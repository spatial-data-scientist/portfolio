(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['luma'] = factory();
  else root['luma'] = factory();})(globalThis, function () {
"use strict";var __exports__=(()=>{var to=Object.create;var he=Object.defineProperty;var ro=Object.getOwnPropertyDescriptor;var no=Object.getOwnPropertyNames;var oo=Object.getPrototypeOf,io=Object.prototype.hasOwnProperty;var so=(r,e,t)=>e in r?he(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var ao=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),co=(r,e)=>{for(var t in e)he(r,t,{get:e[t],enumerable:!0})},we=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of no(e))!io.call(r,o)&&o!==t&&he(r,o,{get:()=>e[o],enumerable:!(n=ro(e,o))||n.enumerable});return r},Le=(r,e,t)=>(we(r,e,"default"),t&&we(t,e,"default")),fr=(r,e,t)=>(t=r!=null?to(oo(r)):{},we(e||!r||!r.__esModule?he(t,"default",{value:r,enumerable:!0}):t,r)),lo=r=>we(he({},"__esModule",{value:!0}),r);var ur=(r,e,t)=>(so(r,typeof e!="symbol"?e+"":e,t),t);var et=ao((Xi,_r)=>{_r.exports=globalThis.luma});var Pe={};co(Pe,{ShaderAssembler:()=>me,ShaderModuleInstance:()=>C,_ShaderModuleInstance:()=>C,_getDependencyGraph:()=>ke,_resolveModules:()=>re,_warp:()=>fe,assembleShaderPairGLSL:()=>Ne,brightnessContrast:()=>Zr,bulgePinch:()=>dn,capitalize:()=>Z,colorHalftone:()=>ln,combineInjects:()=>br,convertToVec4:()=>lt,denoise:()=>Jr,dirlight:()=>Wt,dirlight1:()=>Wn,dotScreen:()=>fn,edgeWork:()=>un,fp32:()=>Qr,fp64:()=>An,fp64arithmetic:()=>Jt,fxaa:()=>gn,generateShaderForModule:()=>Dr,geometry1:()=>yn,getPassthroughFS:()=>Cr,getQualifierDetails:()=>Ir,getShaderInfo:()=>Se,getShaderLayoutFromWGSL:()=>Br,glsl:()=>hr,gouraudLighting:()=>$n,gouraudMaterial:()=>jt,hexagonalPixelate:()=>_n,hueSaturation:()=>en,ink:()=>hn,lighting:()=>Q,lights1:()=>te,magnify:()=>pn,noise:()=>tn,normalizeShaderModule:()=>Fr,pbr:()=>eo,pbrMaterial:()=>Kr,phongLighting:()=>Kn,phongMaterial:()=>$t,picking:()=>qr,project1:()=>Je,random:()=>q,sepia:()=>rn,swirl:()=>mn,tiltShift:()=>sn,triangleBlur:()=>an,typeToChannelCount:()=>Or,typeToChannelSuffix:()=>Rr,vibrance:()=>nn,vignette:()=>on,zoomBlur:()=>cn});Le(Pe,fr(et(),1));var hr=r=>`${r}`;function D(r,e){if(!r)throw new Error(e||"shadertools: assertion failed.")}var tt={number:{type:"number",validate(r,e){return Number.isFinite(r)&&typeof e=="object"&&(e.max===void 0||r<=e.max)&&(e.min===void 0||r>=e.min)}},array:{type:"array",validate(r,e){return Array.isArray(r)||ArrayBuffer.isView(r)}}};function dr(r){let e={};for(let[t,n]of Object.entries(r))e[t]=fo(n);return e}function mr(r,e,t){let n={};for(let[o,i]of Object.entries(e))r&&o in r&&!i.private?(i.validate&&D(i.validate(r[o],i),`${t}: invalid ${o}`),n[o]=r[o]):n[o]=i.value;return n}function fo(r){let e=pr(r);if(e!=="object")return{value:r,...tt[e],type:e};if(typeof r=="object")return r?r.type!==void 0?{...r,...tt[r.type],type:r.type}:r.value===void 0?{type:"object",value:r}:(e=pr(r.value),{...r,...tt[e],type:e}):{type:"object",value:null};throw new Error("props")}function pr(r){return Array.isArray(r)||ArrayBuffer.isView(r)?"array":typeof r}var gr=`#ifdef MODULE_LOGDEPTH
logdepth_adjustPosition(gl_Position);
#endif
`,xr=`#ifdef MODULE_MATERIAL
gl_FragColor = material_filterColor(gl_FragColor);
#endif
#ifdef MODULE_LIGHTING
gl_FragColor = lighting_filterColor(gl_FragColor);
#endif
#ifdef MODULE_FOG
gl_FragColor = fog_filterColor(gl_FragColor);
#endif
#ifdef MODULE_PICKING
gl_FragColor = picking_filterHighlightColor(gl_FragColor);
gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif
#ifdef MODULE_LOGDEPTH
logdepth_setFragDepth();
#endif
`;var uo={vertex:gr,fragment:xr},vr=/void\s+main\s*\([^)]*\)\s*\{\n?/,Ar=/}\n?[^{}]*$/,rt=[],pe="__LUMA_INJECT_DECLARATIONS__";function yr(r){let e={vertex:{},fragment:{}};for(let t in r){let n=r[t],o=_o(t);typeof n=="string"&&(n={order:0,injection:n}),e[o][t]=n}return e}function _o(r){let e=r.slice(0,2);switch(e){case"vs":return"vertex";case"fs":return"fragment";default:throw new Error(e)}}function de(r,e,t,n=!1){let o=e==="vertex";for(let i in t){let a=t[i];a.sort((u,h)=>u.order-h.order),rt.length=a.length;for(let u=0,h=a.length;u<h;++u)rt[u]=a[u].injection;let c=`${rt.join(`
`)}
`;switch(i){case"vs:#decl":o&&(r=r.replace(pe,c));break;case"vs:#main-start":o&&(r=r.replace(vr,u=>u+c));break;case"vs:#main-end":o&&(r=r.replace(Ar,u=>c+u));break;case"fs:#decl":o||(r=r.replace(pe,c));break;case"fs:#main-start":o||(r=r.replace(vr,u=>u+c));break;case"fs:#main-end":o||(r=r.replace(Ar,u=>c+u));break;default:r=r.replace(i,u=>u+c)}}return r=r.replace(pe,""),n&&(r=r.replace(/\}\s*$/,i=>i+uo[e])),r}function br(r){let e={};return D(Array.isArray(r)&&r.length>1),r.forEach(t=>{for(let n in t)e[n]=e[n]?`${e[n]}
${t[n]}`:t[n]}),e}var ho=1,C=class{name;vs;fs;getModuleUniforms;dependencies;deprecations;defines;injections;uniforms={};uniformTypes={};static instantiateModules(e){return e.map(t=>{if(t instanceof C)return t;D(typeof t!="string",`Shader module use by name is deprecated. Import shader module '${JSON.stringify(t)}' and use it directly.`),t.name||(console.warn("shader module has no name"),t.name=`shader-module-${ho++}`);let n=new C(t);return n.dependencies=C.instantiateModules(t.dependencies||[]),n})}constructor(e){let{name:t,vs:n,fs:o,dependencies:i=[],uniformTypes:a={},uniformPropTypes:c={},getUniforms:u,deprecations:h=[],defines:p={},inject:d={}}=e;D(typeof t=="string"),this.name=t,this.vs=n,this.fs=o,this.getModuleUniforms=u,this.dependencies=C.instantiateModules(i),this.deprecations=this._parseDeprecationDefinitions(h),this.defines=p,this.injections=yr(d),this.uniformTypes=a,c&&(this.uniforms=dr(c))}getModuleSource(e){let t;switch(e){case"vertex":t=this.vs||"";break;case"fragment":t=this.fs||"";break;default:D(!1)}let n=this.name.toUpperCase().replace(/[^0-9a-z]/gi,"_");return`// ----- MODULE ${this.name} ---------------

#define MODULE_${n}
${t}

`}getUniforms(e,t){return this.getModuleUniforms?this.getModuleUniforms(e,t):mr(e,this.uniforms,this.name)}getDefines(){return this.defines}checkDeprecations(e,t){this.deprecations.forEach(n=>{n.regex?.test(e)&&(n.deprecated?t.deprecated(n.old,n.new)():t.removed(n.old,n.new)())})}_parseDeprecationDefinitions(e){return e.forEach(t=>{switch(t.type){case"function":t.regex=new RegExp(`\\b${t.old}\\(`);break;default:t.regex=new RegExp(`${t.type} ${t.old};`)}}),e}_defaultGetUniforms(e={}){let t={},n=this.uniforms;for(let o in n){let i=n[o];o in e&&!i.private?(i.validate&&D(i.validate(e[o],i),`${this.name}: invalid ${o}`),t[o]=e[o]):t[o]=i.value}return t}};function nt(r){if(r.source&&r.platformInfo.type==="webgpu")return{...r,vs:void 0,fs:void 0};if(!r.vs)throw new Error("no vertex shader");let e=Pr(r.platformInfo,r.vs),t;return r.fs&&(t=Pr(r.platformInfo,r.fs)),{...r,vs:e,fs:t}}function Pr(r,e){if(typeof e=="string")return e;switch(r.type){case"webgpu":if(e?.wgsl)return e.wgsl;throw new Error("WebGPU does not support GLSL shaders");default:if(e?.glsl)return e.glsl;throw new Error("WebGL does not support WGSL shaders")}}function re(r){let e=C.instantiateModules(r);return po(e)}function po(r){let e={},t={};return ke({modules:r,level:0,moduleMap:e,moduleDepth:t}),Object.keys(t).sort((n,o)=>t[o]-t[n]).map(n=>e[n])}function ke(r){let{modules:e,level:t,moduleMap:n,moduleDepth:o}=r;if(t>=5)throw new Error("Possible loop in shader dependency graph");for(let i of e)n[i.name]=i,(o[i.name]===void 0||o[i.name]<t)&&(o[i.name]=t);for(let i of e)i.dependencies&&ke({modules:i.dependencies,level:t+1,moduleMap:n,moduleDepth:o})}function wr(r){switch(r?.gpu.toLowerCase()){case"apple":return`#define APPLE_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;case"nvidia":return`#define NVIDIA_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;case"intel":return`#define INTEL_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;case"amd":return`#define AMD_GPU
`;default:return`#define DEFAULT_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`}}function kr(r,e){if(Number(r.match(/^#version[ \t]+(\d+)/m)?.[1]||100)!==300)throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");switch(e){case"vertex":return r=Lr(r,mo),r;case"fragment":return r=Lr(r,go),r;default:throw new Error(e)}}var Sr=[[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,`#version 300 es
`],[/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,"textureLod("],[/\btexture(2D|2DProj|Cube)(EXT)?\(/g,"texture("]],mo=[...Sr,[ot("attribute"),"in $1"],[ot("varying"),"out $1"]],go=[...Sr,[ot("varying"),"in $1"]];function Lr(r,e){for(let[t,n]of e)r=r.replace(t,n);return r}function ot(r){return new RegExp(`\\b${r}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`,"g")}function it(r,e){let t="";for(let n in r){let o=r[n];if(t+=`void ${o.signature} {
`,o.header&&(t+=`  ${o.header}`),e[n]){let i=e[n];i.sort((a,c)=>a.order-c.order);for(let a of i)t+=`  ${a.injection}
`}o.footer&&(t+=`  ${o.footer}`),t+=`}
`}return t}function st(r){let e={vertex:{},fragment:{}};for(let t of r){let n,o;typeof t!="string"?(n=t,o=n.hook):(n={},o=t),o=o.trim();let[i,a]=o.split(":"),c=o.replace(/\(.+/,""),u=Object.assign(n,{signature:a});switch(i){case"vs":e.vertex[c]=u;break;case"fs":e.fragment[c]=u;break;default:throw new Error(i)}}return e}function Se(r,e){return{name:xo(r,e),language:"glsl",version:vo(r)}}function xo(r,e="unnamed"){let n=/#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(r);return n?n[1]:e}function vo(r){let e=100,t=r.match(/[^\s]+/g);if(t&&t.length>=2&&t[0]==="#version"){let n=parseInt(t[1],10);Number.isFinite(n)&&(e=n)}if(e!==100&&e!==300)throw new Error(`Invalid GLSL version ${e}`);return e}var Tr=`

${pe}
`,Ao=`precision highp float;
`;function Er(r){let e=re(r.modules||[]);return{source:at(r.platformInfo,{...r,source:r.source,stage:"vertex",modules:e}),getUniforms:ct(e)}}function Mr(r){let e=re(r.modules||[]);return{vs:at(r.platformInfo,{...r,source:r.vs,stage:"vertex",modules:e}),fs:at(r.platformInfo,{...r,source:r.fs,stage:"fragment",modules:e}),getUniforms:ct(e)}}function Ne(r){let{vs:e,fs:t}=r,n=re(r.modules||[]);return{vs:Nr(r.platformInfo,{...r,source:e,stage:"vertex",modules:n}),fs:Nr(r.platformInfo,{...r,source:t,stage:"fragment",modules:n}),getUniforms:ct(n)}}function at(r,e){let{source:t,stage:n,modules:o,hookFunctions:i=[],inject:a={},log:c}=e;D(typeof t=="string","shader source must be a string");let u=t,h="",p=st(i),d={},m={},x={};for(let g in a){let A=typeof a[g]=="string"?{injection:a[g],order:0}:a[g],L=/^(v|f)s:(#)?([\w-]+)$/.exec(g);if(L){let v=L[2],b=L[3];v?b==="decl"?m[g]=[A]:x[g]=[A]:d[g]=[A]}else x[g]=[A]}let w=r.type!=="webgpu"?o:[];for(let g of w){c&&g.checkDeprecations(u,c);let A=g.getModuleSource(n,"wgsl");h+=A;let L=g.injections[n];for(let v in L){let b=/^(v|f)s:#([\w-]+)$/.exec(v);if(b){let y=b[2]==="decl"?m:x;y[v]=y[v]||[],y[v].push(L[v])}else d[v]=d[v]||[],d[v].push(L[v])}}return h+=Tr,h=de(h,n,m),h+=it(p[n],d),h+=u,h=de(h,n,x),h}function Nr(r,e){let{id:t,source:n,stage:o,language:i="glsl",modules:a,defines:c={},hookFunctions:u=[],inject:h={},prologue:p=!0,log:d}=e;D(typeof n=="string","shader source must be a string");let m=i==="glsl"?Se(n).version:-1,x=r.shaderLanguageVersion,w=m===100?"#version 100":"#version 300 es",A=n.split(`
`).slice(1).join(`
`),L={};a.forEach(S=>{Object.assign(L,S.getDefines())}),Object.assign(L,c);let v="";switch(i){case"wgsl":break;case"glsl":v=p?`${w}

// ----- PROLOGUE -------------------------
${yo({id:t,source:n,stage:o})}
${`#define SHADER_TYPE_${o.toUpperCase()}`}
${wr(r)}
${o==="fragment"?Ao:""}

// ----- APPLICATION DEFINES -------------------------

${bo(L)}

`:`${w}
`;break}let b=st(u),P={},y={},k={};for(let S in h){let F=typeof h[S]=="string"?{injection:h[S],order:0}:h[S],M=/^(v|f)s:(#)?([\w-]+)$/.exec(S);if(M){let T=M[2],I=M[3];T?I==="decl"?y[S]=[F]:k[S]=[F]:P[S]=[F]}else k[S]=[F]}for(let S of a){d&&S.checkDeprecations(A,d);let F=S.getModuleSource(o);v+=F;let M=S.injections[o];for(let T in M){let I=/^(v|f)s:#([\w-]+)$/.exec(T);if(I){let R=I[2]==="decl"?y:k;R[T]=R[T]||[],R[T].push(M[T])}else P[T]=P[T]||[],P[T].push(M[T])}}return v+="// ----- MAIN SHADER SOURCE -------------------------",v+=Tr,v=de(v,o,y),v+=it(b[o],P),v+=A,v=de(v,o,k),i==="glsl"&&m!==x&&(v=kr(v,o)),v.trim()}function ct(r){return function(t){let n={};for(let o of r){let i=o.getUniforms(t,n);Object.assign(n,i)}return n}}function yo(r){let{id:e,source:t,stage:n}=r;return e&&t.indexOf("SHADER_NAME")===-1?`
#define SHADER_NAME ${e}_${n}

`:""}function bo(r={}){let e="";for(let t in r){let n=r[t];(n||Number.isFinite(n))&&(e+=`#define ${t.toUpperCase()} ${r[t]}
`)}return e}var ne=class{_hookFunctions=[];_defaultModules=[];static getDefaultShaderAssembler(){return ne.defaultShaderAssembler=ne.defaultShaderAssembler||new ne,ne.defaultShaderAssembler}addDefaultModule(e){this._defaultModules.find(t=>t.name===(typeof e=="string"?e:e.name))||this._defaultModules.push(e)}removeDefaultModule(e){let t=typeof e=="string"?e:e.name;this._defaultModules=this._defaultModules.filter(n=>n.name!==t)}addShaderHook(e,t){t&&(e=Object.assign(t,{hook:e})),this._hookFunctions.push(e)}assembleShader(e){let t=this._getModuleList(e.modules),n=this._hookFunctions,o=nt(e);return{...Er({platformInfo:e.platformInfo,...o,modules:t,hookFunctions:n}),modules:t}}assembleShaderPair(e){let t=nt(e),n=this._getModuleList(e.modules),o=this._hookFunctions,{platformInfo:i}=e;return{...e.platformInfo.shaderLanguage==="wgsl"?Mr({platformInfo:i,...t,modules:n,hookFunctions:o}):Ne({platformInfo:i,...t,modules:n,hookFunctions:o}),modules:n}}_getModuleList(e=[]){let t=new Array(this._defaultModules.length+e.length),n={},o=0;for(let i=0,a=this._defaultModules.length;i<a;++i){let c=this._defaultModules[i],u=c.name;t[o++]=c,n[u]=!0}for(let i=0,a=e.length;i<a;++i){let c=e[i],u=c.name;n[u]||(t[o++]=c,n[u]=!0)}return t.length=o,C.instantiateModules(t)}},me=ne;ur(me,"defaultShaderAssembler");function Fr(r){if(!r.normalized&&(r.normalized=!0,r.uniformPropTypes&&!r.getUniforms)){let e=new C(r);r.getUniforms=e.getUniforms.bind(e)}return r}var Po=`out vec4 transform_output;
void main() {
transform_output = vec4(0);
}`,wo=`#version 300 es
${Po}`;function Ir(r,e){e=Array.isArray(e)?e:[e];let t=r.replace(/^\s+/,"").split(/\s+/),[n,o,i]=t;if(!e.includes(n)||!o||!i)return null;let a=i.split(";")[0];return{qualifier:n,type:o,name:a}}function Cr(r){let{input:e,inputChannels:t,output:n}=r||{};if(!e)return wo;if(!t)throw new Error("inputChannels");let o=Lo(t),i=lt(e,t);return`#version 300 es
in ${o} ${e};
out vec4 ${n};
void main() {
  ${n} = ${i};
}`}function Rr(r){switch(r){case"float":return"x";case"vec2":return"xy";case"vec3":return"xyz";case"vec4":return"xyzw";default:throw new Error(r)}}function Or(r){switch(r){case"float":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4;default:throw new Error(r)}}function Lo(r){switch(r){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";default:throw new Error(`invalid channels: ${r}`)}}function lt(r,e){switch(e){case 1:return`vec4(${r}, 0.0, 0.0, 1.0)`;case 2:return`vec4(${r}, 0.0, 1.0)`;case 3:return`vec4(${r}, 1.0)`;case 4:return r;default:throw new Error(`invalid channels: ${e}`)}}function Z(r){return typeof r=="string"?r.charAt(0).toUpperCase()+r.slice(1):r}function Ur(r,e){return ko(r,e)}function ko(r,e){let t=[];switch(e.uniforms){case"scoped-interface-blocks":case"unscoped-interface-blocks":t.push(`uniform ${Z(r.name)} {`);break;case"uniforms":}for(let[n,o]of Object.entries(r.uniformTypes||{})){let i=So(o);switch(e.uniforms){case"scoped-interface-blocks":t.push(`  ${i} ${n};`);break;case"unscoped-interface-blocks":t.push(`  ${i} ${r.name}_${n};`);break;case"uniforms":t.push(`uniform ${i} ${r.name}_${n};`)}}switch(e.uniforms){case"scoped-interface-blocks":t.push(`} ${r.name};`);break;case"unscoped-interface-blocks":t.push("};");break;case"uniforms":}return t.push(""),t.join(`
`)}function So(r){return{f32:"float",i32:"int",u32:"uint","vec2<f32>":"vec2","vec3<f32>":"vec3","vec4<f32>":"vec4","vec2<i32>":"ivec2","vec3<i32>":"ivec3","vec4<i32>":"ivec4","vec2<u32>":"uvec2","vec3<u32>":"uvec3","vec4<u32>":"uvec4","mat2x2<f32>":"mat2","mat2x3<f32>":"mat2x3","mat2x4<f32>":"mat2x4","mat3x2<f32>":"mat3x2","mat3x3<f32>":"mat3","mat3x4<f32>":"mat3x4","mat4x2<f32>":"mat4x2","mat4x3<f32>":"mat4x3","mat4x4<f32>":"mat4"}[r]}function zr(r,e){return No(r,e)}function No(r,e){let t=[];t.push(`struct ${Z(r.name)} {`);for(let[n,o]of Object.entries(r?.uniformTypes||{})){let i=o;t.push(`  ${n} : ${i};`)}return t.push("};"),t.push(`var<uniform> ${r.name} : ${Z(r.name)};`),t.join(`
`)}function Dr(r,e){switch(e.shaderLanguage){case"glsl":return Ur(r,e);case"wgsl":return zr(r,e)}}var Xr=fr(et(),1);var ft=class{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}},B=class{constructor(){}get isAstNode(){return!0}get astNodeType(){return""}evaluate(e){throw new Error("Cannot evaluate node")}evaluateString(e){return this.evaluate(e).toString()}search(e){}searchBlock(e,t){if(e){t(ae.instance);for(let n of e)n instanceof Array?this.searchBlock(n,t):n.search(t);t(ce.instance)}}},ae=class extends B{};ae.instance=new ae;var ce=class extends B{};ce.instance=new ce;var N=class extends B{constructor(){super()}},xe=class extends N{constructor(e,t,n,o,i,a){super(),this.calls=new Set,this.name=e,this.args=t,this.returnType=n,this.body=o,this.startLine=i,this.endLine=a}get astNodeType(){return"function"}search(e){this.searchBlock(this.body,e)}},ut=class extends N{constructor(e){super(),this.expression=e}get astNodeType(){return"staticAssert"}search(e){this.expression.search(e)}},_t=class extends N{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"while"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}},ht=class extends N{constructor(e){super(),this.body=e}get astNodeType(){return"continuing"}search(e){this.searchBlock(this.body,e)}},pt=class extends N{constructor(e,t,n,o){super(),this.init=e,this.condition=t,this.increment=n,this.body=o}get astNodeType(){return"for"}search(e){var t,n,o;(t=this.init)===null||t===void 0||t.search(e),(n=this.condition)===null||n===void 0||n.search(e),(o=this.increment)===null||o===void 0||o.search(e),this.searchBlock(this.body,e)}},G=class extends N{constructor(e,t,n,o,i){super(),this.name=e,this.type=t,this.storage=n,this.access=o,this.value=i}get astNodeType(){return"var"}search(e){var t;e(this),(t=this.value)===null||t===void 0||t.search(e)}},Te=class extends N{constructor(e,t,n){super(),this.name=e,this.type=t,this.value=n}get astNodeType(){return"override"}search(e){var t;(t=this.value)===null||t===void 0||t.search(e)}},ve=class extends N{constructor(e,t,n,o,i){super(),this.name=e,this.type=t,this.storage=n,this.access=o,this.value=i}get astNodeType(){return"let"}search(e){var t;e(this),(t=this.value)===null||t===void 0||t.search(e)}},Ee=class extends N{constructor(e,t,n,o,i){super(),this.name=e,this.type=t,this.storage=n,this.access=o,this.value=i}get astNodeType(){return"const"}evaluate(e){return this.value.evaluate(e)}search(e){var t;e(this),(t=this.value)===null||t===void 0||t.search(e)}},le;(function(r){r.increment="++",r.decrement="--"})(le||(le={}));(function(r){function e(t){let n=t;if(n=="parse")throw new Error("Invalid value for IncrementOperator");return r[n]}r.parse=e})(le||(le={}));var dt=class extends N{constructor(e,t){super(),this.operator=e,this.variable=t}get astNodeType(){return"increment"}search(e){this.variable.search(e)}},Ae;(function(r){r.assign="=",r.addAssign="+=",r.subtractAssin="-=",r.multiplyAssign="*=",r.divideAssign="/=",r.moduloAssign="%=",r.andAssign="&=",r.orAssign="|=",r.xorAssign="^=",r.shiftLeftAssign="<<=",r.shiftRightAssign=">>="})(Ae||(Ae={}));(function(r){function e(t){let n=t;if(n=="parse")throw new Error("Invalid value for AssignOperator");return n}r.parse=e})(Ae||(Ae={}));var mt=class extends N{constructor(e,t,n){super(),this.operator=e,this.variable=t,this.value=n}get astNodeType(){return"assign"}search(e){this.variable.search(e),this.value.search(e)}},Me=class extends N{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"call"}search(e){for(let t of this.args)t.search(e);e(this)}},gt=class extends N{constructor(e,t){super(),this.body=e,this.continuing=t}get astNodeType(){return"loop"}},xt=class extends N{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"body"}},vt=class extends N{constructor(e,t,n,o){super(),this.condition=e,this.body=t,this.elseif=n,this.else=o}get astNodeType(){return"if"}search(e){this.condition.search(e),this.searchBlock(this.body,e),this.searchBlock(this.elseif,e),this.searchBlock(this.else,e)}},At=class extends N{constructor(e){super(),this.value=e}get astNodeType(){return"return"}search(e){var t;(t=this.value)===null||t===void 0||t.search(e)}},yt=class extends N{constructor(e){super(),this.name=e}get astNodeType(){return"enable"}},bt=class extends N{constructor(e){super(),this.extensions=e}get astNodeType(){return"requires"}},Pt=class extends N{constructor(e,t){super(),this.severity=e,this.rule=t}get astNodeType(){return"diagnostic"}},Fe=class extends N{constructor(e,t){super(),this.name=e,this.type=t}get astNodeType(){return"alias"}},wt=class extends N{constructor(){super()}get astNodeType(){return"discard"}},Lt=class extends N{constructor(){super()}get astNodeType(){return"break"}},kt=class extends N{constructor(){super()}get astNodeType(){return"continue"}},H=class extends N{constructor(e){super(),this.name=e}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}},V=class extends H{constructor(e,t,n,o){super(e),this.members=t,this.startLine=n,this.endLine=o}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(e){for(let t=0;t<this.members.length;t++)if(this.members[t].name==e)return t;return-1}},Ie=class extends H{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"template"}},St=class extends H{constructor(e,t,n,o){super(e),this.storage=t,this.type=n,this.access=o}get astNodeType(){return"pointer"}},Ce=class extends H{constructor(e,t,n,o){super(e),this.attributes=t,this.format=n,this.count=o}get astNodeType(){return"array"}get isArray(){return!0}},J=class extends H{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"sampler"}},U=class extends B{constructor(){super()}},Re=class extends U{constructor(e){super(),this.value=e}get astNodeType(){return"stringExpr"}toString(){return this.value}evaluateString(){return this.value}},$=class extends U{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"createExpr"}search(e){e(this);for(let t of this.args)t.search(e)}},Oe=class extends U{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"callExpr"}evaluate(e){switch(this.name){case"abs":return Math.abs(this.args[0].evaluate(e));case"acos":return Math.acos(this.args[0].evaluate(e));case"acosh":return Math.acosh(this.args[0].evaluate(e));case"asin":return Math.asin(this.args[0].evaluate(e));case"asinh":return Math.asinh(this.args[0].evaluate(e));case"atan":return Math.atan(this.args[0].evaluate(e));case"atan2":return Math.atan2(this.args[0].evaluate(e),this.args[1].evaluate(e));case"atanh":return Math.atanh(this.args[0].evaluate(e));case"ceil":return Math.ceil(this.args[0].evaluate(e));case"clamp":return Math.min(Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e)),this.args[2].evaluate(e));case"cos":return Math.cos(this.args[0].evaluate(e));case"degrees":return this.args[0].evaluate(e)*180/Math.PI;case"distance":return Math.sqrt(Math.pow(this.args[0].evaluate(e)-this.args[1].evaluate(e),2));case"dot":case"exp":return Math.exp(this.args[0].evaluate(e));case"exp2":return Math.pow(2,this.args[0].evaluate(e));case"floor":return Math.floor(this.args[0].evaluate(e));case"fma":return this.args[0].evaluate(e)*this.args[1].evaluate(e)+this.args[2].evaluate(e);case"fract":return this.args[0].evaluate(e)-Math.floor(this.args[0].evaluate(e));case"inverseSqrt":return 1/Math.sqrt(this.args[0].evaluate(e));case"log":return Math.log(this.args[0].evaluate(e));case"log2":return Math.log2(this.args[0].evaluate(e));case"max":return Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e));case"min":return Math.min(this.args[0].evaluate(e),this.args[1].evaluate(e));case"mix":return this.args[0].evaluate(e)*(1-this.args[2].evaluate(e))+this.args[1].evaluate(e)*this.args[2].evaluate(e);case"modf":return this.args[0].evaluate(e)-Math.floor(this.args[0].evaluate(e));case"pow":return Math.pow(this.args[0].evaluate(e),this.args[1].evaluate(e));case"radians":return this.args[0].evaluate(e)*Math.PI/180;case"round":return Math.round(this.args[0].evaluate(e));case"sign":return Math.sign(this.args[0].evaluate(e));case"sin":return Math.sin(this.args[0].evaluate(e));case"sinh":return Math.sinh(this.args[0].evaluate(e));case"saturate":return Math.min(Math.max(this.args[0].evaluate(e),0),1);case"smoothstep":return this.args[0].evaluate(e)*this.args[0].evaluate(e)*(3-2*this.args[0].evaluate(e));case"sqrt":return Math.sqrt(this.args[0].evaluate(e));case"step":return this.args[0].evaluate(e)<this.args[1].evaluate(e)?0:1;case"tan":return Math.tan(this.args[0].evaluate(e));case"tanh":return Math.tanh(this.args[0].evaluate(e));case"trunc":return Math.trunc(this.args[0].evaluate(e));default:throw new Error("Non const function: "+this.name)}}search(e){for(let t of this.args)t.search(e);e(this)}},ye=class extends U{constructor(e){super(),this.name=e}get astNodeType(){return"varExpr"}search(e){e(this),this.postfix&&this.postfix.search(e)}evaluate(e){let t=e.constants.get(this.name);if(!t)throw new Error("Cannot evaluate node");return t.evaluate(e)}},Ue=class extends U{constructor(e,t){super(),this.name=e,this.initializer=t}get astNodeType(){return"constExpr"}evaluate(e){var t,n;if(this.initializer instanceof $){let o=(t=this.postfix)===null||t===void 0?void 0:t.evaluateString(e),i=(n=this.initializer.type)===null||n===void 0?void 0:n.name,a=e.structs.get(i),c=a?.getMemberIndex(o);if(c!=-1)return this.initializer.args[c].evaluate(e);console.log(c)}return this.initializer.evaluate(e)}search(e){this.initializer.search(e)}},ze=class extends U{constructor(e){super(),this.value=e}get astNodeType(){return"literalExpr"}evaluate(){return this.value}},Nt=class extends U{constructor(e,t){super(),this.type=e,this.value=t}get astNodeType(){return"bitcastExpr"}search(e){this.value.search(e)}},Tt=class extends U{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"typecastExpr"}evaluate(e){return this.args[0].evaluate(e)}search(e){this.searchBlock(this.args,e)}},De=class extends U{constructor(e){super(),this.contents=e}get astNodeType(){return"groupExpr"}evaluate(e){return this.contents[0].evaluate(e)}search(e){this.searchBlock(this.contents,e)}},Et=class extends U{constructor(e){super(),this.index=e}search(e){this.index.search(e)}},Ye=class extends U{constructor(){super()}},Mt=class extends Ye{constructor(e,t){super(),this.operator=e,this.right=t}get astNodeType(){return"unaryOp"}evaluate(e){switch(this.operator){case"+":return this.right.evaluate(e);case"-":return-this.right.evaluate(e);case"!":return this.right.evaluate(e)?0:1;case"~":return~this.right.evaluate(e);default:throw new Error("Unknown unary operator: "+this.operator)}}search(e){this.right.search(e)}},Y=class extends Ye{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}get astNodeType(){return"binaryOp"}evaluate(e){switch(this.operator){case"+":return this.left.evaluate(e)+this.right.evaluate(e);case"-":return this.left.evaluate(e)-this.right.evaluate(e);case"*":return this.left.evaluate(e)*this.right.evaluate(e);case"/":return this.left.evaluate(e)/this.right.evaluate(e);case"%":return this.left.evaluate(e)%this.right.evaluate(e);case"==":return this.left.evaluate(e)==this.right.evaluate(e)?1:0;case"!=":return this.left.evaluate(e)!=this.right.evaluate(e)?1:0;case"<":return this.left.evaluate(e)<this.right.evaluate(e)?1:0;case">":return this.left.evaluate(e)>this.right.evaluate(e)?1:0;case"<=":return this.left.evaluate(e)<=this.right.evaluate(e)?1:0;case">=":return this.left.evaluate(e)>=this.right.evaluate(e)?1:0;case"&&":return this.left.evaluate(e)&&this.right.evaluate(e)?1:0;case"||":return this.left.evaluate(e)||this.right.evaluate(e)?1:0;default:throw new Error(`Unknown operator ${this.operator}`)}}search(e){this.left.search(e),this.right.search(e)}},Xe=class extends B{constructor(){super()}},Ft=class extends Xe{constructor(e,t){super(),this.selector=e,this.body=t}get astNodeType(){return"case"}search(e){this.searchBlock(this.body,e)}},It=class extends Xe{constructor(e){super(),this.body=e}get astNodeType(){return"default"}search(e){this.searchBlock(this.body,e)}},Ct=class extends B{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"argument"}},Rt=class extends B{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"elseif"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}},Ot=class extends B{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"member"}},Ut=class extends B{constructor(e,t){super(),this.name=e,this.value=t}get astNodeType(){return"attribute"}},_,f;(function(r){r[r.token=0]="token",r[r.keyword=1]="keyword",r[r.reserved=2]="reserved"})(f||(f={}));var l=class{constructor(e,t,n){this.name=e,this.type=t,this.rule=n}toString(){return this.name}},s=class{};_=s;s.none=new l("",f.reserved,"");s.eof=new l("EOF",f.token,"");s.reserved={asm:new l("asm",f.reserved,"asm"),bf16:new l("bf16",f.reserved,"bf16"),do:new l("do",f.reserved,"do"),enum:new l("enum",f.reserved,"enum"),f16:new l("f16",f.reserved,"f16"),f64:new l("f64",f.reserved,"f64"),handle:new l("handle",f.reserved,"handle"),i8:new l("i8",f.reserved,"i8"),i16:new l("i16",f.reserved,"i16"),i64:new l("i64",f.reserved,"i64"),mat:new l("mat",f.reserved,"mat"),premerge:new l("premerge",f.reserved,"premerge"),regardless:new l("regardless",f.reserved,"regardless"),typedef:new l("typedef",f.reserved,"typedef"),u8:new l("u8",f.reserved,"u8"),u16:new l("u16",f.reserved,"u16"),u64:new l("u64",f.reserved,"u64"),unless:new l("unless",f.reserved,"unless"),using:new l("using",f.reserved,"using"),vec:new l("vec",f.reserved,"vec"),void:new l("void",f.reserved,"void")};s.keywords={array:new l("array",f.keyword,"array"),atomic:new l("atomic",f.keyword,"atomic"),bool:new l("bool",f.keyword,"bool"),f32:new l("f32",f.keyword,"f32"),i32:new l("i32",f.keyword,"i32"),mat2x2:new l("mat2x2",f.keyword,"mat2x2"),mat2x3:new l("mat2x3",f.keyword,"mat2x3"),mat2x4:new l("mat2x4",f.keyword,"mat2x4"),mat3x2:new l("mat3x2",f.keyword,"mat3x2"),mat3x3:new l("mat3x3",f.keyword,"mat3x3"),mat3x4:new l("mat3x4",f.keyword,"mat3x4"),mat4x2:new l("mat4x2",f.keyword,"mat4x2"),mat4x3:new l("mat4x3",f.keyword,"mat4x3"),mat4x4:new l("mat4x4",f.keyword,"mat4x4"),ptr:new l("ptr",f.keyword,"ptr"),sampler:new l("sampler",f.keyword,"sampler"),sampler_comparison:new l("sampler_comparison",f.keyword,"sampler_comparison"),struct:new l("struct",f.keyword,"struct"),texture_1d:new l("texture_1d",f.keyword,"texture_1d"),texture_2d:new l("texture_2d",f.keyword,"texture_2d"),texture_2d_array:new l("texture_2d_array",f.keyword,"texture_2d_array"),texture_3d:new l("texture_3d",f.keyword,"texture_3d"),texture_cube:new l("texture_cube",f.keyword,"texture_cube"),texture_cube_array:new l("texture_cube_array",f.keyword,"texture_cube_array"),texture_multisampled_2d:new l("texture_multisampled_2d",f.keyword,"texture_multisampled_2d"),texture_storage_1d:new l("texture_storage_1d",f.keyword,"texture_storage_1d"),texture_storage_2d:new l("texture_storage_2d",f.keyword,"texture_storage_2d"),texture_storage_2d_array:new l("texture_storage_2d_array",f.keyword,"texture_storage_2d_array"),texture_storage_3d:new l("texture_storage_3d",f.keyword,"texture_storage_3d"),texture_depth_2d:new l("texture_depth_2d",f.keyword,"texture_depth_2d"),texture_depth_2d_array:new l("texture_depth_2d_array",f.keyword,"texture_depth_2d_array"),texture_depth_cube:new l("texture_depth_cube",f.keyword,"texture_depth_cube"),texture_depth_cube_array:new l("texture_depth_cube_array",f.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new l("texture_depth_multisampled_2d",f.keyword,"texture_depth_multisampled_2d"),texture_external:new l("texture_external",f.keyword,"texture_external"),u32:new l("u32",f.keyword,"u32"),vec2:new l("vec2",f.keyword,"vec2"),vec3:new l("vec3",f.keyword,"vec3"),vec4:new l("vec4",f.keyword,"vec4"),bitcast:new l("bitcast",f.keyword,"bitcast"),block:new l("block",f.keyword,"block"),break:new l("break",f.keyword,"break"),case:new l("case",f.keyword,"case"),continue:new l("continue",f.keyword,"continue"),continuing:new l("continuing",f.keyword,"continuing"),default:new l("default",f.keyword,"default"),diagnostic:new l("diagnostic",f.keyword,"diagnostic"),discard:new l("discard",f.keyword,"discard"),else:new l("else",f.keyword,"else"),enable:new l("enable",f.keyword,"enable"),fallthrough:new l("fallthrough",f.keyword,"fallthrough"),false:new l("false",f.keyword,"false"),fn:new l("fn",f.keyword,"fn"),for:new l("for",f.keyword,"for"),function:new l("function",f.keyword,"function"),if:new l("if",f.keyword,"if"),let:new l("let",f.keyword,"let"),const:new l("const",f.keyword,"const"),loop:new l("loop",f.keyword,"loop"),while:new l("while",f.keyword,"while"),private:new l("private",f.keyword,"private"),read:new l("read",f.keyword,"read"),read_write:new l("read_write",f.keyword,"read_write"),return:new l("return",f.keyword,"return"),requires:new l("requires",f.keyword,"requires"),storage:new l("storage",f.keyword,"storage"),switch:new l("switch",f.keyword,"switch"),true:new l("true",f.keyword,"true"),alias:new l("alias",f.keyword,"alias"),type:new l("type",f.keyword,"type"),uniform:new l("uniform",f.keyword,"uniform"),var:new l("var",f.keyword,"var"),override:new l("override",f.keyword,"override"),workgroup:new l("workgroup",f.keyword,"workgroup"),write:new l("write",f.keyword,"write"),r8unorm:new l("r8unorm",f.keyword,"r8unorm"),r8snorm:new l("r8snorm",f.keyword,"r8snorm"),r8uint:new l("r8uint",f.keyword,"r8uint"),r8sint:new l("r8sint",f.keyword,"r8sint"),r16uint:new l("r16uint",f.keyword,"r16uint"),r16sint:new l("r16sint",f.keyword,"r16sint"),r16float:new l("r16float",f.keyword,"r16float"),rg8unorm:new l("rg8unorm",f.keyword,"rg8unorm"),rg8snorm:new l("rg8snorm",f.keyword,"rg8snorm"),rg8uint:new l("rg8uint",f.keyword,"rg8uint"),rg8sint:new l("rg8sint",f.keyword,"rg8sint"),r32uint:new l("r32uint",f.keyword,"r32uint"),r32sint:new l("r32sint",f.keyword,"r32sint"),r32float:new l("r32float",f.keyword,"r32float"),rg16uint:new l("rg16uint",f.keyword,"rg16uint"),rg16sint:new l("rg16sint",f.keyword,"rg16sint"),rg16float:new l("rg16float",f.keyword,"rg16float"),rgba8unorm:new l("rgba8unorm",f.keyword,"rgba8unorm"),rgba8unorm_srgb:new l("rgba8unorm_srgb",f.keyword,"rgba8unorm_srgb"),rgba8snorm:new l("rgba8snorm",f.keyword,"rgba8snorm"),rgba8uint:new l("rgba8uint",f.keyword,"rgba8uint"),rgba8sint:new l("rgba8sint",f.keyword,"rgba8sint"),bgra8unorm:new l("bgra8unorm",f.keyword,"bgra8unorm"),bgra8unorm_srgb:new l("bgra8unorm_srgb",f.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new l("rgb10a2unorm",f.keyword,"rgb10a2unorm"),rg11b10float:new l("rg11b10float",f.keyword,"rg11b10float"),rg32uint:new l("rg32uint",f.keyword,"rg32uint"),rg32sint:new l("rg32sint",f.keyword,"rg32sint"),rg32float:new l("rg32float",f.keyword,"rg32float"),rgba16uint:new l("rgba16uint",f.keyword,"rgba16uint"),rgba16sint:new l("rgba16sint",f.keyword,"rgba16sint"),rgba16float:new l("rgba16float",f.keyword,"rgba16float"),rgba32uint:new l("rgba32uint",f.keyword,"rgba32uint"),rgba32sint:new l("rgba32sint",f.keyword,"rgba32sint"),rgba32float:new l("rgba32float",f.keyword,"rgba32float"),static_assert:new l("static_assert",f.keyword,"static_assert")};s.tokens={decimal_float_literal:new l("decimal_float_literal",f.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),hex_float_literal:new l("hex_float_literal",f.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),int_literal:new l("int_literal",f.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new l("uint_literal",f.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),ident:new l("ident",f.token,/[_a-zA-Z][0-9a-zA-Z_]*/),and:new l("and",f.token,"&"),and_and:new l("and_and",f.token,"&&"),arrow:new l("arrow ",f.token,"->"),attr:new l("attr",f.token,"@"),forward_slash:new l("forward_slash",f.token,"/"),bang:new l("bang",f.token,"!"),bracket_left:new l("bracket_left",f.token,"["),bracket_right:new l("bracket_right",f.token,"]"),brace_left:new l("brace_left",f.token,"{"),brace_right:new l("brace_right",f.token,"}"),colon:new l("colon",f.token,":"),comma:new l("comma",f.token,","),equal:new l("equal",f.token,"="),equal_equal:new l("equal_equal",f.token,"=="),not_equal:new l("not_equal",f.token,"!="),greater_than:new l("greater_than",f.token,">"),greater_than_equal:new l("greater_than_equal",f.token,">="),shift_right:new l("shift_right",f.token,">>"),less_than:new l("less_than",f.token,"<"),less_than_equal:new l("less_than_equal",f.token,"<="),shift_left:new l("shift_left",f.token,"<<"),modulo:new l("modulo",f.token,"%"),minus:new l("minus",f.token,"-"),minus_minus:new l("minus_minus",f.token,"--"),period:new l("period",f.token,"."),plus:new l("plus",f.token,"+"),plus_plus:new l("plus_plus",f.token,"++"),or:new l("or",f.token,"|"),or_or:new l("or_or",f.token,"||"),paren_left:new l("paren_left",f.token,"("),paren_right:new l("paren_right",f.token,")"),semicolon:new l("semicolon",f.token,";"),star:new l("star",f.token,"*"),tilde:new l("tilde",f.token,"~"),underscore:new l("underscore",f.token,"_"),xor:new l("xor",f.token,"^"),plus_equal:new l("plus_equal",f.token,"+="),minus_equal:new l("minus_equal",f.token,"-="),times_equal:new l("times_equal",f.token,"*="),division_equal:new l("division_equal",f.token,"/="),modulo_equal:new l("modulo_equal",f.token,"%="),and_equal:new l("and_equal",f.token,"&="),or_equal:new l("or_equal",f.token,"|="),xor_equal:new l("xor_equal",f.token,"^="),shift_right_equal:new l("shift_right_equal",f.token,">>="),shift_left_equal:new l("shift_left_equal",f.token,"<<=")};s.simpleTokens={"@":_.tokens.attr,"{":_.tokens.brace_left,"}":_.tokens.brace_right,":":_.tokens.colon,",":_.tokens.comma,"(":_.tokens.paren_left,")":_.tokens.paren_right,";":_.tokens.semicolon};s.literalTokens={"&":_.tokens.and,"&&":_.tokens.and_and,"->":_.tokens.arrow,"/":_.tokens.forward_slash,"!":_.tokens.bang,"[":_.tokens.bracket_left,"]":_.tokens.bracket_right,"=":_.tokens.equal,"==":_.tokens.equal_equal,"!=":_.tokens.not_equal,">":_.tokens.greater_than,">=":_.tokens.greater_than_equal,">>":_.tokens.shift_right,"<":_.tokens.less_than,"<=":_.tokens.less_than_equal,"<<":_.tokens.shift_left,"%":_.tokens.modulo,"-":_.tokens.minus,"--":_.tokens.minus_minus,".":_.tokens.period,"+":_.tokens.plus,"++":_.tokens.plus_plus,"|":_.tokens.or,"||":_.tokens.or_or,"*":_.tokens.star,"~":_.tokens.tilde,_:_.tokens.underscore,"^":_.tokens.xor,"+=":_.tokens.plus_equal,"-=":_.tokens.minus_equal,"*=":_.tokens.times_equal,"/=":_.tokens.division_equal,"%=":_.tokens.modulo_equal,"&=":_.tokens.and_equal,"|=":_.tokens.or_equal,"^=":_.tokens.xor_equal,">>=":_.tokens.shift_right_equal,"<<=":_.tokens.shift_left_equal};s.regexTokens={decimal_float_literal:_.tokens.decimal_float_literal,hex_float_literal:_.tokens.hex_float_literal,int_literal:_.tokens.int_literal,uint_literal:_.tokens.uint_literal,ident:_.tokens.ident};s.storage_class=[_.keywords.function,_.keywords.private,_.keywords.workgroup,_.keywords.uniform,_.keywords.storage];s.access_mode=[_.keywords.read,_.keywords.write,_.keywords.read_write];s.sampler_type=[_.keywords.sampler,_.keywords.sampler_comparison];s.sampled_texture_type=[_.keywords.texture_1d,_.keywords.texture_2d,_.keywords.texture_2d_array,_.keywords.texture_3d,_.keywords.texture_cube,_.keywords.texture_cube_array];s.multisampled_texture_type=[_.keywords.texture_multisampled_2d];s.storage_texture_type=[_.keywords.texture_storage_1d,_.keywords.texture_storage_2d,_.keywords.texture_storage_2d_array,_.keywords.texture_storage_3d];s.depth_texture_type=[_.keywords.texture_depth_2d,_.keywords.texture_depth_2d_array,_.keywords.texture_depth_cube,_.keywords.texture_depth_cube_array,_.keywords.texture_depth_multisampled_2d];s.texture_external_type=[_.keywords.texture_external];s.any_texture_type=[..._.sampled_texture_type,..._.multisampled_texture_type,..._.storage_texture_type,..._.depth_texture_type,..._.texture_external_type];s.texel_format=[_.keywords.r8unorm,_.keywords.r8snorm,_.keywords.r8uint,_.keywords.r8sint,_.keywords.r16uint,_.keywords.r16sint,_.keywords.r16float,_.keywords.rg8unorm,_.keywords.rg8snorm,_.keywords.rg8uint,_.keywords.rg8sint,_.keywords.r32uint,_.keywords.r32sint,_.keywords.r32float,_.keywords.rg16uint,_.keywords.rg16sint,_.keywords.rg16float,_.keywords.rgba8unorm,_.keywords.rgba8unorm_srgb,_.keywords.rgba8snorm,_.keywords.rgba8uint,_.keywords.rgba8sint,_.keywords.bgra8unorm,_.keywords.bgra8unorm_srgb,_.keywords.rgb10a2unorm,_.keywords.rg11b10float,_.keywords.rg32uint,_.keywords.rg32sint,_.keywords.rg32float,_.keywords.rgba16uint,_.keywords.rgba16sint,_.keywords.rgba16float,_.keywords.rgba32uint,_.keywords.rgba32sint,_.keywords.rgba32float];s.const_literal=[_.tokens.int_literal,_.tokens.uint_literal,_.tokens.decimal_float_literal,_.tokens.hex_float_literal,_.keywords.true,_.keywords.false];s.literal_or_ident=[_.tokens.ident,_.tokens.int_literal,_.tokens.uint_literal,_.tokens.decimal_float_literal,_.tokens.hex_float_literal];s.element_count_expression=[_.tokens.int_literal,_.tokens.uint_literal,_.tokens.ident];s.template_types=[_.keywords.vec2,_.keywords.vec3,_.keywords.vec4,_.keywords.mat2x2,_.keywords.mat2x3,_.keywords.mat2x4,_.keywords.mat3x2,_.keywords.mat3x3,_.keywords.mat3x4,_.keywords.mat4x2,_.keywords.mat4x3,_.keywords.mat4x4,_.keywords.atomic,_.keywords.bitcast,..._.any_texture_type];s.attribute_name=[_.tokens.ident,_.keywords.block,_.keywords.diagnostic];s.assignment_operators=[_.tokens.equal,_.tokens.plus_equal,_.tokens.minus_equal,_.tokens.times_equal,_.tokens.division_equal,_.tokens.modulo_equal,_.tokens.and_equal,_.tokens.or_equal,_.tokens.xor_equal,_.tokens.shift_right_equal,_.tokens.shift_left_equal];s.increment_operators=[_.tokens.plus_plus,_.tokens.minus_minus];var Be=class{constructor(e,t,n){this.type=e,this.lexeme=t,this.line=n}toString(){return this.lexeme}isTemplateType(){return s.template_types.indexOf(this.type)!=-1}isArrayType(){return this.type==s.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}},zt=class{constructor(e){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=e??""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new Be(s.eof,"",this._line)),this._tokens}scanToken(){let e=this._advance();if(e==`
`)return this._line++,!0;if(this._isWhitespace(e))return!0;if(e=="/"){if(this._peekAhead()=="/"){for(;e!=`
`;){if(this._isAtEnd())return!0;e=this._advance()}return this._line++,!0}else if(this._peekAhead()=="*"){this._advance();let a=1;for(;a>0;){if(this._isAtEnd())return!0;if(e=this._advance(),e==`
`)this._line++;else if(e=="*"){if(this._peekAhead()=="/"&&(this._advance(),a--,a==0))return!0}else e=="/"&&this._peekAhead()=="*"&&(this._advance(),a++)}return!0}}let t=s.simpleTokens[e];if(t)return this._addToken(t),!0;let n=s.none,o=this._isAlpha(e),i=e==="_";if(this._isAlphaNumeric(e)){let a=this._peekAhead();for(;this._isAlphaNumeric(a);)e+=this._advance(),a=this._peekAhead()}if(o){let a=s.keywords[e];if(a)return this._addToken(a),!0}if(o||i)return this._addToken(s.tokens.ident),!0;for(;;){let a=this._findType(e),c=this._peekAhead();if(e==">"&&(c==">"||c=="=")){let u=!1,h=this._tokens.length-1;for(let p=0;p<5&&h>=0;++p,--h)if(this._tokens[h].type===s.tokens.less_than){h>0&&this._tokens[h-1].isArrayOrTemplateType()&&(u=!0);break}if(u)return this._addToken(a),!0}if(a===s.none){let u=e,h=0,p=2;for(let d=0;d<p;++d)if(u+=this._peekAhead(d),a=this._findType(u),a!==s.none){h=d;break}if(a===s.none)return n===s.none?!1:(this._current--,this._addToken(n),!0);e=u,this._current+=h+1}if(n=a,this._isAtEnd())break;e+=this._advance()}return n===s.none?!1:(this._addToken(n),!0)}_findType(e){for(let n in s.regexTokens){let o=s.regexTokens[n];if(this._match(e,o.rule))return o}let t=s.literalTokens[e];return t||s.none}_match(e,t){let n=t.exec(e);return n&&n.index==0&&n[0]==e}_isAtEnd(){return this._current>=this._source.length}_isAlpha(e){return e>="a"&&e<="z"||e>="A"&&e<="Z"}_isAlphaNumeric(e){return e>="a"&&e<="z"||e>="A"&&e<="Z"||e=="_"||e>="0"&&e<="9"}_isWhitespace(e){return e==" "||e=="	"||e=="\r"}_advance(e=0){let t=this._source[this._current];return e=e||0,e++,this._current+=e,t}_peekAhead(e=0){return e=e||0,this._current+e>=this._source.length?"\0":this._source[this._current+e]}_addToken(e){let t=this._source.substring(this._start,this._current);this._tokens.push(new Be(e,t,this._line))}},Dt=class{constructor(){this._tokens=[],this._current=0,this._currentLine=0,this._context=new ft,this._deferArrayCountEval=[]}parse(e){this._initialize(e),this._deferArrayCountEval.length=0;let t=[];for(;!this._isAtEnd();){let n=this._global_decl_or_directive();if(!n)break;t.push(n)}if(this._deferArrayCountEval.length>0){for(let n of this._deferArrayCountEval){let o=n.arrayType,i=n.countNode;if(i instanceof ye){let c=i.name,u=this._context.constants.get(c);if(u)try{let h=u.evaluate(this._context);o.count=h}catch{}}}this._deferArrayCountEval.length=0}return t}_initialize(e){if(e)if(typeof e=="string"){let t=new zt(e);this._tokens=t.scanTokens()}else this._tokens=e;else this._tokens=[];this._current=0}_error(e,t){return{token:e,message:t,toString:function(){return`${t}`}}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==s.eof}_match(e){if(e instanceof l)return this._check(e)?(this._advance(),!0):!1;for(let t=0,n=e.length;t<n;++t){let o=e[t];if(this._check(o))return this._advance(),!0}return!1}_consume(e,t){if(this._check(e))return this._advance();throw this._error(this._peek(),t)}_check(e){if(this._isAtEnd())return!1;let t=this._peek();if(e instanceof Array){let n=t.type;return e.indexOf(n)!=-1}return t.type==e}_advance(){var e,t;return this._currentLine=(t=(e=this._peek())===null||e===void 0?void 0:e.line)!==null&&t!==void 0?t:-1,this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(s.tokens.semicolon)&&!this._isAtEnd(););if(this._match(s.keywords.alias)){let t=this._type_alias();return this._consume(s.tokens.semicolon,"Expected ';'"),t}if(this._match(s.keywords.diagnostic)){let t=this._diagnostic();return this._consume(s.tokens.semicolon,"Expected ';'"),t}if(this._match(s.keywords.requires)){let t=this._requires_directive();return this._consume(s.tokens.semicolon,"Expected ';'"),t}if(this._match(s.keywords.enable)){let t=this._enable_directive();return this._consume(s.tokens.semicolon,"Expected ';'"),t}let e=this._attribute();if(this._check(s.keywords.var)){let t=this._global_variable_decl();return t!=null&&(t.attributes=e),this._consume(s.tokens.semicolon,"Expected ';'."),t}if(this._check(s.keywords.override)){let t=this._override_variable_decl();return t!=null&&(t.attributes=e),this._consume(s.tokens.semicolon,"Expected ';'."),t}if(this._check(s.keywords.let)){let t=this._global_let_decl();return t!=null&&(t.attributes=e),this._consume(s.tokens.semicolon,"Expected ';'."),t}if(this._check(s.keywords.const)){let t=this._global_const_decl();return t!=null&&(t.attributes=e),this._consume(s.tokens.semicolon,"Expected ';'."),t}if(this._check(s.keywords.struct)){let t=this._struct_decl();return t!=null&&(t.attributes=e),t}if(this._check(s.keywords.fn)){let t=this._function_decl();return t!=null&&(t.attributes=e),t}return null}_function_decl(){if(!this._match(s.keywords.fn))return null;let e=this._currentLine,t=this._consume(s.tokens.ident,"Expected function name.").toString();this._consume(s.tokens.paren_left,"Expected '(' for function arguments.");let n=[];if(!this._check(s.tokens.paren_right))do{if(this._check(s.tokens.paren_right))break;let c=this._attribute(),u=this._consume(s.tokens.ident,"Expected argument name.").toString();this._consume(s.tokens.colon,"Expected ':' for argument type.");let h=this._attribute(),p=this._type_decl();p!=null&&(p.attributes=h,n.push(new Ct(u,p,c)))}while(this._match(s.tokens.comma));this._consume(s.tokens.paren_right,"Expected ')' after function arguments.");let o=null;if(this._match(s.tokens.arrow)){let c=this._attribute();o=this._type_decl(),o!=null&&(o.attributes=c)}let i=this._compound_statement(),a=this._currentLine;return new xe(t,n,o,i,e,a)}_compound_statement(){let e=[];for(this._consume(s.tokens.brace_left,"Expected '{' for block.");!this._check(s.tokens.brace_right);){let t=this._statement();t!==null&&e.push(t)}return this._consume(s.tokens.brace_right,"Expected '}' for block."),e}_statement(){for(;this._match(s.tokens.semicolon)&&!this._isAtEnd(););if(this._check(s.tokens.attr)&&this._attribute(),this._check(s.keywords.if))return this._if_statement();if(this._check(s.keywords.switch))return this._switch_statement();if(this._check(s.keywords.loop))return this._loop_statement();if(this._check(s.keywords.for))return this._for_statement();if(this._check(s.keywords.while))return this._while_statement();if(this._check(s.keywords.continuing))return this._continuing_statement();if(this._check(s.keywords.static_assert))return this._static_assert_statement();if(this._check(s.tokens.brace_left))return this._compound_statement();let e=null;return this._check(s.keywords.return)?e=this._return_statement():this._check([s.keywords.var,s.keywords.let,s.keywords.const])?e=this._variable_statement():this._match(s.keywords.discard)?e=new wt:this._match(s.keywords.break)?e=new Lt:this._match(s.keywords.continue)?e=new kt:e=this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement(),e!=null&&this._consume(s.tokens.semicolon,"Expected ';' after statement."),e}_static_assert_statement(){if(!this._match(s.keywords.static_assert))return null;let e=this._optional_paren_expression();return new ut(e)}_while_statement(){if(!this._match(s.keywords.while))return null;let e=this._optional_paren_expression();this._check(s.tokens.attr)&&this._attribute();let t=this._compound_statement();return new _t(e,t)}_continuing_statement(){if(!this._match(s.keywords.continuing))return null;let e=this._compound_statement();return new ht(e)}_for_statement(){if(!this._match(s.keywords.for))return null;this._consume(s.tokens.paren_left,"Expected '('.");let e=this._check(s.tokens.semicolon)?null:this._for_init();this._consume(s.tokens.semicolon,"Expected ';'.");let t=this._check(s.tokens.semicolon)?null:this._short_circuit_or_expression();this._consume(s.tokens.semicolon,"Expected ';'.");let n=this._check(s.tokens.paren_right)?null:this._for_increment();this._consume(s.tokens.paren_right,"Expected ')'."),this._check(s.tokens.attr)&&this._attribute();let o=this._compound_statement();return new pt(e,t,n,o)}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(s.keywords.var)){let e=this._variable_decl();if(e===null)throw this._error(this._peek(),"Variable declaration expected.");let t=null;return this._match(s.tokens.equal)&&(t=this._short_circuit_or_expression()),new G(e.name,e.type,e.storage,e.access,t)}if(this._match(s.keywords.let)){let e=this._consume(s.tokens.ident,"Expected name for let.").toString(),t=null;if(this._match(s.tokens.colon)){let o=this._attribute();t=this._type_decl(),t!=null&&(t.attributes=o)}this._consume(s.tokens.equal,"Expected '=' for let.");let n=this._short_circuit_or_expression();return new ve(e,t,null,null,n)}if(this._match(s.keywords.const)){let e=this._consume(s.tokens.ident,"Expected name for const.").toString(),t=null;if(this._match(s.tokens.colon)){let o=this._attribute();t=this._type_decl(),t!=null&&(t.attributes=o)}this._consume(s.tokens.equal,"Expected '=' for const.");let n=this._short_circuit_or_expression();return new Ee(e,t,null,null,n)}return null}_increment_decrement_statement(){let e=this._current,t=this._unary_expression();if(t==null)return null;if(!this._check(s.increment_operators))return this._current=e,null;let n=this._consume(s.increment_operators,"Expected increment operator");return new dt(n.type===s.tokens.plus_plus?le.increment:le.decrement,t)}_assignment_statement(){let e=null;if(this._check(s.tokens.brace_right))return null;let t=this._match(s.tokens.underscore);if(t||(e=this._unary_expression()),!t&&e==null)return null;let n=this._consume(s.assignment_operators,"Expected assignment operator."),o=this._short_circuit_or_expression();return new mt(Ae.parse(n.lexeme),e,o)}_func_call_statement(){if(!this._check(s.tokens.ident))return null;let e=this._current,t=this._consume(s.tokens.ident,"Expected function name."),n=this._argument_expression_list();return n===null?(this._current=e,null):new Me(t.lexeme,n)}_loop_statement(){if(!this._match(s.keywords.loop))return null;this._check(s.tokens.attr)&&this._attribute(),this._consume(s.tokens.brace_left,"Expected '{' for loop.");let e=[],t=this._statement();for(;t!==null;){if(Array.isArray(t))for(let o of t)e.push(o);else e.push(t);t=this._statement()}let n=null;return this._match(s.keywords.continuing)&&(n=this._compound_statement()),this._consume(s.tokens.brace_right,"Expected '}' for loop."),new gt(e,n)}_switch_statement(){if(!this._match(s.keywords.switch))return null;let e=this._optional_paren_expression();this._check(s.tokens.attr)&&this._attribute(),this._consume(s.tokens.brace_left,"Expected '{' for switch.");let t=this._switch_body();if(t==null||t.length==0)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(s.tokens.brace_right,"Expected '}' for switch."),new xt(e,t)}_switch_body(){let e=[];if(this._match(s.keywords.case)){let t=this._case_selectors();this._match(s.tokens.colon),this._check(s.tokens.attr)&&this._attribute(),this._consume(s.tokens.brace_left,"Exected '{' for switch case.");let n=this._case_body();this._consume(s.tokens.brace_right,"Exected '}' for switch case."),e.push(new Ft(t,n))}if(this._match(s.keywords.default)){this._match(s.tokens.colon),this._check(s.tokens.attr)&&this._attribute(),this._consume(s.tokens.brace_left,"Exected '{' for switch default.");let t=this._case_body();this._consume(s.tokens.brace_right,"Exected '}' for switch default."),e.push(new It(t))}if(this._check([s.keywords.default,s.keywords.case])){let t=this._switch_body();e.push(t[0])}return e}_case_selectors(){let e=[this._shift_expression()];for(;this._match(s.tokens.comma);)e.push(this._shift_expression());return e}_case_body(){if(this._match(s.keywords.fallthrough))return this._consume(s.tokens.semicolon,"Expected ';'"),[];let e=this._statement();if(e==null)return[];e instanceof Array||(e=[e]);let t=this._case_body();return t.length==0?e:[...e,t[0]]}_if_statement(){if(!this._match(s.keywords.if))return null;let e=this._optional_paren_expression();this._check(s.tokens.attr)&&this._attribute();let t=this._compound_statement(),n=[];this._match_elseif()&&(this._check(s.tokens.attr)&&this._attribute(),n=this._elseif_statement(n));let o=null;return this._match(s.keywords.else)&&(this._check(s.tokens.attr)&&this._attribute(),o=this._compound_statement()),new vt(e,t,n,o)}_match_elseif(){return this._tokens[this._current].type===s.keywords.else&&this._tokens[this._current+1].type===s.keywords.if?(this._advance(),this._advance(),!0):!1}_elseif_statement(e=[]){let t=this._optional_paren_expression(),n=this._compound_statement();return e.push(new Rt(t,n)),this._match_elseif()&&(this._check(s.tokens.attr)&&this._attribute(),this._elseif_statement(e)),e}_return_statement(){if(!this._match(s.keywords.return))return null;let e=this._short_circuit_or_expression();return new At(e)}_short_circuit_or_expression(){let e=this._short_circuit_and_expr();for(;this._match(s.tokens.or_or);)e=new Y(this._previous().toString(),e,this._short_circuit_and_expr());return e}_short_circuit_and_expr(){let e=this._inclusive_or_expression();for(;this._match(s.tokens.and_and);)e=new Y(this._previous().toString(),e,this._inclusive_or_expression());return e}_inclusive_or_expression(){let e=this._exclusive_or_expression();for(;this._match(s.tokens.or);)e=new Y(this._previous().toString(),e,this._exclusive_or_expression());return e}_exclusive_or_expression(){let e=this._and_expression();for(;this._match(s.tokens.xor);)e=new Y(this._previous().toString(),e,this._and_expression());return e}_and_expression(){let e=this._equality_expression();for(;this._match(s.tokens.and);)e=new Y(this._previous().toString(),e,this._equality_expression());return e}_equality_expression(){let e=this._relational_expression();return this._match([s.tokens.equal_equal,s.tokens.not_equal])?new Y(this._previous().toString(),e,this._relational_expression()):e}_relational_expression(){let e=this._shift_expression();for(;this._match([s.tokens.less_than,s.tokens.greater_than,s.tokens.less_than_equal,s.tokens.greater_than_equal]);)e=new Y(this._previous().toString(),e,this._shift_expression());return e}_shift_expression(){let e=this._additive_expression();for(;this._match([s.tokens.shift_left,s.tokens.shift_right]);)e=new Y(this._previous().toString(),e,this._additive_expression());return e}_additive_expression(){let e=this._multiplicative_expression();for(;this._match([s.tokens.plus,s.tokens.minus]);)e=new Y(this._previous().toString(),e,this._multiplicative_expression());return e}_multiplicative_expression(){let e=this._unary_expression();for(;this._match([s.tokens.star,s.tokens.forward_slash,s.tokens.modulo]);)e=new Y(this._previous().toString(),e,this._unary_expression());return e}_unary_expression(){return this._match([s.tokens.minus,s.tokens.bang,s.tokens.tilde,s.tokens.star,s.tokens.and])?new Mt(this._previous().toString(),this._unary_expression()):this._singular_expression()}_singular_expression(){let e=this._primary_expression(),t=this._postfix_expression();return t&&(e.postfix=t),e}_postfix_expression(){if(this._match(s.tokens.bracket_left)){let e=this._short_circuit_or_expression();this._consume(s.tokens.bracket_right,"Expected ']'.");let t=new Et(e),n=this._postfix_expression();return n&&(t.postfix=n),t}if(this._match(s.tokens.period)){let e=this._consume(s.tokens.ident,"Expected member name."),t=this._postfix_expression(),n=new Re(e.lexeme);return t&&(n.postfix=t),n}return null}_getStruct(e){return this._context.aliases.has(e)?this._context.aliases.get(e).type:this._context.structs.has(e)?this._context.structs.get(e):null}_primary_expression(){if(this._match(s.tokens.ident)){let n=this._previous().toString();if(this._check(s.tokens.paren_left)){let o=this._argument_expression_list(),i=this._getStruct(n);return i!=null?new $(i,o):new Oe(n,o)}if(this._context.constants.has(n)){let o=this._context.constants.get(n);return new Ue(n,o.value)}return new ye(n)}if(this._match(s.const_literal))return new ze(parseFloat(this._previous().toString()));if(this._check(s.tokens.paren_left))return this._paren_expression();if(this._match(s.keywords.bitcast)){this._consume(s.tokens.less_than,"Expected '<'.");let n=this._type_decl();this._consume(s.tokens.greater_than,"Expected '>'.");let o=this._paren_expression();return new Nt(n,o)}let e=this._type_decl(),t=this._argument_expression_list();return new Tt(e,t)}_argument_expression_list(){if(!this._match(s.tokens.paren_left))return null;let e=[];do{if(this._check(s.tokens.paren_right))break;let t=this._short_circuit_or_expression();e.push(t)}while(this._match(s.tokens.comma));return this._consume(s.tokens.paren_right,"Expected ')' for agument list"),e}_optional_paren_expression(){this._match(s.tokens.paren_left);let e=this._short_circuit_or_expression();return this._match(s.tokens.paren_right),new De([e])}_paren_expression(){this._consume(s.tokens.paren_left,"Expected '('.");let e=this._short_circuit_or_expression();return this._consume(s.tokens.paren_right,"Expected ')'."),new De([e])}_struct_decl(){if(!this._match(s.keywords.struct))return null;let e=this._currentLine,t=this._consume(s.tokens.ident,"Expected name for struct.").toString();this._consume(s.tokens.brace_left,"Expected '{' for struct body.");let n=[];for(;!this._check(s.tokens.brace_right);){let a=this._attribute(),c=this._consume(s.tokens.ident,"Expected variable name.").toString();this._consume(s.tokens.colon,"Expected ':' for struct member type.");let u=this._attribute(),h=this._type_decl();h!=null&&(h.attributes=u),this._check(s.tokens.brace_right)?this._match(s.tokens.comma):this._consume(s.tokens.comma,"Expected ',' for struct member."),n.push(new Ot(c,h,a))}this._consume(s.tokens.brace_right,"Expected '}' after struct body.");let o=this._currentLine,i=new V(t,n,e,o);return this._context.structs.set(t,i),i}_global_variable_decl(){let e=this._variable_decl();return e&&this._match(s.tokens.equal)&&(e.value=this._const_expression()),e}_override_variable_decl(){let e=this._override_decl();return e&&this._match(s.tokens.equal)&&(e.value=this._const_expression()),e}_global_const_decl(){if(!this._match(s.keywords.const))return null;let e=this._consume(s.tokens.ident,"Expected variable name"),t=null;if(this._match(s.tokens.colon)){let i=this._attribute();t=this._type_decl(),t!=null&&(t.attributes=i)}let n=null;if(this._match(s.tokens.equal)){let i=this._short_circuit_or_expression();if(i instanceof $)n=i;else if(i instanceof Ue&&i.initializer instanceof $)n=i.initializer;else try{let a=i.evaluate(this._context);n=new ze(a)}catch{n=i}}let o=new Ee(e.toString(),t,"","",n);return this._context.constants.set(o.name,o),o}_global_let_decl(){if(!this._match(s.keywords.let))return null;let e=this._consume(s.tokens.ident,"Expected variable name"),t=null;if(this._match(s.tokens.colon)){let o=this._attribute();t=this._type_decl(),t!=null&&(t.attributes=o)}let n=null;return this._match(s.tokens.equal)&&(n=this._const_expression()),new ve(e.toString(),t,"","",n)}_const_expression(){if(this._match(s.const_literal))return new Re(this._previous().toString());let e=this._type_decl();this._consume(s.tokens.paren_left,"Expected '('.");let t=[];for(;!this._check(s.tokens.paren_right)&&(t.push(this._const_expression()),!!this._check(s.tokens.comma));)this._advance();return this._consume(s.tokens.paren_right,"Expected ')'."),new $(e,t)}_variable_decl(){if(!this._match(s.keywords.var))return null;let e="",t="";this._match(s.tokens.less_than)&&(e=this._consume(s.storage_class,"Expected storage_class.").toString(),this._match(s.tokens.comma)&&(t=this._consume(s.access_mode,"Expected access_mode.").toString()),this._consume(s.tokens.greater_than,"Expected '>'."));let n=this._consume(s.tokens.ident,"Expected variable name"),o=null;if(this._match(s.tokens.colon)){let i=this._attribute();o=this._type_decl(),o!=null&&(o.attributes=i)}return new G(n.toString(),o,e,t,null)}_override_decl(){if(!this._match(s.keywords.override))return null;let e=this._consume(s.tokens.ident,"Expected variable name"),t=null;if(this._match(s.tokens.colon)){let n=this._attribute();t=this._type_decl(),t!=null&&(t.attributes=n)}return new Te(e.toString(),t,null)}_diagnostic(){this._consume(s.tokens.paren_left,"Expected '('");let e=this._consume(s.tokens.ident,"Expected severity control name.");this._consume(s.tokens.comma,"Expected ','");let t=this._consume(s.tokens.ident,"Expected diagnostic rule name.");return this._consume(s.tokens.paren_right,"Expected ')'"),new Pt(e.toString(),t.toString())}_enable_directive(){let e=this._consume(s.tokens.ident,"identity expected.");return new yt(e.toString())}_requires_directive(){let e=[this._consume(s.tokens.ident,"identity expected.").toString()];for(;this._match(s.tokens.comma);){let t=this._consume(s.tokens.ident,"identity expected.");e.push(t.toString())}return new bt(e)}_type_alias(){let e=this._consume(s.tokens.ident,"identity expected.");this._consume(s.tokens.equal,"Expected '=' for type alias.");let t=this._type_decl();if(t===null)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(t.name)&&(t=this._context.aliases.get(t.name).type);let n=new Fe(e.toString(),t);return this._context.aliases.set(n.name,n),n}_type_decl(){if(this._check([s.tokens.ident,...s.texel_format,s.keywords.bool,s.keywords.f32,s.keywords.i32,s.keywords.u32])){let n=this._advance(),o=n.toString();return this._context.structs.has(o)?this._context.structs.get(o):this._context.aliases.has(o)?this._context.aliases.get(o).type:new H(n.toString())}let e=this._texture_sampler_types();if(e)return e;if(this._check(s.template_types)){let n=this._advance().toString(),o=null,i=null;return this._match(s.tokens.less_than)&&(o=this._type_decl(),i=null,this._match(s.tokens.comma)&&(i=this._consume(s.access_mode,"Expected access_mode for pointer").toString()),this._consume(s.tokens.greater_than,"Expected '>' for type.")),new Ie(n,o,i)}if(this._match(s.keywords.ptr)){let n=this._previous().toString();this._consume(s.tokens.less_than,"Expected '<' for pointer.");let o=this._consume(s.storage_class,"Expected storage_class for pointer");this._consume(s.tokens.comma,"Expected ',' for pointer.");let i=this._type_decl(),a=null;return this._match(s.tokens.comma)&&(a=this._consume(s.access_mode,"Expected access_mode for pointer").toString()),this._consume(s.tokens.greater_than,"Expected '>' for pointer."),new St(n,o.toString(),i,a)}let t=this._attribute();if(this._match(s.keywords.array)){let n=null,o=-1,i=this._previous(),a=null;if(this._match(s.tokens.less_than)){n=this._type_decl(),this._context.aliases.has(n.name)&&(n=this._context.aliases.get(n.name).type);let u="";if(this._match(s.tokens.comma)){a=this._shift_expression();try{u=a.evaluate(this._context).toString(),a=null}catch{u="1"}}this._consume(s.tokens.greater_than,"Expected '>' for array."),o=u?parseInt(u):0}let c=new Ce(i.toString(),t,n,o);return a&&this._deferArrayCountEval.push({arrayType:c,countNode:a}),c}return null}_texture_sampler_types(){if(this._match(s.sampler_type))return new J(this._previous().toString(),null,null);if(this._match(s.depth_texture_type))return new J(this._previous().toString(),null,null);if(this._match(s.sampled_texture_type)||this._match(s.multisampled_texture_type)){let e=this._previous();this._consume(s.tokens.less_than,"Expected '<' for sampler type.");let t=this._type_decl();return this._consume(s.tokens.greater_than,"Expected '>' for sampler type."),new J(e.toString(),t,null)}if(this._match(s.storage_texture_type)){let e=this._previous();this._consume(s.tokens.less_than,"Expected '<' for sampler type.");let t=this._consume(s.texel_format,"Invalid texel format.").toString();this._consume(s.tokens.comma,"Expected ',' after texel format.");let n=this._consume(s.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(s.tokens.greater_than,"Expected '>' for sampler type."),new J(e.toString(),t,n)}return null}_attribute(){let e=[];for(;this._match(s.tokens.attr);){let t=this._consume(s.attribute_name,"Expected attribute name"),n=new Ut(t.toString(),null);if(this._match(s.tokens.paren_left)){if(n.value=this._consume(s.literal_or_ident,"Expected attribute value").toString(),this._check(s.tokens.comma)){this._advance();do{let o=this._consume(s.literal_or_ident,"Expected attribute value").toString();n.value instanceof Array||(n.value=[n.value]),n.value.push(o)}while(this._match(s.tokens.comma))}this._consume(s.tokens.paren_right,"Expected ')'")}e.push(n)}return e.length==0?null:e}},K=class{constructor(e,t){this.name=e,this.attributes=t,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}},Qe=class{constructor(e,t,n){this.name=e,this.type=t,this.attributes=n,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray?this.type.format:this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}},oe=class extends K{constructor(e,t){super(e,t),this.members=[],this.align=0,this.startLine=-1,this.endLine=-1,this.inUse=!1}get isStruct(){return!0}},ge=class extends K{constructor(e,t){super(e,t),this.count=0,this.stride=0}get isArray(){return!0}},qe=class extends K{constructor(e,t,n,o){super(e,n),this.format=t,this.access=o}get isTemplate(){return!0}},j;(function(r){r[r.Uniform=0]="Uniform",r[r.Storage=1]="Storage",r[r.Texture=2]="Texture",r[r.Sampler=3]="Sampler",r[r.StorageTexture=4]="StorageTexture"})(j||(j={}));var ie=class{constructor(e,t,n,o,i,a,c){this.name=e,this.type=t,this.group=n,this.binding=o,this.attributes=i,this.resourceType=a,this.access=c}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray?this.type.format:this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}},Yt=class{constructor(e,t){this.name=e,this.type=t}},se=class{constructor(e,t){this.align=e,this.size=t}},Xt=class{constructor(e,t,n,o){this.name=e,this.type=t,this.locationType=n,this.location=o,this.interpolation=null}},Ve=class{constructor(e,t,n,o){this.name=e,this.type=t,this.locationType=n,this.location=o}},Bt=class{constructor(e,t=null){this.stage=null,this.inputs=[],this.outputs=[],this.resources=[],this.startLine=-1,this.endLine=-1,this.inUse=!1,this.calls=new Set,this.name=e,this.stage=t}},Qt=class{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}},qt=class{constructor(e,t,n,o){this.name=e,this.type=t,this.attributes=n,this.id=o}},Vt=class{constructor(e){this.resources=null,this.inUse=!1,this.info=null,this.node=e}},X=class{constructor(e){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new Qt,this.functions=[],this._types=new Map,this._functions=new Map,e&&this.update(e)}_isStorageTexture(e){return e.name=="texture_storage_1d"||e.name=="texture_storage_2d"||e.name=="texture_storage_2d_array"||e.name=="texture_storage_3d"}update(e){let n=new Dt().parse(e);for(let o of n)o instanceof xe&&this._functions.set(o.name,new Vt(o));for(let o of n)if(o instanceof V){let i=this._getTypeInfo(o,null);i instanceof oe&&this.structs.push(i)}for(let o of n){if(o instanceof Fe){this.aliases.push(this._getAliasInfo(o));continue}if(o instanceof Te){let i=o,a=this._getAttributeNum(i.attributes,"id",0),c=i.type!=null?this._getTypeInfo(i.type,i.attributes):null;this.overrides.push(new qt(i.name,c,i.attributes,a));continue}if(this._isUniformVar(o)){let i=o,a=this._getAttributeNum(i.attributes,"group",0),c=this._getAttributeNum(i.attributes,"binding",0),u=this._getTypeInfo(i.type,i.attributes),h=new ie(i.name,u,a,c,i.attributes,j.Uniform,i.access);this.uniforms.push(h);continue}if(this._isStorageVar(o)){let i=o,a=this._getAttributeNum(i.attributes,"group",0),c=this._getAttributeNum(i.attributes,"binding",0),u=this._getTypeInfo(i.type,i.attributes),h=this._isStorageTexture(u),p=new ie(i.name,u,a,c,i.attributes,h?j.StorageTexture:j.Storage,i.access);this.storage.push(p);continue}if(this._isTextureVar(o)){let i=o,a=this._getAttributeNum(i.attributes,"group",0),c=this._getAttributeNum(i.attributes,"binding",0),u=this._getTypeInfo(i.type,i.attributes),h=this._isStorageTexture(u),p=new ie(i.name,u,a,c,i.attributes,h?j.StorageTexture:j.Texture,i.access);h?this.storage.push(p):this.textures.push(p);continue}if(this._isSamplerVar(o)){let i=o,a=this._getAttributeNum(i.attributes,"group",0),c=this._getAttributeNum(i.attributes,"binding",0),u=this._getTypeInfo(i.type,i.attributes),h=new ie(i.name,u,a,c,i.attributes,j.Sampler,i.access);this.samplers.push(h);continue}if(o instanceof xe){let i=this._getAttribute(o,"vertex"),a=this._getAttribute(o,"fragment"),c=this._getAttribute(o,"compute"),u=i||a||c,h=new Bt(o.name,u?.name);h.startLine=o.startLine,h.endLine=o.endLine,this.functions.push(h),this._functions.get(o.name).info=h,u&&(this._functions.get(o.name).inUse=!0,h.inUse=!0,h.resources=this._findResources(o,!!u),h.inputs=this._getInputs(o.args),h.outputs=this._getOutputs(o.returnType),this.entry[u.name].push(h));continue}}for(let o of this._functions.values())o.info&&(o.info.inUse=o.inUse,this._addCalls(o.node,o.info.calls));for(let o of this.uniforms)this._markStructsInUse(o.type);for(let o of this.storage)this._markStructsInUse(o.type)}_markStructsInUse(e){if(e.isStruct){e.inUse=!0;for(let t of e.members)this._markStructsInUse(t.type)}else if(e.isArray)this._markStructsInUse(e.format);else if(e.isTemplate)this._markStructsInUse(e.format);else{let t=this._getAlias(e.name);t&&this._markStructsInUse(t)}}_addCalls(e,t){var n;for(let o of e.calls){let i=(n=this._functions.get(o.name))===null||n===void 0?void 0:n.info;i&&t.add(i)}}findResource(e,t){for(let n of this.uniforms)if(n.group==e&&n.binding==t)return n;for(let n of this.storage)if(n.group==e&&n.binding==t)return n;for(let n of this.textures)if(n.group==e&&n.binding==t)return n;for(let n of this.samplers)if(n.group==e&&n.binding==t)return n;return null}_findResource(e){for(let t of this.uniforms)if(t.name==e)return t;for(let t of this.storage)if(t.name==e)return t;for(let t of this.textures)if(t.name==e)return t;for(let t of this.samplers)if(t.name==e)return t;return null}_markStructsFromAST(e){let t=this._getTypeInfo(e,null);this._markStructsInUse(t)}_findResources(e,t){let n=[],o=this,i=[];return e.search(a=>{if(a instanceof ae)i.push({});else if(a instanceof ce)i.pop();else if(a instanceof G){let c=a;t&&c.type!==null&&this._markStructsFromAST(c.type),i.length>0&&(i[i.length-1][c.name]=c)}else if(a instanceof $){let c=a;t&&c.type!==null&&this._markStructsFromAST(c.type)}else if(a instanceof ve){let c=a;t&&c.type!==null&&this._markStructsFromAST(c.type),i.length>0&&(i[i.length-1][c.name]=c)}else if(a instanceof ye){let c=a;if(i.length>0&&i[i.length-1][c.name])return;let u=o._findResource(c.name);u&&n.push(u)}else if(a instanceof Oe){let c=a,u=o._functions.get(c.name);u&&(t&&(u.inUse=!0),e.calls.add(u.node),u.resources===null&&(u.resources=o._findResources(u.node,t)),n.push(...u.resources))}else if(a instanceof Me){let c=a,u=o._functions.get(c.name);u&&(t&&(u.inUse=!0),e.calls.add(u.node),u.resources===null&&(u.resources=o._findResources(u.node,t)),n.push(...u.resources))}}),[...new Map(n.map(a=>[a.name,a])).values()]}getBindGroups(){let e=[];function t(n,o){n>=e.length&&(e.length=n+1),e[n]===void 0&&(e[n]=[]),o>=e[n].length&&(e[n].length=o+1)}for(let n of this.uniforms){t(n.group,n.binding);let o=e[n.group];o[n.binding]=n}for(let n of this.storage){t(n.group,n.binding);let o=e[n.group];o[n.binding]=n}for(let n of this.textures){t(n.group,n.binding);let o=e[n.group];o[n.binding]=n}for(let n of this.samplers){t(n.group,n.binding);let o=e[n.group];o[n.binding]=n}return e}_getOutputs(e,t=void 0){if(t===void 0&&(t=[]),e instanceof V)this._getStructOutputs(e,t);else{let n=this._getOutputInfo(e);n!==null&&t.push(n)}return t}_getStructOutputs(e,t){for(let n of e.members)if(n.type instanceof V)this._getStructOutputs(n.type,t);else{let o=this._getAttribute(n,"location")||this._getAttribute(n,"builtin");if(o!==null){let i=this._getTypeInfo(n.type,n.type.attributes),a=this._parseInt(o.value),c=new Ve(n.name,i,o.name,a);t.push(c)}}}_getOutputInfo(e){let t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(t!==null){let n=this._getTypeInfo(e,e.attributes),o=this._parseInt(t.value);return new Ve("",n,t.name,o)}return null}_getInputs(e,t=void 0){t===void 0&&(t=[]);for(let n of e)if(n.type instanceof V)this._getStructInputs(n.type,t);else{let o=this._getInputInfo(n);o!==null&&t.push(o)}return t}_getStructInputs(e,t){for(let n of e.members)if(n.type instanceof V)this._getStructInputs(n.type,t);else{let o=this._getInputInfo(n);o!==null&&t.push(o)}}_getInputInfo(e){let t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(t!==null){let n=this._getAttribute(e,"interpolation"),o=this._getTypeInfo(e.type,e.attributes),i=this._parseInt(t.value),a=new Xt(e.name,o,t.name,i);return n!==null&&(a.interpolation=this._parseString(n.value)),a}return null}_parseString(e){return e instanceof Array&&(e=e[0]),e}_parseInt(e){e instanceof Array&&(e=e[0]);let t=parseInt(e);return isNaN(t)?e:t}_getAlias(e){for(let t of this.aliases)if(t.name==e)return t.type;return null}_getAliasInfo(e){return new Yt(e.name,this._getTypeInfo(e.type,null))}_getTypeInfo(e,t){if(this._types.has(e))return this._types.get(e);if(e instanceof Ce){let o=e,i=this._getTypeInfo(o.format,o.attributes),a=new ge(o.name,t);return a.format=i,a.count=o.count,this._types.set(e,a),this._updateTypeInfo(a),a}if(e instanceof V){let o=e,i=new oe(o.name,t);i.startLine=o.startLine,i.endLine=o.endLine;for(let a of o.members){let c=this._getTypeInfo(a.type,a.attributes);i.members.push(new Qe(a.name,c,a.attributes))}return this._types.set(e,i),this._updateTypeInfo(i),i}if(e instanceof J){let o=e,i=o.format instanceof H,a=o.format?i?this._getTypeInfo(o.format,null):new K(o.format,null):null,c=new qe(o.name,a,t,o.access);return this._types.set(e,c),this._updateTypeInfo(c),c}if(e instanceof Ie){let o=e,i=o.format?this._getTypeInfo(o.format,null):null,a=new qe(o.name,i,t,o.access);return this._types.set(e,a),this._updateTypeInfo(a),a}let n=new K(e.name,t);return this._types.set(e,n),this._updateTypeInfo(n),n}_updateTypeInfo(e){var t,n;let o=this._getTypeSize(e);if(e.size=(t=o?.size)!==null&&t!==void 0?t:0,e instanceof ge){let i=this._getTypeSize(e.format);e.stride=(n=i?.size)!==null&&n!==void 0?n:0,this._updateTypeInfo(e.format)}e instanceof oe&&this._updateStructInfo(e)}_updateStructInfo(e){var t;let n=0,o=0,i=0,a=0;for(let c=0,u=e.members.length;c<u;++c){let h=e.members[c],p=this._getTypeSize(h);if(!p)continue;(t=this._getAlias(h.type.name))!==null&&t!==void 0||h.type;let d=p.align,m=p.size;n=this._roundUp(d,n+o),o=m,i=n,a=Math.max(a,d),h.offset=n,h.size=m,this._updateTypeInfo(h.type)}e.size=this._roundUp(a,i+o),e.align=a}_getTypeSize(e){var t;if(e==null)return null;let n=this._getAttributeNum(e.attributes,"size",0),o=this._getAttributeNum(e.attributes,"align",0);if(e instanceof Qe&&(e=e.type),e instanceof K){let i=this._getAlias(e.name);i!==null&&(e=i)}{let i=X._typeInfo[e.name];if(i!==void 0){let a=e.format==="f16"?2:1;return new se(Math.max(o,i.align/a),Math.max(n,i.size/a))}}{let i=X._typeInfo[e.name.substring(0,e.name.length-1)];if(i){let a=e.name[e.name.length-1]==="h"?2:1;return new se(Math.max(o,i.align/a),Math.max(n,i.size/a))}}if(e instanceof ge){let i=e,a=8,c=8,u=this._getTypeSize(i.format);u!==null&&(c=u.size,a=u.align);let h=i.count,p=this._getAttributeNum((t=e?.attributes)!==null&&t!==void 0?t:null,"stride",this._roundUp(a,c));return c=h*p,n&&(c=n),new se(Math.max(o,a),Math.max(n,c))}if(e instanceof oe){let i=0,a=0,c=0,u=0,h=0;for(let p of e.members){let d=this._getTypeSize(p.type);d!==null&&(i=Math.max(d.align,i),c=this._roundUp(d.align,c+u),u=d.size,h=c)}return a=this._roundUp(i,h+u),new se(Math.max(o,i),Math.max(n,a))}return null}_isUniformVar(e){return e instanceof G&&e.storage=="uniform"}_isStorageVar(e){return e instanceof G&&e.storage=="storage"}_isTextureVar(e){return e instanceof G&&e.type!==null&&X._textureTypes.indexOf(e.type.name)!=-1}_isSamplerVar(e){return e instanceof G&&e.type!==null&&X._samplerTypes.indexOf(e.type.name)!=-1}_getAttribute(e,t){let n=e;if(!n||!n.attributes)return null;let o=n.attributes;for(let i of o)if(i.name==t)return i;return null}_getAttributeNum(e,t,n){if(e===null)return n;for(let o of e)if(o.name==t){let i=o!==null&&o.value!==null?o.value:n;return i instanceof Array&&(i=i[0]),typeof i=="number"?i:typeof i=="string"?parseInt(i):n}return n}_roundUp(e,t){return Math.ceil(t/e)*e}};X._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}};X._textureTypes=s.any_texture_type.map(r=>r.name);X._samplerTypes=s.sampler_type.map(r=>r.name);function Br(r){let e={attributes:[],bindings:[]},t;try{t=To(r)}catch(i){return Xr.log.error(i.message)(),e}for(let i of t.uniforms){let a=[];for(let c of i.type?.members||[])a.push({name:c.name,type:Yr(c.type)});e.bindings.push({type:"uniform",name:i.name,location:i.binding,group:i.group,members:a})}let n=t.entry.vertex[0],o=n?.inputs.length||0;for(let i=0;i<o;i++){let a=n.inputs[i];if(a.locationType==="location"){let c=Yr(a.type);e.attributes.push({name:a.name,location:Number(a.location),type:c})}}return e}function Yr(r){return r.format?`${r.name}<${r.format.name}>`:r.name}function To(r){try{return new X(r)}catch(e){if(e instanceof Error)throw e;let t="WGSL parse error";throw typeof e=="object"&&e?.message&&(t+=`: ${e.message} `),typeof e=="object"&&e?.token&&(t+=e.token.line||""),new Error(t,{cause:e})}}var Eo=`float random(vec3 scale, float seed) {
return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}
`,q={name:"random",fs:Eo};var Mo=`#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;
const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;
const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;
const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;
float sin_taylor_fp32(float a) {
float r, s, t, x;
if (a == 0.0) {
return 0.0;
}
x = -a * a;
s = a;
r = a;
r = r * x;
t = r * INVERSE_FACTORIAL_3;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_5;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_7;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_9;
s = s + t;
return s;
}
void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
if (a == 0.0) {
sin_t = 0.0;
cos_t = 1.0;
}
sin_t = sin_taylor_fp32(a);
cos_t = sqrt(1.0 - sin_t * sin_t);
}
float tan_taylor_fp32(float a) {
float sin_a;
float cos_a;
if (a == 0.0) {
return 0.0;
}
float z = floor(a / TWO_PI);
float r = a - TWO_PI * z;
float t;
float q = floor(r / PI_2 + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return 1.0 / 0.0;
}
t = r - PI_2 * q;
q = floor(t / PI_16 + 0.5);
int k = int(q);
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return 1.0 / 0.0;
} else {
t = t - PI_16 * q;
}
float u = 0.0;
float v = 0.0;
float sin_t, cos_t;
float s, c;
sincos_taylor_fp32(t, sin_t, cos_t);
if (k == 0) {
s = sin_t;
c = cos_t;
} else {
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0;
v = SIN_TABLE_0;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1;
v = SIN_TABLE_1;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2;
v = SIN_TABLE_2;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3;
v = SIN_TABLE_3;
}
if (k > 0) {
s = u * sin_t + v * cos_t;
c = u * cos_t - v * sin_t;
} else {
s = u * sin_t - v * cos_t;
c = u * cos_t + v * sin_t;
}
}
if (j == 0) {
sin_a = s;
cos_a = c;
} else if (j == 1) {
sin_a = c;
cos_a = -s;
} else if (j == -1) {
sin_a = -c;
cos_a = s;
} else {
sin_a = -s;
cos_a = -c;
}
return sin_a / cos_a;
}
#endif
float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
return tan_taylor_fp32(a);
#else
return tan(a);
#endif
}
`,Qr={name:"fp32",vs:Mo};var Fo=new Float32Array([0,1,1,1]),Io=`uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
out vec4 picking_vRGBcolor_Avalid;
vec3 picking_normalizeColor(vec3 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
vec4 picking_normalizeColor(vec4 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
bool picking_isColorZero(vec3 color) {
return dot(color, vec3(1.0)) < 0.00001;
}
bool picking_isColorValid(vec3 color) {
return dot(color, vec3(1.0)) > 0.00001;
}
bool isVertexHighlighted(vec3 vertexColor) {
vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
return
bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}
void picking_setPickingColor(vec3 pickingColor) {
pickingColor = picking_normalizeColor(pickingColor);
if (bool(picking.isActive)) {
picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));
if (!bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = pickingColor;
}
} else {
picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
}
}
void picking_setPickingAttribute(float value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.r = value;
}
}
void picking_setPickingAttribute(vec2 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rg = value;
}
}
void picking_setPickingAttribute(vec3 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = value;
}
}
`,Co=`uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
in vec4 picking_vRGBcolor_Avalid;
vec4 picking_filterHighlightColor(vec4 color) {
if (picking.isActive > 0.5) {
return color;
}
bool selected = bool(picking_vRGBcolor_Avalid.a);
if (selected) {
float highLightAlpha = picking.highlightColor.a;
float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
float highLightRatio = highLightAlpha / blendedAlpha;
vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
return vec4(blendedRGB, blendedAlpha);
} else {
return color;
}
}
vec4 picking_filterPickingColor(vec4 color) {
if (bool(picking.isActive)) {
if (picking_vRGBcolor_Avalid.a == 0.0) {
discard;
}
return picking_vRGBcolor_Avalid;
}
return color;
}
vec4 picking_filterColor(vec4 color) {
vec4 highlightColor = picking_filterHighlightColor(color);
return picking_filterPickingColor(highlightColor);
}
`,qr={name:"picking",vs:Io,fs:Co,uniformTypes:{isActive:"f32",isAttribute:"f32",isHighlightActive:"f32",useFloatColors:"f32",highlightedObjectColor:"vec3<f32>",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,isAttribute:!1,isHighlightActive:!1,useFloatColors:!0,highlightedObjectColor:new Float32Array([0,0,0]),highlightColor:Fo},getUniforms:Ro};function Ro(r={},e){let t={};if(r.highlightedObjectColor!==void 0)if(r.highlightedObjectColor===null)t.isHighlightActive=!1;else{t.isHighlightActive=!0;let n=r.highlightedObjectColor.slice(0,3);t.highlightedObjectColor=n}if(r.highlightColor){let n=Array.from(r.highlightColor,o=>o/255);Number.isFinite(n[3])||(n[3]=1),t.highlightColor=n}return r.isActive!==void 0&&(t.isActive=Boolean(r.isActive),t.isAttribute=Boolean(r.isAttribute)),r.useFloatColors!==void 0&&(t.useFloatColors=Boolean(r.useFloatColors)),t}var Gt=`precision highp int;
struct AmbientLight {
vec3 color;
};
struct PointLight {
vec3 color;
vec3 position;
vec3 attenuation;
};
struct DirectionalLight {
vec3 color;
vec3 direction;
};
uniform lightingUniforms {
int enabled;
int pointLightCount;
int directionalLightCount;
vec3 ambientColor;
int lightType;
vec3 lightColor;
vec3 lightDirection;
vec3 lightPosition;
vec3 lightAttenuation;
} lighting;
PointLight lighting_getPointLight(int index) {
return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}
DirectionalLight lighting_getDirectionalLight(int index) {
return DirectionalLight(lighting.lightColor, lighting.lightDirection);
}
float getPointLightAttenuation(PointLight pointLight, float distance) {
return pointLight.attenuation.x
+ pointLight.attenuation.y * distance
+ pointLight.attenuation.z * distance * distance;
}
`;var Oo=5,Uo=255,be;(function(r){r[r.POINT=0]="POINT",r[r.DIRECTIONAL=1]="DIRECTIONAL"})(be||(be={}));var Q={name:"lighting",vs:Gt,fs:Gt,getUniforms(r,e){return zo(r)},defines:{MAX_LIGHTS:Oo},uniformTypes:{enabled:"i32",ambientLightColor:"vec3<f32>",numberOfLights:"i32",lightType:"i32",lightColor:"vec3<f32>",lightPosition:"vec3<f32>",lightDirection:"vec3<f32>",lightAttenuation:"vec3<f32>"},defaultUniforms:{enabled:1,ambientLightColor:[.1,.1,.1],numberOfLights:0,lightType:be.POINT,lightColor:[1,1,1],lightPosition:[1,1,2],lightDirection:[1,1,1],lightAttenuation:[1,1,1]}};function zo(r,e={}){if(r=r&&{...r},!r)return{...Q.defaultUniforms};r.lights&&(r={...r,...Yo(r.lights),lights:void 0});let{ambientLight:t,pointLights:n,directionalLights:o}=r||{};if(!(t||n&&n.length>0||o&&o.length>0))return{...Q.defaultUniforms,enabled:0};let a={...Q.defaultUniforms,...e,...Do({ambientLight:t,pointLights:n,directionalLights:o})};return r.enabled!==void 0&&(a.enabled=r.enabled?1:0),a}function Do({ambientLight:r,pointLights:e=[],directionalLights:t=[]}){let n={};n.ambientLightColor=Ht(r);let o=0;for(let i of e)n.lightType=be.POINT,n.lightColor=Ht(i),n.lightPosition=i.position,n.lightAttenuation=[i.attenuation||1,0,0],o++;for(let i of t)n.lightType=be.DIRECTIONAL,n.lightColor=Ht(i),n.lightPosition=i.position,n.lightDirection=i.direction,o++;return n.numberOfLights=o,n}function Yo(r){let e={pointLights:[],directionalLights:[]};for(let t of r||[])switch(t.type){case"ambient":e.ambientLight=t;break;case"directional":e.directionalLights?.push(t);break;case"point":e.pointLights?.push(t);break;default:}return e}function Ht(r={}){let{color:e=[0,0,0],intensity:t=1}=r;return e.map(n=>n*t/Uo)}var Xo=`out vec3 dirlight_vNormal;
void dirlight_setNormal(vec3 normal) {
dirlight_vNormal = normalize(normal);
}
`,Bo=`uniform dirlightUniforms {
vec3 lightDirection;
} dirlight;
in vec3 dirlight_vNormal;
vec4 dirlight_filterColor(vec4 color) {
float d = abs(dot(dirlight_vNormal, normalize(dirlight.lightDirection)));
return vec4(color.rgb * d, color.a);
}
`,Wt={name:"dirlight",dependencies:[],vs:Xo,fs:Bo,uniformTypes:{lightDirection:"vec3<f32>"},defaultUniforms:{lightDirection:new Float32Array([1,1,2])},getUniforms:Qo};function Qo(r=Wt.defaultUniforms){let e={};return r.lightDirection&&(e.dirlight_uLightDirection=r.lightDirection),e}var Vr=`uniform materialUniforms {
uniform float ambient;
uniform float diffuse;
uniform float shininess;
uniform vec3  specularColor;
} material;
`,Gr=`uniform materialUniforms {
uniform float ambient;
uniform float diffuse;
uniform float shininess;
uniform vec3  specularColor;
} material;
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
vec3 halfway_direction = normalize(light_direction + view_direction);
float lambertian = dot(light_direction, normal_worldspace);
float specular = 0.0;
if (lambertian > 0.0) {
float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
specular = pow(specular_angle, material.shininess);
}
lambertian = max(lambertian, 0.0);
return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = surfaceColor;
if (lighting.enabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
lightColor = material.ambient * surfaceColor * lighting.ambientColor;
if (lighting.lightType == 0) {
PointLight pointLight = lighting_getPointLight(0);
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
} else if (lighting.lightType == 1) {
DirectionalLight directionalLight = lighting_getDirectionalLight(0);
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = vec3(0, 0, 0);
vec3 surfaceColor = vec3(0, 0, 0);
if (lighting.enabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
switch (lighting.lightType) {
case 0:
PointLight pointLight = lighting_getPointLight(0);
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
break;
case 1:
DirectionalLight directionalLight = lighting_getDirectionalLight(0);
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
break;
}
}
return lightColor;
}
`;var jt={name:"gouraud-lighting",vs:Vr,fs:Gr,defines:{LIGHTING_VERTEX:1},dependencies:[Q],uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(r){return{...jt.defaultUniforms,...r}}};var Hr=`uniform phongMaterialUniforms {
uniform float ambient;
uniform float diffuse;
uniform float shininess;
uniform vec3  specularColor;
} material;
`,Wr=`uniform phongMaterialUniforms {
uniform float ambient;
uniform float diffuse;
uniform float shininess;
uniform vec3  specularColor;
} material;
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
vec3 halfway_direction = normalize(light_direction + view_direction);
float lambertian = dot(light_direction, normal_worldspace);
float specular = 0.0;
if (lambertian > 0.0) {
float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
specular = pow(specular_angle, material.shininess);
}
lambertian = max(lambertian, 0.0);
return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = surfaceColor;
if (lighting.enabled == 0) {
return lightColor;
}
vec3 view_direction = normalize(cameraPosition - position_worldspace);
lightColor = material.ambient * surfaceColor * lighting.ambientColor;
if (lighting.lightType == 0) {
PointLight pointLight = lighting_getPointLight(0);
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
} else if (lighting.lightType == 1) {
DirectionalLight directionalLight = lighting_getDirectionalLight(0);
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
return lightColor;
}
vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = vec3(0, 0, 0);
vec3 surfaceColor = vec3(0, 0, 0);
if (lighting.enabled == 0) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
switch (lighting.lightType) {
case 0:
PointLight pointLight = lighting_getPointLight(0);
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
break;
case 1:
DirectionalLight directionalLight = lighting_getDirectionalLight(0);
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
break;
}
}
return lightColor;
}
`;var $t={name:"phong-lighting",vs:Hr,fs:Wr,defines:{LIGHTING_FRAGMENT:1},dependencies:[Q],uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(r){return{...$t.defaultUniforms,...r}}};var jr=`uniform projection {
mat4 u_MVPMatrix;
mat4 u_ModelMatrix;
mat4 u_NormalMatrix;
vec3 u_Camera;
}
varying vec3 pbr_vPosition;
varying vec2 pbr_vUV;
#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
# else
varying vec3 pbr_vNormal;
# endif
#endif
void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
vec4 pos = u_ModelMatrix * position;
pbr_vPosition = vec3(pos.xyz) / pos.w;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));
vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));
vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else
pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0.,0.);
#endif
}
`;var $r=`precision highp float;
uniform Projection {
uniform vec3 u_Camera;
};
uniform pbrMaterial {
bool unlit;
bool baseColorMapEnabled;
vec4 baseColorFactor;
bool normalMapEnabled;
float normalScale;
bool emissiveMapEnabled;
vec3 emissiveFactor;
vec2 metallicRoughnessValues;
bool metallicRoughnessMapEnabled;
bool occlusionMapEnabled;
float occlusionStrength;
bool alphaCutoffEnabled;
float alphaCutoff;
bool IBLenabled;
vec2 scaleIBLAmbient;
vec4 scaleDiffBaseMR;
vec4 scaleFGDSpec;
} u_pbrMaterial;
#ifdef HAS_BASECOLORMAP
uniform sampler2D u_BaseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D u_NormalSampler;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D u_EmissiveSampler;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D u_MetallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D u_OcclusionSampler;
#endif
#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
#endif
varying vec3 pbr_vPosition;
varying vec2 pbr_vUV;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
#else
varying vec3 pbr_vNormal;
#endif
#endif
struct PBRInfo {
float NdotL;
float NdotV;
float NdotH;
float LdotH;
float VdotH;
float perceptualRoughness;
float metalness;
vec3 reflectance0;
vec3 reflectance90;
float alphaRoughness;
vec3 diffuseColor;
vec3 specularColor;
vec3 n;
vec3 v;
};
const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;
vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else
vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif
return vec4(linOut,srgbIn.w);;
#else
return srgbIn;
#endif
}
vec3 getNormal()
{
#ifndef HAS_TANGENTS
vec3 pos_dx = dFdx(pbr_vPosition);
vec3 pos_dy = dFdy(pbr_vPosition);
vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);
#ifdef HAS_NORMALS
vec3 ng = normalize(pbr_vNormal);
#else
vec3 ng = cross(pos_dx, pos_dy);
#endif
t = normalize(t - ng * dot(ng, t));
vec3 b = normalize(cross(ng, t));
mat3 tbn = mat3(t, b, ng);
#else
mat3 tbn = pbr_vTBN;
#endif
#ifdef HAS_NORMALMAP
vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;
n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_pbrMaterial.normalScale, u_pbrMaterial.normalScale, 1.0)));
#else
vec3 n = normalize(tbn[2].xyz);
#endif
return n;
}
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)
{
float mipCount = 9.0;
float lod = (pbrInfo.perceptualRoughness * mipCount);
vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,
vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;
vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;
#ifdef USE_TEX_LOD
vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;
#else
vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
#endif
vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;
vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);
diffuse *= u_pbrMaterial.scaleIBLAmbient.x;
specular *= u_pbrMaterial.scaleIBLAmbient.y;
return diffuse + specular;
}
#endif
vec3 diffuse(PBRInfo pbrInfo)
{
return pbrInfo.diffuseColor / M_PI;
}
vec3 specularReflection(PBRInfo pbrInfo)
{
return pbrInfo.reflectance0 +
(pbrInfo.reflectance90 - pbrInfo.reflectance0) *
pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);
}
float geometricOcclusion(PBRInfo pbrInfo)
{
float NdotL = pbrInfo.NdotL;
float NdotV = pbrInfo.NdotV;
float r = pbrInfo.alphaRoughness;
float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
return attenuationL * attenuationV;
}
float microfacetDistribution(PBRInfo pbrInfo)
{
float roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;
float f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;
return roughnessSq / (M_PI * f * f);
}
void PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {
pbrInfo.NdotL = 1.0;
pbrInfo.NdotH = 0.0;
pbrInfo.LdotH = 0.0;
pbrInfo.VdotH = 1.0;
}
void PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {
vec3 n = pbrInfo.n;
vec3 v = pbrInfo.v;
vec3 l = normalize(lightDirection);
vec3 h = normalize(l+v);
pbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);
pbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
pbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
pbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
}
void PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {
vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
PBRInfo_setDirectionalLight(pbrInfo, light_direction);
}
vec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {
vec3 F = specularReflection(pbrInfo);
float G = geometricOcclusion(pbrInfo);
float D = microfacetDistribution(pbrInfo);
vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);
vec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);
return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);
}
vec4 pbr_filterColor(vec4 colorUnused)
{
#ifdef HAS_BASECOLORMAP
vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_pbrMaterial.baseColorFactor;
#else
vec4 baseColor = u_pbrMaterial.baseColorFactor;
#endif
#ifdef ALPHA_CUTOFF
if (baseColor.a < u_pbrMaterial.alphaCutoff) {
discard;
}
#endif
vec3 color = vec3(0, 0, 0);
if(u_pbrMaterial.unlit){
color.rgb = baseColor.rgb;
}
else{
float perceptualRoughness = u_pbrMaterial.metallicRoughnessValues.y;
float metallic = u_pbrMaterial.metallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);
perceptualRoughness = mrSample.g * perceptualRoughness;
metallic = mrSample.b * metallic;
#endif
perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
metallic = clamp(metallic, 0.0, 1.0);
float alphaRoughness = perceptualRoughness * perceptualRoughness;
vec3 f0 = vec3(0.04);
vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
diffuseColor *= 1.0 - metallic;
vec3 specularColor = mix(f0, baseColor.rgb, metallic);
float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);
float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
vec3 specularEnvironmentR0 = specularColor.rgb;
vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;
vec3 n = getNormal();
vec3 v = normalize(u_Camera - pbr_vPosition);
float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
vec3 reflection = -normalize(reflect(v, n));
PBRInfo pbrInfo = PBRInfo(
0.0,
NdotV,
0.0,
0.0,
0.0,
perceptualRoughness,
metallic,
specularEnvironmentR0,
specularEnvironmentR90,
alphaRoughness,
diffuseColor,
specularColor,
n,
v
);
#ifdef USE_LIGHTS
PBRInfo_setAmbientLight(pbrInfo);
color += calculateFinalColor(pbrInfo, lighting_uAmbientLight.color);
for(int i = 0; i < lighting_uDirectionalLightCount; i++) {
if (i < lighting_uDirectionalLightCount) {
PBRInfo_setDirectionalLight(pbrInfo, lighting_uDirectionalLight[i].direction);
color += calculateFinalColor(pbrInfo, lighting_uDirectionalLight[i].color);
}
}
for(int i = 0; i < lighting_uPointLightCount; i++) {
if (i < lighting_uPointLightCount) {
PBRInfo_setPointLight(pbrInfo, lighting_uPointLight[i]);
float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));
color += calculateFinalColor(pbrInfo, lighting_uPointLight[i].color / attenuation);
}
}
#endif
#ifdef USE_IBL
if (u_pbrMateral.IBLEnabled) {
color += getIBLContribution(pbrInfo, n, reflection);
}
#endif
#ifdef HAS_OCCLUSIONMAP
if (u_pbrMaterial.occlusionMapEnabled) {
float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;
color = mix(color, color * ao, u_pbrMaterial.occlusionStrength);
}
#endif
#ifdef HAS_EMISSIVEMAP
if (u_pbrMaterial.emmissiveMapEnabled) {
vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_pbrMaterial.emissiveFactor;
color += emissive;
}
#endif
#ifdef PBR_DEBUG
color = mix(color, baseColor.rgb, u_pbrMaterial.scaleDiffBaseMR.y);
color = mix(color, vec3(metallic), u_pbrMaterial.scaleDiffBaseMR.z);
color = mix(color, vec3(perceptualRoughness), u_pbrMaterial.scaleDiffBaseMR.w);
#endif
}
return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`;var Kr={name:"pbr",vs:jr,fs:$r,defines:{LIGHTING_FRAGMENT:1,HAS_NORMALMAP:0,HAS_EMISSIVEMAP:0,HAS_OCCLUSIONMAP:0,HAS_BASECOLORMAP:0,HAS_METALROUGHNESSMAP:0,ALPHA_CUTOFF:0,USE_IBL:0,PBR_DEBUG:0},uniformTypes:{unlit:"i32",baseColorMapEnabled:"i32",baseColorFactor:"vec4<f32>",normalMapEnabled:"i32",normalScale:"f32",emissiveMapEnabled:"i32",emissiveFactor:"vec3<f32>",metallicRoughnessValues:"vec2<f32>",metallicRoughnessMapEnabled:"i32",occlusionMapEnabled:"i32",occlusionStrength:"f32",alphaCutoffEnabled:"i32",alphaCutoff:"f32",IBLenabled:"i32",scaleIBLAmbient:"vec2<f32>",scaleDiffBaseMR:"vec4<f32>",scaleFGDSpec:"vec4<f32>"},bindings:{baseColorSampler:{type:"texture",location:8},normalSampler:{type:"texture",location:9},emissiveSampler:{type:"texture",location:10},metallicRoughnessSampler:{type:"texture",location:11},occlusionSampler:{type:"texture",location:12},diffuseEnvSampler:{type:"texture",location:13},specularEnvSampler:{type:"texture",location:14},brdfLUT:{type:"texture",location:15}},dependencies:[Q]};var qo=`uniform brightnessContrastUniforms {
float brightness;
float contrast;
} brightnessContrast;
vec4 brightnessContrast_filterColor(vec4 color) {
color.rgb += brightnessContrast.brightness;
if (brightnessContrast.contrast > 0.0) {
color.rgb = (color.rgb - 0.5) / (1.0 - brightnessContrast.contrast) + 0.5;
} else {
color.rgb = (color.rgb - 0.5) * (1.0 + brightnessContrast.contrast) + 0.5;
}
return color;
}
vec4 brightnessContrast_filterColor(vec4 color, vec2 texSize, vec2 texCoords) {
return brightnessContrast_filterColor(color);
}
`,Zr={name:"brightnessContrast",uniformTypes:{brightness:"f32",contrast:"f32"},uniformPropTypes:{brightness:{format:"f32",value:0,min:-1,max:1},contrast:{format:"f32",value:0,min:-1,max:1}},fs:qo,passes:[{filter:!0}]};var Vo=`uniform denoiseUniforms {
float strength;
} noise;
vec4 denoise_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
float adjustedExponent = 3. + 200. * pow(1. - noise.strength, 4.);
vec4 center = texture(source, texCoord);
vec4 color = vec4(0.0);
float total = 0.0;
for (float x = -4.0; x <= 4.0; x += 1.0) {
for (float y = -4.0; y <= 4.0; y += 1.0) {
vec4 offsetColor = texture(source, texCoord + vec2(x, y) / texSize);
float weight = 1.0 - abs(dot(offsetColor.rgb - center.rgb, vec3(0.25)));
weight = pow(weight, adjustedExponent);
color += offsetColor * weight;
total += weight;
}
}
return color / total;
}
`,Jr={name:"denoise",uniformTypes:{strength:"f32"},uniformPropTypes:{strength:{format:"f32",value:.5,min:0,max:1}},fs:Vo,passes:[{sampler:!0},{sampler:!0}]};var Go=`uniform hueSaturationUniforms {
float hue;
float saturation;
} hueSaturation;
vec4 hueSaturation_filterColor(vec4 color) {
float angle = hueSaturation.hue * 3.14159265;
float s = sin(angle), c = cos(angle);
vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;
float len = length(color.rgb);
color.rgb = vec3(
dot(color.rgb, weights.xyz),
dot(color.rgb, weights.zxy),
dot(color.rgb, weights.yzx)
);
float average = (color.r + color.g + color.b) / 3.0;
if (hueSaturation.saturation > 0.0) {
color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - hueSaturation.saturation));
} else {
color.rgb += (average - color.rgb) * (-hueSaturation.saturation);
}
return color;
}
vec4 hueSaturation_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
return hueSaturation_filterColor(color);
}
`,en={name:"hueSaturation",uniformTypes:{hue:"f32",saturation:"f32"},uniformPropTypes:{hue:{value:0,min:-1,max:1},saturation:{value:0,min:-1,max:1}},fs:Go,passes:[{filter:!0}]};var Ho=`uniform noiseUniforms {
float amount;
} noise;
float rand(vec2 co) {
return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
vec4 noise_filterColor(vec4 color, vec2 texCoord) {
float diff = (rand(texCoord) - 0.5) * noise.amount;
color.r += diff;
color.g += diff;
color.b += diff;
return color;
}
vec4 noise_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
return noise_filterColor(color, texCoord);
}
`,tn={name:"noise",uniformTypes:{amount:"f32"},uniformPropTypes:{amount:{value:.5,min:0,max:1}},fs:Ho,passes:[{filter:!0}]};var Wo=`uniform sepiaUniforms {
float amount;
} sepia;
vec4 sepia_filterColor(vec4 color) {
float r = color.r;
float g = color.g;
float b = color.b;
color.r =
min(1.0, (r * (1.0 - (0.607 * sepia.amount))) + (g * (0.769 * sepia.amount)) + (b * (0.189 * sepia.amount)));
color.g = min(1.0, (r * 0.349 * sepia.amount) + (g * (1.0 - (0.314 * sepia.amount))) + (b * 0.168 * sepia.amount));
color.b = min(1.0, (r * 0.272 * sepia.amount) + (g * 0.534 * sepia.amount) + (b * (1.0 - (0.869 * sepia.amount))));
return color;
}
vec4 sepia_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
return sepia_filterColor(color);
}
`,rn={name:"sepia",uniformTypes:{amount:"f32"},uniformPropTypes:{amount:{value:.5,min:0,max:1}},fs:Wo,passes:[{filter:!0}]};var jo=`uniform vibranceUniforms {
float amount;
} vibrance;
vec4 vibrance_filterColor(vec4 color) {
float average = (color.r + color.g + color.b) / 3.0;
float mx = max(color.r, max(color.g, color.b));
float amt = (mx - average) * (-vibrance.amount * 3.0);
color.rgb = mix(color.rgb, vec3(mx), amt);
return color;
}
vec4 vibrance_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
return vibrance_filterColor(color);
}
`,nn={name:"vibrance",uniformPropTypes:{amount:{value:0,min:-1,max:1}},fs:jo,passes:[{filter:!0}]};var $o=`uniform vignetteUniforms {
float radius;
float amount;
} vignette;
vec4 vignette_filterColor(vec4 color, vec2 texCoord) {
float dist = distance(texCoord, vec2(0.5, 0.5));
float ratio = smoothstep(0.8, vignette.radius * 0.799, dist * (vignette.amount + vignette.radius));
return color.rgba * ratio + (1.0 - ratio)*vec4(0.0, 0.0, 0.0, 1.0);
}
vec4 vignette_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
return vignette_filterColor(color, texCoord);
}
`,on={name:"vignette",fs:$o,uniformTypes:{radius:"f32",amount:"f32"},uniformPropTypes:{radius:{value:.5,min:0,max:1},amount:{value:.5,min:0,max:1}},passes:[{filter:!0}]};var Ko=`uniform tiltShiftUniforms {
float blurRadius;
float gradientRadius;
vec2 start;
vec2 end;
bool invert;
} tiltShift;
vec2 tiltShift_getDelta(vec2 texSize) {
vec2 vector = normalize((tiltShift.end - tiltShift.start) * texSize);
return tiltShift.invert ? vec2(-vector.y, vector.x) : vector;
}
vec4 tiltShift_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec4 color = vec4(0.0);
float total = 0.0;
float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
vec2 normal = normalize(vec2((tiltShift.start.y - tiltShift.end.y) * texSize.y, (tiltShift.end.x - tiltShift.start.x) * texSize.x));
float radius = smoothstep(0.0, 1.0,
abs(dot(texCoord * texSize - tiltShift.start * texSize, normal)) / tiltShift.gradientRadius) * tiltShift.blurRadius;
for (float t = -30.0; t <= 30.0; t++) {
float percent = (t + offset - 0.5) / 30.0;
float weight = 1.0 - abs(percent);
vec4 offsetColor = texture(source, texCoord + tiltShift_getDelta(texSize) / texSize * percent * radius);
offsetColor.rgb *= offsetColor.a;
color += offsetColor * weight;
total += weight;
}
color = color / total;
color.rgb /= color.a + 0.00001;
return color;
}
`,sn={name:"tiltShift",uniformTypes:{blurRadius:"f32",gradientRadius:"f32",start:"vec2<f32>",end:"vec2<f32>",invert:"i32"},uniformPropTypes:{blurRadius:{value:15,min:0,max:50},gradientRadius:{value:200,min:0,max:400},start:{value:[0,0]},end:{value:[1,1]},invert:{value:!1,private:!0}},passes:[{sampler:!0,uniforms:{invert:!1}},{sampler:!0,uniforms:{invert:!0}}],dependencies:[q],fs:Ko};var Zo=`uniform triangleBlurUniforms {
float radius;
vec2 delta;
} triangleBlur;
vec4 triangleBlur_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 adjustedDelta = triangleBlur.delta * triangleBlur.radius / texSize;
vec4 color = vec4(0.0);
float total = 0.0;
float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
for (float t = -30.0; t <= 30.0; t++) {
float percent = (t + offset - 0.5) / 30.0;
float weight = 1.0 - abs(percent);
vec4 offsetColor = texture(source, texCoord + adjustedDelta * percent);
offsetColor.rgb *= offsetColor.a;
color += offsetColor * weight;
total += weight;
}
color = color / total;
color.rgb /= color.a + 0.00001;
return color;
}
`,an={name:"triangleBlur",uniformTypes:{radius:"f32",delta:"vec2<f32>"},uniformPropTypes:{radius:{value:20,min:0,softMax:100},delta:{value:[1,0],private:!0}},fs:Zo,dependencies:[q],passes:[{sampler:!0,uniforms:{delta:[1,0]}},{sampler:!0,uniforms:{delta:[0,1]}}]};var Jo=`
uniform zoomBlurUniforms {
  vec2 center;
  float strength;
} zoomBlur;

vec4 zoomBlur_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
  vec4 color = vec4(0.0);
  float total = 0.0;
  vec2 toCenter = zoomBlur.center * texSize - texCoord * texSize;

  /* randomize the lookup values to hide the fixed number of samples */
  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);

  for (float t = 0.0; t <= 40.0; t++) {
    float percent = (t + offset) / 40.0;
    float weight = 4.0 * (percent - percent * percent);
    vec4 offsetColor = texture(source, texCoord + toCenter * percent * zoomBlur.strength / texSize);

    /* switch to pre-multiplied alpha to correctly blur transparent images */
    offsetColor.rgb *= offsetColor.a;

    color += offsetColor * weight;
    total += weight;
  }

  color = color / total;

  /* switch back from pre-multiplied alpha */
  color.rgb /= color.a + 0.00001;

  return color;
}
`,cn={name:"zoomBlur",uniformTypes:{center:"vec2<f32>",strength:"f32"},uniformPropTypes:{center:{value:[.5,.5]},strength:{value:.3,min:0,softMax:1}},fs:Jo,dependencies:[q],passes:[{sampler:!0}]};var ei=`uniform colorHalftoneUniforms {
vec2 center;
float angle;
float size;
} colorHalftone;
float pattern(float angle, float scale, vec2 texSize, vec2 texCoord) {
float s = sin(angle), c = cos(angle);
vec2 tex = texCoord * texSize - colorHalftone.center * texSize;
vec2 point = vec2(
c * tex.x - s * tex.y,
s * tex.x + c * tex.y
) * scale;
return (sin(point.x) * sin(point.y)) * 4.0;
}
vec4 colorHalftone_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
float scale = 3.1514 / colorHalftone.size;
vec3 cmy = 1.0 - color.rgb;
float k = min(cmy.x, min(cmy.y, cmy.z));
cmy = (cmy - k) / (1.0 - k);
cmy = clamp(
cmy * 10.0 - 3.0 + vec3(
pattern(colorHalftone.angle + 0.26179, scale, texSize, texCoord),
pattern(colorHalftone.angle + 1.30899, scale, texSize, texCoord),
pattern(colorHalftone.angle, scale, texSize, texCoord)
),
0.0,
1.0
);
k = clamp(k * 10.0 - 5.0 + pattern(colorHalftone.angle + 0.78539, scale, texSize, texCoord), 0.0, 1.0);
return vec4(1.0 - cmy - k, color.a);
}
`,ln={name:"colorHalftone",uniformTypes:{center:"vec2<f32>",angle:"f32",size:"f32"},uniformPropTypes:{center:{value:[.5,.5]},angle:{value:1.1,softMin:0,softMax:Math.PI/2},size:{value:4,min:1,softMin:3,softMax:20}},fs:ei,passes:[{filter:!0}]};var ti=`uniform dotScreenUniforms {
vec2 center;
float angle;
float size;
} dotScreen;
float pattern(vec2 texSize, vec2 texCoord) {
float scale = 3.1415 / dotScreen.size;
float s = sin(dotScreen.angle), c = cos(dotScreen.angle);
vec2 tex = texCoord * texSize - dotScreen.center * texSize;
vec2 point = vec2(
c * tex.x - s * tex.y,
s * tex.x + c * tex.y
) * scale;
return (sin(point.x) * sin(point.y)) * 4.0;
}
vec4 dotScreen_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
float average = (color.r + color.g + color.b) / 3.0;
return vec4(vec3(average * 10.0 - 5.0 + pattern(texSize, texCoord)), color.a);
}
`,fn={name:"dotScreen",uniformTypes:{center:"vec2<f32>",angle:"f32",size:"f32"},uniformPropTypes:{center:{value:[.5,.5]},angle:{value:1.1,softMin:0,softMax:Math.PI/2},size:{value:3,min:1,softMin:3,softMax:20}},fs:ti,passes:[{filter:!0}]};var ri=`uniform edgeWorkUniforms {
float radius;
vec2 delta;
} edgeWork;
vec4 edgeWork_sampleColor1(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 relativeDelta = edgeWork.radius * edgeWork.delta / texSize;
vec2 color = vec2(0.0);
vec2 total = vec2(0.0);
float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
for (float t = -30.0; t <= 30.0; t++) {
float percent = (t + offset - 0.5) / 30.0;
float weight = 1.0 - abs(percent);
vec3 sampleColor = texture(source, texCoord + relativeDelta * percent).rgb;
float average = (sampleColor.r + sampleColor.g + sampleColor.b) / 3.0;
color.x += average * weight;
total.x += weight;
if (abs(t) < 15.0) {
weight = weight * 2.0 - 1.0;
color.y += average * weight;
total.y += weight;
}
}
return vec4(color / total, 0.0, 1.0);
}
vec4 edgeWork_sampleColor2(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 relativeDelta = edgeWork.radius * edgeWork.delta / texSize;
vec2 color = vec2(0.0);
vec2 total = vec2(0.0);
float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
for (float t = -30.0; t <= 30.0; t++) {
float percent = (t + offset - 0.5) / 30.0;
float weight = 1.0 - abs(percent);
vec2 sampleColor = texture(source, texCoord + relativeDelta * percent).xy;
color.x += sampleColor.x * weight;
total.x += weight;
if (abs(t) < 15.0) {
weight = weight * 2.0 - 1.0;
color.y += sampleColor.y * weight;
total.y += weight;
}
}
float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);
return vec4(c, c, c, 1.0);
}
`,un={name:"edgeWork",uniformPropTypes:{radius:{value:2,min:1,softMax:50},delta:{value:[1,0],private:!0}},fs:ri,dependencies:[q],passes:[{sampler:"edgeWork_sampleColor1",uniformPropTypes:{delta:[1,0]}},{sampler:"edgeWork_sampleColor2",uniformPropTypes:{delta:[0,1]}}]};var ni=`uniform hexagonalPixelateUniforms {
vec2 center;
float scale;
} hexagonalPixelate;
vec4 hexagonalPixelate_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 tex = (texCoord * texSize - hexagonalPixelate.center * texSize) / hexagonalPixelate.scale;
tex.y /= 0.866025404;
tex.x -= tex.y * 0.5;
vec2 a;
if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {
a = vec2(floor(tex.x), floor(tex.y));
}
else a = vec2(ceil(tex.x), ceil(tex.y));
vec2 b = vec2(ceil(tex.x), floor(tex.y));
vec2 c = vec2(floor(tex.x), ceil(tex.y));
vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);
vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);
vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);
vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);
float alen = length(TEX - A);
float blen = length(TEX - B);
float clen = length(TEX - C);
vec2 choice;
if (alen < blen) {
if (alen < clen) choice = a;
else choice = c;
} else {
if (blen < clen) choice = b;
else choice = c;
}
choice.x += choice.y * 0.5;
choice.y *= 0.866025404;
choice *= hexagonalPixelate.scale / texSize;
return texture(source, choice + hexagonalPixelate.center);
}
`,_n={name:"hexagonalPixelate",uniformTypes:{center:"vec2<f32>",scale:"f32"},uniformPropTypes:{center:{value:[.5,.5],hint:"screenspace"},scale:{value:10,min:1,softMin:5,softMax:50}},fs:ni,passes:[{sampler:!0}]};var oi=`uniform inkUniforms {
float strength;
} ink;
vec4 ink_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 dx = vec2(1.0 / texSize.x, 0.0);
vec2 dy = vec2(0.0, 1.0 / texSize.y);
vec4 color = texture(source, texCoord);
float bigTotal = 0.0;
float smallTotal = 0.0;
vec3 bigAverage = vec3(0.0);
vec3 smallAverage = vec3(0.0);
for (float x = -2.0; x <= 2.0; x += 1.0) {
for (float y = -2.0; y <= 2.0; y += 1.0) {
vec3 offsetColor = texture(source, texCoord + dx * x + dy * y).rgb;
bigAverage += offsetColor;
bigTotal += 1.0;
if (abs(x) + abs(y) < 2.0) {
smallAverage += offsetColor;
smallTotal += 1.0;
}
}
}
vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);
float power = ink.strength * ink.strength * ink.strength * ink.strength * ink.strength;
return vec4(color.rgb - dot(edge, edge) * power * 100000.0, color.a);
}
`,hn={name:"ink",uniformTypes:{strength:"f32"},uniformPropTypes:{strength:{value:.25,min:0,softMax:1}},fs:oi,passes:[{sampler:!0}]};var ii=`uniform magnifyUniforms {
vec2 screenXY;
float radiusPixels;
float zoom;
float borderWidthPixels;
vec4 borderColor;
} magnify;
vec4 magnify_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 pos = vec2(magnify.screenXY.x, 1.0 - magnify.screenXY.y);
float dist = distance(texCoord * texSize, pos * texSize);
if (dist < magnify.radiusPixels) {
return texture(source, (texCoord - pos) / magnify.zoom + pos);
}
if (dist <= magnify.radiusPixels + magnify.borderWidthPixels) {
return magnify.borderColor;
}
return texture(source, texCoord);
}
`,pn={name:"magnify",uniformTypes:{screenXY:"vec2<f32>",radiusPixels:"f32",zoom:"f32",borderWidthPixels:"f32",borderColor:"vec4<f32>"},uniformPropTypes:{screenXY:{value:[0,0]},radiusPixels:200,zoom:2,borderWidthPixels:0,borderColor:{value:[255,255,255,255]}},fs:ii,passes:[{sampler:!0}]};var si=`vec4 warp_sampleColor(sampler2D source, vec2 texSize, vec2 coord) {
vec4 color = texture(source, coord / texSize);
vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);
if (coord != clampedCoord) {
color.a *= max(0.0, 1.0 - length(coord - clampedCoord));
}
return color;
}
`,fe={name:"warp",passes:[],fs:si};var ai=`uniform bulgePinchUniforms {
float radius;
float strength;
vec2 center;
} bulgePinch;
vec2 bulgePinch_warp(vec2 coord, vec2 texCenter) {
coord -= texCenter;
float distance = length(coord);
if (distance < bulgePinch.radius) {
float percent = distance / bulgePinch.radius;
if (bulgePinch.strength > 0.0) {
coord *= mix(1.0, smoothstep(0.0, bulgePinch.radius / distance, percent), bulgePinch.strength * 0.75);
} else {
coord *= mix(1.0, pow(percent, 1.0 + bulgePinch.strength * 0.75) * bulgePinch.radius / distance, 1.0 - percent);
}
}
coord += texCenter;
return coord;
}
vec4 bulgePinch_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 coord = texCoord * texSize;
coord = bulgePinch_warp(coord, bulgePinch.center * texSize);
return warp_sampleColor(source, texSize, coord);
}
`,dn={name:"bulgePinch",fs:ai,uniformTypes:{center:"vec2<f32>",radius:"f32",strength:"f32"},uniformPropTypes:{center:{value:[.5,.5]},radius:{value:200,min:1,softMax:600},strength:{value:.5,min:-1,max:1}},dependencies:[fe],passes:[{sampler:!0}]};var ci=`uniform swirlUniforms {
float radius;
float angle;
vec2 center;
} swirl;
vec2 swirl_warp(vec2 coord, vec2 texCenter) {
coord -= texCenter;
float distance = length(coord);
if (distance < swirl.radius) {
float percent = (swirl.radius - distance) / swirl.radius;
float theta = percent * percent * swirl.angle;
float s = sin(theta);
float c = cos(theta);
coord = vec2(
coord.x * c - coord.y * s,
coord.x * s + coord.y * c
);
}
coord += texCenter;
return coord;
}
vec4 swirl_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 coord = texCoord * texSize;
coord = swirl_warp(coord, swirl.center * texSize);
return warp_sampleColor(source, texSize, coord);
}
`,mn={name:"swirl",fs:ci,uniformTypes:{center:"vec2<f32>",radius:"f32",angle:"f32"},uniformPropTypes:{center:{value:[.5,.5]},radius:{value:200,min:1,softMax:600},angle:{value:3,softMin:-25,softMax:25}},dependencies:[fe],passes:[{sampler:!0}]};var li=`
#define FXAA_QUALITY_PRESET 29

#if (FXAA_QUALITY_PRESET == 10)
    #define FXAA_QUALITY_PS 3
    #define FXAA_QUALITY_P0 1.5
    #define FXAA_QUALITY_P1 3.0
    #define FXAA_QUALITY_P2 12.0
#endif
#if (FXAA_QUALITY_PRESET == 11)
    #define FXAA_QUALITY_PS 4
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 3.0
    #define FXAA_QUALITY_P3 12.0
#endif
#if (FXAA_QUALITY_PRESET == 12)
    #define FXAA_QUALITY_PS 5
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 4.0
    #define FXAA_QUALITY_P4 12.0
#endif
#if (FXAA_QUALITY_PRESET == 13)
    #define FXAA_QUALITY_PS 6
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 4.0
    #define FXAA_QUALITY_P5 12.0
#endif
#if (FXAA_QUALITY_PRESET == 14)
    #define FXAA_QUALITY_PS 7
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 4.0
    #define FXAA_QUALITY_P6 12.0
#endif
#if (FXAA_QUALITY_PRESET == 15)
    #define FXAA_QUALITY_PS 8
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 4.0
    #define FXAA_QUALITY_P7 12.0
#endif
#if (FXAA_QUALITY_PRESET == 20)
    #define FXAA_QUALITY_PS 3
    #define FXAA_QUALITY_P0 1.5
    #define FXAA_QUALITY_P1 2.0
    #define FXAA_QUALITY_P2 8.0
#endif
#if (FXAA_QUALITY_PRESET == 21)
    #define FXAA_QUALITY_PS 4
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 8.0
#endif
#if (FXAA_QUALITY_PRESET == 22)
    #define FXAA_QUALITY_PS 5
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 8.0
#endif
#if (FXAA_QUALITY_PRESET == 23)
    #define FXAA_QUALITY_PS 6
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 8.0
#endif
#if (FXAA_QUALITY_PRESET == 24)
    #define FXAA_QUALITY_PS 7
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 3.0
    #define FXAA_QUALITY_P6 8.0
#endif
#if (FXAA_QUALITY_PRESET == 25)
    #define FXAA_QUALITY_PS 8
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 4.0
    #define FXAA_QUALITY_P7 8.0
#endif
#if (FXAA_QUALITY_PRESET == 26)
    #define FXAA_QUALITY_PS 9
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 4.0
    #define FXAA_QUALITY_P8 8.0
#endif
#if (FXAA_QUALITY_PRESET == 27)
    #define FXAA_QUALITY_PS 10
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 4.0
    #define FXAA_QUALITY_P9 8.0
#endif
#if (FXAA_QUALITY_PRESET == 28)
    #define FXAA_QUALITY_PS 11
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 2.0
    #define FXAA_QUALITY_P9 4.0
    #define FXAA_QUALITY_P10 8.0
#endif
#if (FXAA_QUALITY_PRESET == 29)
    #define FXAA_QUALITY_PS 12
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 2.0
    #define FXAA_QUALITY_P9 2.0
    #define FXAA_QUALITY_P10 4.0
    #define FXAA_QUALITY_P11 8.0
#endif
#if (FXAA_QUALITY_PRESET == 39)
    #define FXAA_QUALITY_PS 12
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.0
    #define FXAA_QUALITY_P2 1.0
    #define FXAA_QUALITY_P3 1.0
    #define FXAA_QUALITY_P4 1.0
    #define FXAA_QUALITY_P5 1.5
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 2.0
    #define FXAA_QUALITY_P9 2.0
    #define FXAA_QUALITY_P10 4.0
    #define FXAA_QUALITY_P11 8.0
#endif

#define FxaaBool bool
#define FxaaFloat float
#define FxaaFloat2 vec2
#define FxaaFloat3 vec3
#define FxaaFloat4 vec4
#define FxaaHalf float
#define FxaaHalf2 vec2
#define FxaaHalf3 vec3
#define FxaaHalf4 vec4
#define FxaaInt2 vec2
#define FxaaTex sampler2D

#define FxaaSat(x) clamp(x, 0.0, 1.0)
#define FxaaTexTop(t, p) texture(t, p)
#define FxaaTexOff(t, p, o, r) texture(t, p + (o * r))

FxaaFloat FxaaLuma_(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.2126, 0.7152, 0.0722)); }

FxaaFloat4 FxaaPixelShader_(
    //
    // Use noperspective interpolation here (turn off perspective interpolation).
    // {xy} = center of pixel
    FxaaFloat2 pos,
    //
    // Input color texture.
    // {rgb_} = color in linear or perceptual color space
    // if (FXAA_GREEN_AS_LUMA == 0)
    //     {___a} = luma in perceptual color space (not linear)
    FxaaTex tex,
    //
    // Only used on FXAA Quality.
    // This must be from a constant/uniform.
    // {x_} = 1.0/screenWidthInPixels
    // {_y} = 1.0/screenHeightInPixels
    FxaaFloat2 fxaaQualityRcpFrame,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITY_SUBPIX define.
    // It is here now to allow easier tuning.
    // Choose the amount of sub-pixel aliasing removal.
    // This can effect sharpness.
    //   1.00 - upper limit (softer)
    //   0.75 - default amount of filtering
    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)
    //   0.25 - almost off
    //   0.00 - completely off
    FxaaFloat fxaaQualitySubpix,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.
    // It is here now to allow easier tuning.
    // The minimum amount of local contrast required to apply algorithm.
    //   0.333 - too little (faster)
    //   0.250 - low quality
    //   0.166 - default
    //   0.125 - high quality
    //   0.063 - overkill (slower)
    FxaaFloat fxaaQualityEdgeThreshold,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.
    // It is here now to allow easier tuning.
    // Trims the algorithm from processing darks.
    //   0.0833 - upper limit (default, the start of visible unfiltered edges)
    //   0.0625 - high quality (faster)
    //   0.0312 - visible limit (slower)
    // Special notes when using FXAA_GREEN_AS_LUMA,
    //   Likely want to set this to zero.
    //   As colors that are mostly not-green
    //   will appear very dark in the green channel!
    //   Tune by looking at mostly non-green content,
    //   then start at zero and increase until aliasing is a problem.
    FxaaFloat fxaaQualityEdgeThresholdMin
) {
/*--------------------------------------------------------------------------*/
    FxaaFloat2 posM;
    posM.x = pos.x;
    posM.y = pos.y;
    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
    #define lumaM rgbyM.y
    FxaaFloat lumaS = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaN = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
/*--------------------------------------------------------------------------*/
    FxaaFloat maxSM = max(lumaS, lumaM);
    FxaaFloat minSM = min(lumaS, lumaM);
    FxaaFloat maxESM = max(lumaE, maxSM);
    FxaaFloat minESM = min(lumaE, minSM);
    FxaaFloat maxWN = max(lumaN, lumaW);
    FxaaFloat minWN = min(lumaN, lumaW);
    FxaaFloat rangeMax = max(maxWN, maxESM);
    FxaaFloat rangeMin = min(minWN, minESM);
    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
    FxaaFloat range = rangeMax - rangeMin;
    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
    FxaaBool earlyExit = range < rangeMaxClamped;
/*--------------------------------------------------------------------------*/
    if(earlyExit)
        return rgbyM;
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaSE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaNE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaSW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNS = lumaN + lumaS;
    FxaaFloat lumaWE = lumaW + lumaE;
    FxaaFloat subpixRcpRange = 1.0/range;
    FxaaFloat subpixNSWE = lumaNS + lumaWE;
    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNESE = lumaNE + lumaSE;
    FxaaFloat lumaNWNE = lumaNW + lumaNE;
    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNWSW = lumaNW + lumaSW;
    FxaaFloat lumaSWSE = lumaSW + lumaSE;
    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
/*--------------------------------------------------------------------------*/
    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
    FxaaBool horzSpan = edgeHorz >= edgeVert;
    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
/*--------------------------------------------------------------------------*/
    if(!horzSpan) lumaN = lumaW;
    if(!horzSpan) lumaS = lumaE;
    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;
    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;
/*--------------------------------------------------------------------------*/
    FxaaFloat gradientN = lumaN - lumaM;
    FxaaFloat gradientS = lumaS - lumaM;
    FxaaFloat lumaNN = lumaN + lumaM;
    FxaaFloat lumaSS = lumaS + lumaM;
    FxaaBool pairN = abs(gradientN) >= abs(gradientS);
    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
    if(pairN) lengthSign = -lengthSign;
    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
/*--------------------------------------------------------------------------*/
    FxaaFloat2 posB;
    posB.x = posM.x;
    posB.y = posM.y;
    FxaaFloat2 offNP;
    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
    if(!horzSpan) posB.x += lengthSign * 0.5;
    if( horzSpan) posB.y += lengthSign * 0.5;
/*--------------------------------------------------------------------------*/
    FxaaFloat2 posN;
    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
    FxaaFloat2 posP;
    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;
    FxaaFloat lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN));
    FxaaFloat subpixE = subpixC * subpixC;
    FxaaFloat lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP));
/*--------------------------------------------------------------------------*/
    if(!pairN) lumaNN = lumaSS;
    FxaaFloat gradientScaled = gradient * 1.0/4.0;
    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
    FxaaFloat subpixF = subpixD * subpixE;
    FxaaBool lumaMLTZero = lumaMM < 0.0;
/*--------------------------------------------------------------------------*/
    lumaEndN -= lumaNN * 0.5;
    lumaEndP -= lumaNN * 0.5;
    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;
    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;
    FxaaBool doneNP = (!doneN) || (!doneP);
    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;
    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;
/*--------------------------------------------------------------------------*/
    if(doneNP) {
        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
        doneN = abs(lumaEndN) >= gradientScaled;
        doneP = abs(lumaEndP) >= gradientScaled;
        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;
        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;
        doneNP = (!doneN) || (!doneP);
        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;
        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;
/*--------------------------------------------------------------------------*/
        #if (FXAA_QUALITY_PS > 3)
        if(doneNP) {
            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
            doneN = abs(lumaEndN) >= gradientScaled;
            doneP = abs(lumaEndP) >= gradientScaled;
            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;
            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;
            doneNP = (!doneN) || (!doneP);
            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;
            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;
/*--------------------------------------------------------------------------*/
            #if (FXAA_QUALITY_PS > 4)
            if(doneNP) {
                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                doneN = abs(lumaEndN) >= gradientScaled;
                doneP = abs(lumaEndP) >= gradientScaled;
                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;
                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;
                doneNP = (!doneN) || (!doneP);
                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;
                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;
/*--------------------------------------------------------------------------*/
                #if (FXAA_QUALITY_PS > 5)
                if(doneNP) {
                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                    doneN = abs(lumaEndN) >= gradientScaled;
                    doneP = abs(lumaEndP) >= gradientScaled;
                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;
                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;
                    doneNP = (!doneN) || (!doneP);
                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;
                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;
/*--------------------------------------------------------------------------*/
                    #if (FXAA_QUALITY_PS > 6)
                    if(doneNP) {
                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                        doneN = abs(lumaEndN) >= gradientScaled;
                        doneP = abs(lumaEndP) >= gradientScaled;
                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;
                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;
                        doneNP = (!doneN) || (!doneP);
                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;
                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;
/*--------------------------------------------------------------------------*/
                        #if (FXAA_QUALITY_PS > 7)
                        if(doneNP) {
                            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                            doneN = abs(lumaEndN) >= gradientScaled;
                            doneP = abs(lumaEndP) >= gradientScaled;
                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;
                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;
                            doneNP = (!doneN) || (!doneP);
                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;
                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;
/*--------------------------------------------------------------------------*/
    #if (FXAA_QUALITY_PS > 8)
    if(doneNP) {
        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
        doneN = abs(lumaEndN) >= gradientScaled;
        doneP = abs(lumaEndP) >= gradientScaled;
        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;
        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;
        doneNP = (!doneN) || (!doneP);
        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;
        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;
/*--------------------------------------------------------------------------*/
        #if (FXAA_QUALITY_PS > 9)
        if(doneNP) {
            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
            doneN = abs(lumaEndN) >= gradientScaled;
            doneP = abs(lumaEndP) >= gradientScaled;
            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;
            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;
            doneNP = (!doneN) || (!doneP);
            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;
            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;
/*--------------------------------------------------------------------------*/
            #if (FXAA_QUALITY_PS > 10)
            if(doneNP) {
                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                doneN = abs(lumaEndN) >= gradientScaled;
                doneP = abs(lumaEndP) >= gradientScaled;
                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;
                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;
                doneNP = (!doneN) || (!doneP);
                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;
                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;
/*--------------------------------------------------------------------------*/
                #if (FXAA_QUALITY_PS > 11)
                if(doneNP) {
                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                    doneN = abs(lumaEndN) >= gradientScaled;
                    doneP = abs(lumaEndP) >= gradientScaled;
                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;
                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;
                    doneNP = (!doneN) || (!doneP);
                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;
                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;
/*--------------------------------------------------------------------------*/
                    #if (FXAA_QUALITY_PS > 12)
                    if(doneNP) {
                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                        doneN = abs(lumaEndN) >= gradientScaled;
                        doneP = abs(lumaEndP) >= gradientScaled;
                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;
                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;
                        doneNP = (!doneN) || (!doneP);
                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;
                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;
/*--------------------------------------------------------------------------*/
                    }
                    #endif
/*--------------------------------------------------------------------------*/
                }
                #endif
/*--------------------------------------------------------------------------*/
            }
            #endif
/*--------------------------------------------------------------------------*/
        }
        #endif
/*--------------------------------------------------------------------------*/
    }
    #endif
/*--------------------------------------------------------------------------*/
                        }
                        #endif
/*--------------------------------------------------------------------------*/
                    }
                    #endif
/*--------------------------------------------------------------------------*/
                }
                #endif
/*--------------------------------------------------------------------------*/
            }
            #endif
/*--------------------------------------------------------------------------*/
        }
        #endif
/*--------------------------------------------------------------------------*/
    }
/*--------------------------------------------------------------------------*/
    FxaaFloat dstN = posM.x - posN.x;
    FxaaFloat dstP = posP.x - posM.x;
    if(!horzSpan) dstN = posM.y - posN.y;
    if(!horzSpan) dstP = posP.y - posM.y;
/*--------------------------------------------------------------------------*/
    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
    FxaaFloat spanLength = (dstP + dstN);
    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
    FxaaFloat spanLengthRcp = 1.0/spanLength;
/*--------------------------------------------------------------------------*/
    FxaaBool directionN = dstN < dstP;
    FxaaFloat dst = min(dstN, dstP);
    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
    FxaaFloat subpixG = subpixF * subpixF;
    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
/*--------------------------------------------------------------------------*/
    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
    return FxaaTexTop(tex, posM);
}

vec4 fxaa_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
    const float fxaa_QualitySubpix = 0.5;
    const float fxaa_QualityEdgeThreshold = 0.125;
    const float fxaa_QualityEdgeThresholdMin = 0.0833;

    return FxaaPixelShader_(
        texCoord,
        source,
        vec2(1.0) / texSize,
        fxaa_QualitySubpix,
        fxaa_QualityEdgeThreshold,
        fxaa_QualityEdgeThresholdMin
    );
}
`,gn={name:"fxaa",uniformPropTypes:{},fs:li,passes:[{sampler:!0}]};function Ge(r,e=[],t=0){let n=Math.fround(r),o=r-n;return e[t]=n,e[t+1]=o,e}function Kt(r){return r-Math.fround(r)}function Zt(r){let e=new Float32Array(32);for(let t=0;t<4;++t)for(let n=0;n<4;++n){let o=t*4+n;Ge(r[n*4+t],e,o*2)}return e}var xn=`uniform float ONE;
vec2 split(float a) {
const float SPLIT = 4097.0;
float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float a_hi = t * ONE - (t - a);
float a_lo = a * ONE - a_hi;
#else
float a_hi = t - (t - a);
float a_lo = a - a_hi;
#endif
return vec2(a_hi, a_lo);
}
vec2 split2(vec2 a) {
vec2 b = split(a.x);
b.y += a.y;
return b;
}
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float sum = (a + b) * ONE;
float err = b - (sum - a) * ONE;
#else
float sum = a + b;
float err = b - (sum - a);
#endif
return vec2(sum, err);
}
vec2 twoSum(float a, float b) {
float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
float v = s - a;
float err = (a - (s - v)) + (b - v);
#endif
return vec2(s, err);
}
vec2 twoSub(float a, float b) {
float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
float v = s - a;
float err = (a - (s - v)) - (b + v);
#endif
return vec2(s, err);
}
vec2 twoSqr(float a) {
float prod = a * a;
vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
return vec2(prod, err);
}
vec2 twoProd(float a, float b) {
float prod = a * b;
vec2 a_fp64 = split(a);
vec2 b_fp64 = split(b);
float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
return vec2(prod, err);
}
vec2 sum_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSum(a.x, b.x);
t = twoSum(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 sub_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSub(a.x, b.x);
t = twoSub(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 mul_fp64(vec2 a, vec2 b) {
vec2 prod = twoProd(a.x, b.x);
prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
return prod;
}
vec2 div_fp64(vec2 a, vec2 b) {
float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
vec2 yn = a * xn;
#endif
float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
vec2 prod = twoProd(xn, diff);
return sum_fp64(yn, prod);
}
vec2 sqrt_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
float x = 1.0 / sqrt(a.x);
float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
vec2 yn_sqr = twoSqr(yn) * ONE;
#else
vec2 yn_sqr = twoSqr(yn);
#endif
float diff = sub_fp64(a, yn_sqr).x;
vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
return sum_fp64(split(yn), prod);
#else
return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`;var vn=`const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);
const vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);
const vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);
const vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);
const vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);
const vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);
const vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);
const vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);
const vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);
const vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);
const vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);
const vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);
const vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);
const vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);
const vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);
const vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);
const vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);
const vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);
const vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);
const vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);
const vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);
const vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);
const vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);
const vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);
const vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);
const vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);
float nint(float d) {
if (d == floor(d)) return d;
return floor(d + 0.5);
}
vec2 nint_fp64(vec2 a) {
float hi = nint(a.x);
float lo;
vec2 tmp;
if (hi == a.x) {
lo = nint(a.y);
tmp = quickTwoSum(hi, lo);
} else {
lo = 0.0;
if (abs(hi - a.x) == 0.5 && a.y < 0.0) {
hi -= 1.0;
}
tmp = vec2(hi, lo);
}
return tmp;
}
vec2 exp_fp64(vec2 a) {
const int k_power = 4;
const float k = 16.0;
const float inv_k = 1.0 / k;
if (a.x <= -88.0) return vec2(0.0, 0.0);
if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);
if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);
if (a.x == 1.0 && a.y == 0.0) return E_FP64;
float m = floor(a.x / LOG2_FP64.x + 0.5);
vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;
vec2 s, t, p;
p = mul_fp64(r, r);
s = sum_fp64(r, p * 0.5);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);
s = sum_fp64(s, t);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);
s = sum_fp64(s, t);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);
s = sum_fp64(s, t);
for (int i = 0; i < k_power; i++) {
s = sum_fp64(s * 2.0, mul_fp64(s, s));
}
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
s = sum_fp64(s, vec2(ONE, 0.0));
#else
s = sum_fp64(s, vec2(1.0, 0.0));
#endif
return s * pow(2.0, m);
}
vec2 log_fp64(vec2 a)
{
if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
vec2 x = vec2(log(a.x), 0.0);
vec2 s;
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
s = vec2(ONE, 0.0);
#else
s = vec2(1.0, 0.0);
#endif
x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);
return x;
}
vec2 sin_taylor_fp64(vec2 a) {
vec2 r, s, t, x;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
x = -mul_fp64(a, a);
s = a;
r = a;
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);
s = sum_fp64(s, t);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);
s = sum_fp64(s, t);
return s;
}
vec2 cos_taylor_fp64(vec2 a) {
vec2 r, s, t, x;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(1.0, 0.0);
}
x = -mul_fp64(a, a);
r = x;
s = sum_fp64(vec2(1.0, 0.0), r * 0.5);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);
s = sum_fp64(s, t);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);
s = sum_fp64(s, t);
return s;
}
void sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {
if (a.x == 0.0 && a.y == 0.0) {
sin_t = vec2(0.0, 0.0);
cos_t = vec2(1.0, 0.0);
}
sin_t = sin_taylor_fp64(a);
cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));
}
vec2 sin_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
if (k == 0) {
if (j == 0) {
return sin_taylor_fp64(t);
} else if (j == 1) {
return cos_taylor_fp64(t);
} else if (j == -1) {
return -cos_taylor_fp64(t);
} else {
return -sin_taylor_fp64(t);
}
}
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
vec2 sin_t, cos_t;
sincos_taylor_fp64(t, sin_t, cos_t);
vec2 result = vec2(0.0, 0.0);
if (j == 0) {
if (k > 0) {
result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
}
} else if (j == 1) {
if (k > 0) {
result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
} else if (j == -1) {
if (k > 0) {
result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
} else {
result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
}
} else {
if (k > 0) {
result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
}
}
return result;
}
vec2 cos_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) {
return vec2(1.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
if (k == 0) {
if (j == 0) {
return cos_taylor_fp64(t);
} else if (j == 1) {
return -sin_taylor_fp64(t);
} else if (j == -1) {
return sin_taylor_fp64(t);
} else {
return -cos_taylor_fp64(t);
}
}
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
vec2 sin_t, cos_t;
sincos_taylor_fp64(t, sin_t, cos_t);
vec2 result = vec2(0.0, 0.0);
if (j == 0) {
if (k > 0) {
result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
} else if (j == 1) {
if (k > 0) {
result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
}
} else if (j == -1) {
if (k > 0) {
result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
}
} else {
if (k > 0) {
result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
} else {
result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
}
return result;
}
vec2 tan_fp64(vec2 a) {
vec2 sin_a;
vec2 cos_a;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
vec2 sin_t, cos_t;
vec2 s, c;
sincos_taylor_fp64(t, sin_t, cos_t);
if (k == 0) {
s = sin_t;
c = cos_t;
} else {
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
if (k > 0) {
s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
}
if (j == 0) {
sin_a = s;
cos_a = c;
} else if (j == 1) {
sin_a = c;
cos_a = -s;
} else if (j == -1) {
sin_a = -c;
cos_a = s;
} else {
sin_a = -s;
cos_a = -c;
}
return div_fp64(sin_a, cos_a);
}
vec2 radians_fp64(vec2 degree) {
return mul_fp64(degree, PI_180_FP64);
}
vec2 mix_fp64(vec2 a, vec2 b, float x) {
vec2 range = sub_fp64(b, a);
return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}
void vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = sum_fp64(a[0], b[0]);
out_val[1] = sum_fp64(a[1], b[1]);
}
void vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = sub_fp64(a[0], b[0]);
out_val[1] = sub_fp64(a[1], b[1]);
}
void vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = mul_fp64(a[0], b[0]);
out_val[1] = mul_fp64(a[1], b[1]);
}
void vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = div_fp64(a[0], b[0]);
out_val[1] = div_fp64(a[1], b[1]);
}
void vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {
vec2 range[2];
vec2_sub_fp64(y, x, range);
vec2 portion[2];
portion[0] = range[0] * a;
portion[1] = range[1] * a;
vec2_sum_fp64(x, portion, out_val);
}
vec2 vec2_length_fp64(vec2 x[2]) {
return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));
}
void vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {
vec2 length = vec2_length_fp64(x);
vec2 length_vec2[2];
length_vec2[0] = length;
length_vec2[1] = length;
vec2_div_fp64(x, length_vec2, out_val);
}
vec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {
vec2 diff[2];
vec2_sub_fp64(x, y, diff);
return vec2_length_fp64(diff);
}
vec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {
vec2 v[2];
v[0] = mul_fp64(a[0], b[0]);
v[1] = mul_fp64(a[1], b[1]);
return sum_fp64(v[0], v[1]);
}
void vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
for (int i = 0; i < 3; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
void vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
for (int i = 0; i < 3; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
vec2 vec3_length_fp64(vec2 x[3]) {
return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),
mul_fp64(x[2], x[2])));
}
vec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {
vec2 diff[3];
vec3_sub_fp64(x, y, diff);
return vec3_length_fp64(diff);
}
void vec4_fp64(vec4 a, out vec2 out_val[4]) {
out_val[0].x = a[0];
out_val[0].y = 0.0;
out_val[1].x = a[1];
out_val[1].y = 0.0;
out_val[2].x = a[2];
out_val[2].y = 0.0;
out_val[3].x = a[3];
out_val[3].y = 0.0;
}
void vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {
out_val[0] = mul_fp64(a[0], b);
out_val[1] = mul_fp64(a[1], b);
out_val[2] = mul_fp64(a[2], b);
out_val[3] = mul_fp64(a[3], b);
}
void vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {
for (int i = 0; i < 4; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
void vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {
vec2 v[4];
v[0] = mul_fp64(a[0], b[0]);
v[1] = mul_fp64(a[1], b[1]);
v[2] = mul_fp64(a[2], b[2]);
v[3] = mul_fp64(a[3], b[3]);
out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));
}
void mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {
vec2 tmp[4];
for (int i = 0; i < 4; i++)
{
for (int j = 0; j < 4; j++)
{
tmp[j] = b[j + i * 4];
}
vec4_dot_fp64(a, tmp, out_val[i]);
}
}
`;var fi={ONE:1};function ui(){return fi}var Jt={name:"fp64-arithmetic",vs:xn,getUniforms:ui,fp64ify:Ge,fp64LowPart:Kt,fp64ifyMatrix4:Zt},An={name:"fp64",vs:vn,dependencies:[Jt],fp64ify:Ge,fp64LowPart:Kt,fp64ifyMatrix4:Zt};var _i=`varying vec4 geometry_vPosition;
varying vec3 geometry_vNormal;
void geometry_setNormal(vec3 normal) {
geometry_vNormal = normal;
}
void geometry_setPosition(vec4 position) {
geometry_vPosition = position;
}
void geometry_setPosition(vec3 position) {
geometry_vPosition = vec4(position, 1.);
}
`,hi=`varying vec4 geometry_vPosition;
varying vec3 geometry_vNormal;
vec4 geometry_getPosition() {
return geometry_vPosition;
}
vec3 geometry_getNormal() {
return geometry_vNormal;
}
`,yn={name:"geometry",vs:_i,fs:hi};var Ra=1/Math.PI*180,Oa=1/180*Math.PI,pi={EPSILON:1e-12,debug:!1,precision:4,printTypes:!1,printDegrees:!1,printRowMajor:!0,_cartographicRadians:!1};globalThis.mathgl=globalThis.mathgl||{config:{...pi}};var O=globalThis.mathgl.config;function bn(r,{precision:e=O.precision}={}){return r=di(r),`${parseFloat(r.toPrecision(e))}`}function He(r){return Array.isArray(r)||ArrayBuffer.isView(r)&&!(r instanceof DataView)}function er(r,e,t){let n=O.EPSILON;t&&(O.EPSILON=t);try{if(r===e)return!0;if(He(r)&&He(e)){if(r.length!==e.length)return!1;for(let o=0;o<r.length;++o)if(!er(r[o],e[o]))return!1;return!0}return r&&r.equals?r.equals(e):e&&e.equals?e.equals(r):typeof r=="number"&&typeof e=="number"?Math.abs(r-e)<=O.EPSILON*Math.max(1,Math.abs(r),Math.abs(e)):!1}finally{O.EPSILON=n}}function di(r){return Math.round(r/O.EPSILON)*O.EPSILON}var We=class extends Array{clone(){return new this.constructor().copy(this)}fromArray(e,t=0){for(let n=0;n<this.ELEMENTS;++n)this[n]=e[n+t];return this.check()}toArray(e=[],t=0){for(let n=0;n<this.ELEMENTS;++n)e[t+n]=this[n];return e}toObject(e){return e}from(e){return Array.isArray(e)?this.copy(e):this.fromObject(e)}to(e){return e===this?this:He(e)?this.toArray(e):this.toObject(e)}toTarget(e){return e?this.to(e):this}toFloat32Array(){return new Float32Array(this)}toString(){return this.formatString(O)}formatString(e){let t="";for(let n=0;n<this.ELEMENTS;++n)t+=(n>0?", ":"")+bn(this[n],e);return`${e.printTypes?this.constructor.name:""}[${t}]`}equals(e){if(!e||this.length!==e.length)return!1;for(let t=0;t<this.ELEMENTS;++t)if(!er(this[t],e[t]))return!1;return!0}exactEquals(e){if(!e||this.length!==e.length)return!1;for(let t=0;t<this.ELEMENTS;++t)if(this[t]!==e[t])return!1;return!0}negate(){for(let e=0;e<this.ELEMENTS;++e)this[e]=-this[e];return this.check()}lerp(e,t,n){if(n===void 0)return this.lerp(this,e,t);for(let o=0;o<this.ELEMENTS;++o){let i=e[o],a=typeof t=="number"?t:t[o];this[o]=i+n*(a-i)}return this.check()}min(e){for(let t=0;t<this.ELEMENTS;++t)this[t]=Math.min(e[t],this[t]);return this.check()}max(e){for(let t=0;t<this.ELEMENTS;++t)this[t]=Math.max(e[t],this[t]);return this.check()}clamp(e,t){for(let n=0;n<this.ELEMENTS;++n)this[n]=Math.min(Math.max(this[n],e[n]),t[n]);return this.check()}add(...e){for(let t of e)for(let n=0;n<this.ELEMENTS;++n)this[n]+=t[n];return this.check()}subtract(...e){for(let t of e)for(let n=0;n<this.ELEMENTS;++n)this[n]-=t[n];return this.check()}scale(e){if(typeof e=="number")for(let t=0;t<this.ELEMENTS;++t)this[t]*=e;else for(let t=0;t<this.ELEMENTS&&t<e.length;++t)this[t]*=e[t];return this.check()}multiplyByScalar(e){for(let t=0;t<this.ELEMENTS;++t)this[t]*=e;return this.check()}check(){if(O.debug&&!this.validate())throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);return this}validate(){let e=this.length===this.ELEMENTS;for(let t=0;t<this.ELEMENTS;++t)e=e&&Number.isFinite(this[t]);return e}sub(e){return this.subtract(e)}setScalar(e){for(let t=0;t<this.ELEMENTS;++t)this[t]=e;return this.check()}addScalar(e){for(let t=0;t<this.ELEMENTS;++t)this[t]+=e;return this.check()}subScalar(e){return this.addScalar(-e)}multiplyScalar(e){for(let t=0;t<this.ELEMENTS;++t)this[t]*=e;return this.check()}divideScalar(e){return this.multiplyByScalar(1/e)}clampScalar(e,t){for(let n=0;n<this.ELEMENTS;++n)this[n]=Math.min(Math.max(this[n],e),t);return this.check()}get elements(){return this}};function mi(r,e){if(r.length!==e)return!1;for(let t=0;t<r.length;++t)if(!Number.isFinite(r[t]))return!1;return!0}function Pn(r){if(!Number.isFinite(r))throw new Error(`Invalid number ${JSON.stringify(r)}`);return r}function je(r,e,t=""){if(O.debug&&!mi(r,e))throw new Error(`math.gl: ${t} some fields set to invalid numbers'`);return r}var W=typeof Float32Array<"u"?Float32Array:Array;var Ba=Math.PI/180;function gi(){let r=new W(2);return W!=Float32Array&&(r[0]=0,r[1]=0),r}function kn(r,e,t){let n=e[0],o=e[1];return r[0]=t[0]*n+t[4]*o+t[12],r[1]=t[1]*n+t[5]*o+t[13],r}var Qa=function(){let r=gi();return function(e,t,n,o,i,a){let c,u;for(t||(t=2),n||(n=0),o?u=Math.min(o*t+n,e.length):u=e.length,c=n;c<u;c+=t)r[0]=e[c],r[1]=e[c+1],i(r,r,a),e[c]=r[0],e[c+1]=r[1];return e}}();function Sn(r,e,t){let n=e[0],o=e[1],i=t[3]*n+t[7]*o||1;return r[0]=(t[0]*n+t[4]*o)/i,r[1]=(t[1]*n+t[5]*o)/i,r}function Nn(r,e,t){let n=e[0],o=e[1],i=e[2],a=t[3]*n+t[7]*o+t[11]*i||1;return r[0]=(t[0]*n+t[4]*o+t[8]*i)/a,r[1]=(t[1]*n+t[5]*o+t[9]*i)/a,r[2]=(t[2]*n+t[6]*o+t[10]*i)/a,r}function xi(){let r=new W(3);return W!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r}function Tn(r,e,t){let n=e[0],o=e[1],i=e[2],a=t[3]*n+t[7]*o+t[11]*i+t[15];return a=a||1,r[0]=(t[0]*n+t[4]*o+t[8]*i+t[12])/a,r[1]=(t[1]*n+t[5]*o+t[9]*i+t[13])/a,r[2]=(t[2]*n+t[6]*o+t[10]*i+t[14])/a,r}var Ga=function(){let r=xi();return function(e,t,n,o,i,a){let c,u;for(t||(t=3),n||(n=0),o?u=Math.min(o*t+n,e.length):u=e.length,c=n;c<u;c+=t)r[0]=e[c],r[1]=e[c+1],r[2]=e[c+2],i(r,r,a),e[c]=r[0],e[c+1]=r[1],e[c+2]=r[2];return e}}();var $e=class extends We{toString(){let e="[";if(O.printRowMajor){e+="row-major:";for(let t=0;t<this.RANK;++t)for(let n=0;n<this.RANK;++n)e+=` ${this[n*this.RANK+t]}`}else{e+="column-major:";for(let t=0;t<this.ELEMENTS;++t)e+=` ${this[t]}`}return e+="]",e}getElementIndex(e,t){return t*this.RANK+e}getElement(e,t){return this[t*this.RANK+e]}setElement(e,t,n){return this[t*this.RANK+e]=Pn(n),this}getColumn(e,t=new Array(this.RANK).fill(-0)){let n=e*this.RANK;for(let o=0;o<this.RANK;++o)t[o]=this[n+o];return t}setColumn(e,t){let n=e*this.RANK;for(let o=0;o<this.RANK;++o)this[n+o]=t[o];return this}};function vi(r){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function En(r,e){if(r===e){let t=e[1],n=e[2],o=e[3],i=e[6],a=e[7],c=e[11];r[1]=e[4],r[2]=e[8],r[3]=e[12],r[4]=t,r[6]=e[9],r[7]=e[13],r[8]=n,r[9]=i,r[11]=e[14],r[12]=o,r[13]=a,r[14]=c}else r[0]=e[0],r[1]=e[4],r[2]=e[8],r[3]=e[12],r[4]=e[1],r[5]=e[5],r[6]=e[9],r[7]=e[13],r[8]=e[2],r[9]=e[6],r[10]=e[10],r[11]=e[14],r[12]=e[3],r[13]=e[7],r[14]=e[11],r[15]=e[15];return r}function Mn(r,e){let t=e[0],n=e[1],o=e[2],i=e[3],a=e[4],c=e[5],u=e[6],h=e[7],p=e[8],d=e[9],m=e[10],x=e[11],w=e[12],g=e[13],A=e[14],L=e[15],v=t*c-n*a,b=t*u-o*a,P=t*h-i*a,y=n*u-o*c,k=n*h-i*c,S=o*h-i*u,F=p*g-d*w,M=p*A-m*w,T=p*L-x*w,I=d*A-m*g,z=d*L-x*g,R=m*L-x*A,E=v*R-b*z+P*I+y*T-k*M+S*F;return E?(E=1/E,r[0]=(c*R-u*z+h*I)*E,r[1]=(o*z-n*R-i*I)*E,r[2]=(g*S-A*k+L*y)*E,r[3]=(m*k-d*S-x*y)*E,r[4]=(u*T-a*R-h*M)*E,r[5]=(t*R-o*T+i*M)*E,r[6]=(A*P-w*S-L*b)*E,r[7]=(p*S-m*P+x*b)*E,r[8]=(a*z-c*T+h*F)*E,r[9]=(n*T-t*z-i*F)*E,r[10]=(w*k-g*P+L*v)*E,r[11]=(d*P-p*k-x*v)*E,r[12]=(c*M-a*I-u*F)*E,r[13]=(t*I-n*M+o*F)*E,r[14]=(g*b-w*y-A*v)*E,r[15]=(p*y-d*b+m*v)*E,r):null}function Fn(r){let e=r[0],t=r[1],n=r[2],o=r[3],i=r[4],a=r[5],c=r[6],u=r[7],h=r[8],p=r[9],d=r[10],m=r[11],x=r[12],w=r[13],g=r[14],A=r[15],L=e*a-t*i,v=e*c-n*i,b=t*c-n*a,P=h*w-p*x,y=h*g-d*x,k=p*g-d*w,S=e*k-t*y+n*P,F=i*k-a*y+c*P,M=h*b-p*v+d*L,T=x*b-w*v+g*L;return u*S-o*F+A*M-m*T}function rr(r,e,t){let n=e[0],o=e[1],i=e[2],a=e[3],c=e[4],u=e[5],h=e[6],p=e[7],d=e[8],m=e[9],x=e[10],w=e[11],g=e[12],A=e[13],L=e[14],v=e[15],b=t[0],P=t[1],y=t[2],k=t[3];return r[0]=b*n+P*c+y*d+k*g,r[1]=b*o+P*u+y*m+k*A,r[2]=b*i+P*h+y*x+k*L,r[3]=b*a+P*p+y*w+k*v,b=t[4],P=t[5],y=t[6],k=t[7],r[4]=b*n+P*c+y*d+k*g,r[5]=b*o+P*u+y*m+k*A,r[6]=b*i+P*h+y*x+k*L,r[7]=b*a+P*p+y*w+k*v,b=t[8],P=t[9],y=t[10],k=t[11],r[8]=b*n+P*c+y*d+k*g,r[9]=b*o+P*u+y*m+k*A,r[10]=b*i+P*h+y*x+k*L,r[11]=b*a+P*p+y*w+k*v,b=t[12],P=t[13],y=t[14],k=t[15],r[12]=b*n+P*c+y*d+k*g,r[13]=b*o+P*u+y*m+k*A,r[14]=b*i+P*h+y*x+k*L,r[15]=b*a+P*p+y*w+k*v,r}function In(r,e,t){let n=t[0],o=t[1],i=t[2],a,c,u,h,p,d,m,x,w,g,A,L;return e===r?(r[12]=e[0]*n+e[4]*o+e[8]*i+e[12],r[13]=e[1]*n+e[5]*o+e[9]*i+e[13],r[14]=e[2]*n+e[6]*o+e[10]*i+e[14],r[15]=e[3]*n+e[7]*o+e[11]*i+e[15]):(a=e[0],c=e[1],u=e[2],h=e[3],p=e[4],d=e[5],m=e[6],x=e[7],w=e[8],g=e[9],A=e[10],L=e[11],r[0]=a,r[1]=c,r[2]=u,r[3]=h,r[4]=p,r[5]=d,r[6]=m,r[7]=x,r[8]=w,r[9]=g,r[10]=A,r[11]=L,r[12]=a*n+p*o+w*i+e[12],r[13]=c*n+d*o+g*i+e[13],r[14]=u*n+m*o+A*i+e[14],r[15]=h*n+x*o+L*i+e[15]),r}function Cn(r,e,t){let n=t[0],o=t[1],i=t[2];return r[0]=e[0]*n,r[1]=e[1]*n,r[2]=e[2]*n,r[3]=e[3]*n,r[4]=e[4]*o,r[5]=e[5]*o,r[6]=e[6]*o,r[7]=e[7]*o,r[8]=e[8]*i,r[9]=e[9]*i,r[10]=e[10]*i,r[11]=e[11]*i,r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15],r}function Rn(r,e,t,n){let o=n[0],i=n[1],a=n[2],c=Math.sqrt(o*o+i*i+a*a),u,h,p,d,m,x,w,g,A,L,v,b,P,y,k,S,F,M,T,I,z,R,E,_e;return c<1e-6?null:(c=1/c,o*=c,i*=c,a*=c,h=Math.sin(t),u=Math.cos(t),p=1-u,d=e[0],m=e[1],x=e[2],w=e[3],g=e[4],A=e[5],L=e[6],v=e[7],b=e[8],P=e[9],y=e[10],k=e[11],S=o*o*p+u,F=i*o*p+a*h,M=a*o*p-i*h,T=o*i*p-a*h,I=i*i*p+u,z=a*i*p+o*h,R=o*a*p+i*h,E=i*a*p-o*h,_e=a*a*p+u,r[0]=d*S+g*F+b*M,r[1]=m*S+A*F+P*M,r[2]=x*S+L*F+y*M,r[3]=w*S+v*F+k*M,r[4]=d*T+g*I+b*z,r[5]=m*T+A*I+P*z,r[6]=x*T+L*I+y*z,r[7]=w*T+v*I+k*z,r[8]=d*R+g*E+b*_e,r[9]=m*R+A*E+P*_e,r[10]=x*R+L*E+y*_e,r[11]=w*R+v*E+k*_e,e!==r&&(r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r)}function On(r,e,t){let n=Math.sin(t),o=Math.cos(t),i=e[4],a=e[5],c=e[6],u=e[7],h=e[8],p=e[9],d=e[10],m=e[11];return e!==r&&(r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[4]=i*o+h*n,r[5]=a*o+p*n,r[6]=c*o+d*n,r[7]=u*o+m*n,r[8]=h*o-i*n,r[9]=p*o-a*n,r[10]=d*o-c*n,r[11]=m*o-u*n,r}function Un(r,e,t){let n=Math.sin(t),o=Math.cos(t),i=e[0],a=e[1],c=e[2],u=e[3],h=e[8],p=e[9],d=e[10],m=e[11];return e!==r&&(r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[0]=i*o-h*n,r[1]=a*o-p*n,r[2]=c*o-d*n,r[3]=u*o-m*n,r[8]=i*n+h*o,r[9]=a*n+p*o,r[10]=c*n+d*o,r[11]=u*n+m*o,r}function zn(r,e,t){let n=Math.sin(t),o=Math.cos(t),i=e[0],a=e[1],c=e[2],u=e[3],h=e[4],p=e[5],d=e[6],m=e[7];return e!==r&&(r[8]=e[8],r[9]=e[9],r[10]=e[10],r[11]=e[11],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[0]=i*o+h*n,r[1]=a*o+p*n,r[2]=c*o+d*n,r[3]=u*o+m*n,r[4]=h*o-i*n,r[5]=p*o-a*n,r[6]=d*o-c*n,r[7]=m*o-u*n,r}function Dn(r,e){let t=e[0],n=e[1],o=e[2],i=e[3],a=t+t,c=n+n,u=o+o,h=t*a,p=n*a,d=n*c,m=o*a,x=o*c,w=o*u,g=i*a,A=i*c,L=i*u;return r[0]=1-d-w,r[1]=p+L,r[2]=m-A,r[3]=0,r[4]=p-L,r[5]=1-h-w,r[6]=x+g,r[7]=0,r[8]=m+A,r[9]=x-g,r[10]=1-h-d,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function Yn(r,e,t,n,o,i,a){let c=1/(t-e),u=1/(o-n),h=1/(i-a);return r[0]=i*2*c,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=i*2*u,r[6]=0,r[7]=0,r[8]=(t+e)*c,r[9]=(o+n)*u,r[10]=(a+i)*h,r[11]=-1,r[12]=0,r[13]=0,r[14]=a*i*2*h,r[15]=0,r}function Ai(r,e,t,n,o){let i=1/Math.tan(e/2);if(r[0]=i/t,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=i,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,o!=null&&o!==1/0){let a=1/(n-o);r[10]=(o+n)*a,r[14]=2*o*n*a}else r[10]=-1,r[14]=-2*n;return r}var Xn=Ai;function yi(r,e,t,n,o,i,a){let c=1/(e-t),u=1/(n-o),h=1/(i-a);return r[0]=-2*c,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=-2*u,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=2*h,r[11]=0,r[12]=(e+t)*c,r[13]=(o+n)*u,r[14]=(a+i)*h,r[15]=1,r}var Bn=yi;function Qn(r,e,t,n){let o,i,a,c,u,h,p,d,m,x,w=e[0],g=e[1],A=e[2],L=n[0],v=n[1],b=n[2],P=t[0],y=t[1],k=t[2];return Math.abs(w-P)<1e-6&&Math.abs(g-y)<1e-6&&Math.abs(A-k)<1e-6?vi(r):(d=w-P,m=g-y,x=A-k,o=1/Math.sqrt(d*d+m*m+x*x),d*=o,m*=o,x*=o,i=v*x-b*m,a=b*d-L*x,c=L*m-v*d,o=Math.sqrt(i*i+a*a+c*c),o?(o=1/o,i*=o,a*=o,c*=o):(i=0,a=0,c=0),u=m*c-x*a,h=x*i-d*c,p=d*a-m*i,o=Math.sqrt(u*u+h*h+p*p),o?(o=1/o,u*=o,h*=o,p*=o):(u=0,h=0,p=0),r[0]=i,r[1]=u,r[2]=d,r[3]=0,r[4]=a,r[5]=h,r[6]=m,r[7]=0,r[8]=c,r[9]=p,r[10]=x,r[11]=0,r[12]=-(i*w+a*g+c*A),r[13]=-(u*w+h*g+p*A),r[14]=-(d*w+m*g+x*A),r[15]=1,r)}function bi(){let r=new W(4);return W!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0,r[3]=0),r}function qn(r,e,t){let n=e[0],o=e[1],i=e[2],a=e[3];return r[0]=t[0]*n+t[4]*o+t[8]*i+t[12]*a,r[1]=t[1]*n+t[5]*o+t[9]*i+t[13]*a,r[2]=t[2]*n+t[6]*o+t[10]*i+t[14]*a,r[3]=t[3]*n+t[7]*o+t[11]*i+t[15]*a,r}var Ja=function(){let r=bi();return function(e,t,n,o,i,a){let c,u;for(t||(t=4),n||(n=0),o?u=Math.min(o*t+n,e.length):u=e.length,c=n;c<u;c+=t)r[0]=e[c],r[1]=e[c+1],r[2]=e[c+2],r[3]=e[c+3],i(r,r,a),e[c]=r[0],e[c+1]=r[1],e[c+2]=r[2],e[c+3]=r[3];return e}}();var ir;(function(r){r[r.COL0ROW0=0]="COL0ROW0",r[r.COL0ROW1=1]="COL0ROW1",r[r.COL0ROW2=2]="COL0ROW2",r[r.COL0ROW3=3]="COL0ROW3",r[r.COL1ROW0=4]="COL1ROW0",r[r.COL1ROW1=5]="COL1ROW1",r[r.COL1ROW2=6]="COL1ROW2",r[r.COL1ROW3=7]="COL1ROW3",r[r.COL2ROW0=8]="COL2ROW0",r[r.COL2ROW1=9]="COL2ROW1",r[r.COL2ROW2=10]="COL2ROW2",r[r.COL2ROW3=11]="COL2ROW3",r[r.COL3ROW0=12]="COL3ROW0",r[r.COL3ROW1=13]="COL3ROW1",r[r.COL3ROW2=14]="COL3ROW2",r[r.COL3ROW3=15]="COL3ROW3"})(ir||(ir={}));var Pi=45*Math.PI/180,wi=1,nr=.1,or=500,Li=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),ee=class extends $e{static get IDENTITY(){return Si()}static get ZERO(){return ki()}get ELEMENTS(){return 16}get RANK(){return 4}get INDICES(){return ir}constructor(e){super(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),arguments.length===1&&Array.isArray(e)?this.copy(e):this.identity()}copy(e){return this[0]=e[0],this[1]=e[1],this[2]=e[2],this[3]=e[3],this[4]=e[4],this[5]=e[5],this[6]=e[6],this[7]=e[7],this[8]=e[8],this[9]=e[9],this[10]=e[10],this[11]=e[11],this[12]=e[12],this[13]=e[13],this[14]=e[14],this[15]=e[15],this.check()}set(e,t,n,o,i,a,c,u,h,p,d,m,x,w,g,A){return this[0]=e,this[1]=t,this[2]=n,this[3]=o,this[4]=i,this[5]=a,this[6]=c,this[7]=u,this[8]=h,this[9]=p,this[10]=d,this[11]=m,this[12]=x,this[13]=w,this[14]=g,this[15]=A,this.check()}setRowMajor(e,t,n,o,i,a,c,u,h,p,d,m,x,w,g,A){return this[0]=e,this[1]=i,this[2]=h,this[3]=x,this[4]=t,this[5]=a,this[6]=p,this[7]=w,this[8]=n,this[9]=c,this[10]=d,this[11]=g,this[12]=o,this[13]=u,this[14]=m,this[15]=A,this.check()}toRowMajor(e){return e[0]=this[0],e[1]=this[4],e[2]=this[8],e[3]=this[12],e[4]=this[1],e[5]=this[5],e[6]=this[9],e[7]=this[13],e[8]=this[2],e[9]=this[6],e[10]=this[10],e[11]=this[14],e[12]=this[3],e[13]=this[7],e[14]=this[11],e[15]=this[15],e}identity(){return this.copy(Li)}fromObject(e){return this.check()}fromQuaternion(e){return Dn(this,e),this.check()}frustum(e){let{left:t,right:n,bottom:o,top:i,near:a=nr,far:c=or}=e;return c===1/0?Ni(this,t,n,o,i,a):Yn(this,t,n,o,i,a,c),this.check()}lookAt(e){let{eye:t,center:n=[0,0,0],up:o=[0,1,0]}=e;return Qn(this,t,n,o),this.check()}ortho(e){let{left:t,right:n,bottom:o,top:i,near:a=nr,far:c=or}=e;return Bn(this,t,n,o,i,a,c),this.check()}orthographic(e){let{fovy:t=Pi,aspect:n=wi,focalDistance:o=1,near:i=nr,far:a=or}=e;Vn(t);let c=t/2,u=o*Math.tan(c),h=u*n;return this.ortho({left:-h,right:h,bottom:-u,top:u,near:i,far:a})}perspective(e){let{fovy:t=45*Math.PI/180,aspect:n=1,near:o=.1,far:i=500}=e;return Vn(t),Xn(this,t,n,o,i),this.check()}determinant(){return Fn(this)}getScale(e=[-0,-0,-0]){return e[0]=Math.sqrt(this[0]*this[0]+this[1]*this[1]+this[2]*this[2]),e[1]=Math.sqrt(this[4]*this[4]+this[5]*this[5]+this[6]*this[6]),e[2]=Math.sqrt(this[8]*this[8]+this[9]*this[9]+this[10]*this[10]),e}getTranslation(e=[-0,-0,-0]){return e[0]=this[12],e[1]=this[13],e[2]=this[14],e}getRotation(e,t){e=e||[-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],t=t||[-0,-0,-0];let n=this.getScale(t),o=1/n[0],i=1/n[1],a=1/n[2];return e[0]=this[0]*o,e[1]=this[1]*i,e[2]=this[2]*a,e[3]=0,e[4]=this[4]*o,e[5]=this[5]*i,e[6]=this[6]*a,e[7]=0,e[8]=this[8]*o,e[9]=this[9]*i,e[10]=this[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}getRotationMatrix3(e,t){e=e||[-0,-0,-0,-0,-0,-0,-0,-0,-0],t=t||[-0,-0,-0];let n=this.getScale(t),o=1/n[0],i=1/n[1],a=1/n[2];return e[0]=this[0]*o,e[1]=this[1]*i,e[2]=this[2]*a,e[3]=this[4]*o,e[4]=this[5]*i,e[5]=this[6]*a,e[6]=this[8]*o,e[7]=this[9]*i,e[8]=this[10]*a,e}transpose(){return En(this,this),this.check()}invert(){return Mn(this,this),this.check()}multiplyLeft(e){return rr(this,e,this),this.check()}multiplyRight(e){return rr(this,this,e),this.check()}rotateX(e){return On(this,this,e),this.check()}rotateY(e){return Un(this,this,e),this.check()}rotateZ(e){return zn(this,this,e),this.check()}rotateXYZ(e){return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2])}rotateAxis(e,t){return Rn(this,this,e,t),this.check()}scale(e){return Cn(this,this,Array.isArray(e)?e:[e,e,e]),this.check()}translate(e){return In(this,this,e),this.check()}transform(e,t){return e.length===4?(t=qn(t||[-0,-0,-0,-0],e,this),je(t,4),t):this.transformAsPoint(e,t)}transformAsPoint(e,t){let{length:n}=e,o;switch(n){case 2:o=kn(t||[-0,-0],e,this);break;case 3:o=Tn(t||[-0,-0,-0],e,this);break;default:throw new Error("Illegal vector")}return je(o,e.length),o}transformAsVector(e,t){let n;switch(e.length){case 2:n=Sn(t||[-0,-0],e,this);break;case 3:n=Nn(t||[-0,-0,-0],e,this);break;default:throw new Error("Illegal vector")}return je(n,e.length),n}transformPoint(e,t){return this.transformAsPoint(e,t)}transformVector(e,t){return this.transformAsPoint(e,t)}transformDirection(e,t){return this.transformAsVector(e,t)}makeRotationX(e){return this.identity().rotateX(e)}makeTranslation(e,t,n){return this.identity().translate([e,t,n])}},Ke,Ze;function ki(){return Ke||(Ke=new ee([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),Object.freeze(Ke)),Ke}function Si(){return Ze||(Ze=new ee,Object.freeze(Ze)),Ze}function Vn(r){if(r>Math.PI*2)throw Error("expected radians")}function Ni(r,e,t,n,o,i){let a=2*i/(t-e),c=2*i/(o-n),u=(t+e)/(t-e),h=(o+n)/(o-n),p=-1,d=-1,m=-2*i;return r[0]=a,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=c,r[6]=0,r[7]=0,r[8]=u,r[9]=h,r[10]=p,r[11]=d,r[12]=0,r[13]=0,r[14]=m,r[15]=0,r}var sr=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],Ti={modelMatrix:sr,viewMatrix:sr,projectionMatrix:sr,cameraPositionWorld:[0,0,0]};function Ei(r=Ti,e={}){let t={};return r.modelMatrix!==void 0&&(t.modelMatrix=r.modelMatrix),r.viewMatrix!==void 0&&(t.viewMatrix=r.viewMatrix),r.projectionMatrix!==void 0&&(t.projectionMatrix=r.projectionMatrix),r.cameraPositionWorld!==void 0&&(t.cameraPositionWorld=r.cameraPositionWorld),(r.projectionMatrix!==void 0||r.viewMatrix!==void 0)&&(t.viewProjectionMatrix=new ee(r.projectionMatrix).multiplyRight(r.viewMatrix)),t}var Gn=`varying vec4 project_vPositionWorld;
varying vec3 project_vNormalWorld;
vec4 project_getPosition_World() {
return project_vPositionWorld;
}
vec3 project_getNormal_World() {
return project_vNormalWorld;
}
`,Mi=`${Gn}

// Unprefixed uniforms
uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewProjectionMatrix;
uniform vec3 cameraPositionWorld;

struct World {
  vec3 position;
  vec3 normal;
};

World world;

void project_setPosition(vec4 position) {
  project_vPositionWorld = position;
}

void project_setNormal(vec3 normal) {
  project_vNormalWorld = normal;
}

void project_setPositionAndNormal_World(vec3 position, vec3 normal) {
  world.position = position;
  world.normal = normal;
}

void project_setPositionAndNormal_Model(vec3 position, vec3 normal) {
  world.position = (modelMatrix * vec4(position, 1.)).xyz;
  world.normal = mat3(modelMatrix) * normal;
}

vec4 project_model_to_clipspace(vec4 position) {
  return viewProjectionMatrix * modelMatrix * position;
}

vec4 project_model_to_clipspace(vec3 position) {
  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);
}

vec4 project_world_to_clipspace(vec3 position) {
  return viewProjectionMatrix * vec4(position, 1.);
}

vec4 project_view_to_clipspace(vec3 position) {
  return projectionMatrix * vec4(position, 1.);
}

vec4 project_to_clipspace(vec3 position) {
  return viewProjectionMatrix * vec4(position, 1.);
}
`,Fi=`
${Gn}`,Je={name:"project",getUniforms:Ei,vs:Mi,fs:Fi};var ar=`#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
vec3 color;
};
struct PointLight {
vec3 color;
vec3 position;
vec3 attenuation;
};
struct DirectionalLight {
vec3 color;
vec3 direction;
};
uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;
uniform bool lighting_uEnabled;
float getPointLightAttenuation(PointLight pointLight, float distance) {
return pointLight.attenuation.x
+ pointLight.attenuation.y * distance
+ pointLight.attenuation.z * distance * distance;
}
#endif
`;var Ii={lightSources:{}};function cr(r={}){let{color:e=[0,0,0],intensity:t=1}=r;return e.map(n=>n*t/255)}function Ci({ambientLight:r,pointLights:e=[],directionalLights:t=[]}){let n={};return r?n["lighting_uAmbientLight.color"]=cr(r):n["lighting_uAmbientLight.color"]=[0,0,0],e.forEach((o,i)=>{n[`lighting_uPointLight[${i}].color`]=cr(o),n[`lighting_uPointLight[${i}].position`]=o.position,n[`lighting_uPointLight[${i}].attenuation`]=o.attenuation||[1,0,0]}),n.lighting_uPointLightCount=e.length,t.forEach((o,i)=>{n[`lighting_uDirectionalLight[${i}].color`]=cr(o),n[`lighting_uDirectionalLight[${i}].direction`]=o.direction}),n.lighting_uDirectionalLightCount=t.length,n}function Hn(r=Ii){if("lightSources"in r){let{ambientLight:e,pointLights:t,directionalLights:n}=r.lightSources||{};return e||t&&t.length>0||n&&n.length>0?Object.assign({},Ci({ambientLight:e,pointLights:t,directionalLights:n}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in r){let e={pointLights:[],directionalLights:[]};for(let t of r.lights||[])switch(t.type){case"ambient":e.ambientLight=t;break;case"directional":e.directionalLights?.push(t);break;case"point":e.pointLights?.push(t);break;default:}return Hn({lightSources:e})}return{}}var te={name:"lights",vs:ar,fs:ar,getUniforms:Hn,defines:{MAX_LIGHTS:3}};var Ri={lightDirection:new Float32Array([1,1,2])};function Oi(r=Ri){let e={};return r.lightDirection&&(e.dirlight_uLightDirection=r.lightDirection),e}var Ui=`uniform vec3 dirlight_uLightDirection;
vec4 dirlight_filterColor(vec4 color) {
vec3 normal = project_getNormal_World();
float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));
return vec4(color.rgb * d, color.a);
}
`,Wn={name:"dirlight",fs:Ui,getUniforms:Oi,dependencies:[Je]};var lr=`uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
vec3 halfway_direction = normalize(light_direction + view_direction);
float lambertian = dot(light_direction, normal_worldspace);
float specular = 0.0;
if (lambertian > 0.0) {
float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
specular = pow(specular_angle, lighting_uShininess);
}
lambertian = max(lambertian, 0.0);
return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = surfaceColor;
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = vec3(0, 0, 0);
vec3 surfaceColor = vec3(0, 0, 0);
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
`;var zi={};function Di(r){let{ambient:e=.35,diffuse:t=.6,shininess:n=32,specularColor:o=[30,30,30]}=r;return{lighting_uAmbient:e,lighting_uDiffuse:t,lighting_uShininess:n,lighting_uSpecularColor:o.map(i=>i/255)}}function jn(r=zi){if(!("material"in r))return{};let{material:e}=r;return e?Di(e):{lighting_uEnabled:!1}}var $n={name:"gouraud-lighting",dependencies:[te],vs:lr,defines:{LIGHTING_VERTEX:1},getUniforms:jn},Kn={name:"phong-lighting",dependencies:[te],fs:lr,defines:{LIGHTING_FRAGMENT:1},getUniforms:jn};var Zn=`uniform mat4 u_MVPMatrix;
uniform mat4 u_ModelMatrix;
uniform mat4 u_NormalMatrix;
out vec3 pbr_vPosition;
out vec2 pbr_vUV;
#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
out mat3 pbr_vTBN;
# else
out vec3 pbr_vNormal;
# endif
#endif
void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
vec4 pos = u_ModelMatrix * position;
pbr_vPosition = vec3(pos.xyz) / pos.w;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));
vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));
vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else
pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0.,0.);
#endif
}
`;var Jn=`precision highp float;
uniform bool pbr_uUnlit;
#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
uniform vec2 u_ScaleIBLAmbient;
#endif
#ifdef HAS_BASECOLORMAP
uniform sampler2D u_BaseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D u_EmissiveSampler;
uniform vec3 u_EmissiveFactor;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D u_MetallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D u_OcclusionSampler;
uniform float u_OcclusionStrength;
#endif
#ifdef ALPHA_CUTOFF
uniform float u_AlphaCutoff;
#endif
uniform vec2 u_MetallicRoughnessValues;
uniform vec4 u_BaseColorFactor;
uniform vec3 u_Camera;
#ifdef PBR_DEBUG
uniform vec4 u_ScaleDiffBaseMR;
uniform vec4 u_ScaleFGDSpec;
#endif
in vec3 pbr_vPosition;
in vec2 pbr_vUV;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
in mat3 pbr_vTBN;
#else
in vec3 pbr_vNormal;
#endif
#endif
struct PBRInfo
{
float NdotL;
float NdotV;
float NdotH;
float LdotH;
float VdotH;
float perceptualRoughness;
float metalness;
vec3 reflectance0;
vec3 reflectance90;
float alphaRoughness;
vec3 diffuseColor;
vec3 specularColor;
vec3 n;
vec3 v;
};
const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;
vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else
vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif
return vec4(linOut,srgbIn.w);;
#else
return srgbIn;
#endif
}
vec3 getNormal()
{
#ifndef HAS_TANGENTS
vec3 pos_dx = dFdx(pbr_vPosition);
vec3 pos_dy = dFdy(pbr_vPosition);
vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);
#ifdef HAS_NORMALS
vec3 ng = normalize(pbr_vNormal);
#else
vec3 ng = cross(pos_dx, pos_dy);
#endif
t = normalize(t - ng * dot(ng, t));
vec3 b = normalize(cross(ng, t));
mat3 tbn = mat3(t, b, ng);
#else
mat3 tbn = pbr_vTBN;
#endif
#ifdef HAS_NORMALMAP
vec3 n = texture(u_NormalSampler, pbr_vUV).rgb;
n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));
#else
vec3 n = normalize(tbn[2].xyz);
#endif
return n;
}
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
float mipCount = 9.0;
float lod = (pbrInputs.perceptualRoughness * mipCount);
vec3 brdf = SRGBtoLINEAR(texture(u_brdfLUT,
vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;
#ifdef USE_TEX_LOD
vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;
#else
vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
#endif
vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);
diffuse *= u_ScaleIBLAmbient.x;
specular *= u_ScaleIBLAmbient.y;
return diffuse + specular;
}
#endif
vec3 diffuse(PBRInfo pbrInputs)
{
return pbrInputs.diffuseColor / M_PI;
}
vec3 specularReflection(PBRInfo pbrInputs)
{
return pbrInputs.reflectance0 +
(pbrInputs.reflectance90 - pbrInputs.reflectance0) *
pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}
float geometricOcclusion(PBRInfo pbrInputs)
{
float NdotL = pbrInputs.NdotL;
float NdotV = pbrInputs.NdotV;
float r = pbrInputs.alphaRoughness;
float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
return attenuationL * attenuationV;
}
float microfacetDistribution(PBRInfo pbrInputs)
{
float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
return roughnessSq / (M_PI * f * f);
}
void PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {
pbrInputs.NdotL = 1.0;
pbrInputs.NdotH = 0.0;
pbrInputs.LdotH = 0.0;
pbrInputs.VdotH = 1.0;
}
void PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {
vec3 n = pbrInputs.n;
vec3 v = pbrInputs.v;
vec3 l = normalize(lightDirection);
vec3 h = normalize(l+v);
pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);
pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);
pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);
pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);
}
void PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {
vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
PBRInfo_setDirectionalLight(pbrInputs, light_direction);
}
vec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {
vec3 F = specularReflection(pbrInputs);
float G = geometricOcclusion(pbrInputs);
float D = microfacetDistribution(pbrInputs);
vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);
return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);
}
vec4 pbr_filterColor(vec4 colorUnused)
{
#ifdef HAS_BASECOLORMAP
vec4 baseColor = SRGBtoLINEAR(texture(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;
#else
vec4 baseColor = u_BaseColorFactor;
#endif
#ifdef ALPHA_CUTOFF
if (baseColor.a < u_AlphaCutoff) {
discard;
}
#endif
vec3 color = vec3(0, 0, 0);
if(pbr_uUnlit){
color.rgb = baseColor.rgb;
}
else{
float perceptualRoughness = u_MetallicRoughnessValues.y;
float metallic = u_MetallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
vec4 mrSample = texture(u_MetallicRoughnessSampler, pbr_vUV);
perceptualRoughness = mrSample.g * perceptualRoughness;
metallic = mrSample.b * metallic;
#endif
perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
metallic = clamp(metallic, 0.0, 1.0);
float alphaRoughness = perceptualRoughness * perceptualRoughness;
vec3 f0 = vec3(0.04);
vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
diffuseColor *= 1.0 - metallic;
vec3 specularColor = mix(f0, baseColor.rgb, metallic);
float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);
float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
vec3 specularEnvironmentR0 = specularColor.rgb;
vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;
vec3 n = getNormal();
vec3 v = normalize(u_Camera - pbr_vPosition);
float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
vec3 reflection = -normalize(reflect(v, n));
PBRInfo pbrInputs = PBRInfo(
0.0,
NdotV,
0.0,
0.0,
0.0,
perceptualRoughness,
metallic,
specularEnvironmentR0,
specularEnvironmentR90,
alphaRoughness,
diffuseColor,
specularColor,
n,
v
);
#ifdef USE_LIGHTS
PBRInfo_setAmbientLight(pbrInputs);
color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);
for(int i = 0; i < lighting_uDirectionalLightCount; i++) {
if (i < lighting_uDirectionalLightCount) {
PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);
color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);
}
}
for(int i = 0; i < lighting_uPointLightCount; i++) {
if (i < lighting_uPointLightCount) {
PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);
float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));
color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);
}
}
#endif
#ifdef USE_IBL
color += getIBLContribution(pbrInputs, n, reflection);
#endif
#ifdef HAS_OCCLUSIONMAP
float ao = texture(u_OcclusionSampler, pbr_vUV).r;
color = mix(color, color * ao, u_OcclusionStrength);
#endif
#ifdef HAS_EMISSIVEMAP
vec3 emissive = SRGBtoLINEAR(texture(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;
color += emissive;
#endif
#ifdef PBR_DEBUG
color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);
color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);
color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);
#endif
}
return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`;var eo={name:"pbr",vs:Zn,fs:Jn,defines:{LIGHTING_FRAGMENT:1},dependencies:[te]};return lo(Pe);})();
/**
 * ORIGINAL LICENCE
 * @license
 * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
      return __exports__;
      });
