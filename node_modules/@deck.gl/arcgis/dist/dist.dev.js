(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // external-global-plugin:@deck.gl/core
  var require_core = __commonJS({
    "external-global-plugin:@deck.gl/core"(exports, module) {
      module.exports = globalThis.deck;
    }
  });

  // external-global-plugin:@luma.gl/engine
  var require_engine = __commonJS({
    "external-global-plugin:@luma.gl/engine"(exports, module) {
      module.exports = globalThis.luma;
    }
  });

  // ../../node_modules/esri-loader/dist/umd/esri-loader.js
  var require_esri_loader = __commonJS({
    "../../node_modules/esri-loader/dist/umd/esri-loader.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global.esriLoader = global.esriLoader || {});
      })(exports, function(exports2) {
        "use strict";
        var isBrowser = typeof window !== "undefined";
        var utils = {
          Promise: isBrowser ? window["Promise"] : void 0
        };
        var DEFAULT_VERSION = "4.25";
        var NEXT = "next";
        function parseVersion(version) {
          if (version.toLowerCase() === NEXT) {
            return NEXT;
          }
          var match = version && version.match(/^(\d)\.(\d+)/);
          return match && {
            major: parseInt(match[1], 10),
            minor: parseInt(match[2], 10)
          };
        }
        function getCdnUrl(version) {
          if (version === void 0) {
            version = DEFAULT_VERSION;
          }
          return "https://js.arcgis.com/".concat(version, "/");
        }
        function getCdnCssUrl(version) {
          if (version === void 0) {
            version = DEFAULT_VERSION;
          }
          var baseUrl = getCdnUrl(version);
          var parsedVersion = parseVersion(version);
          if (parsedVersion !== NEXT && parsedVersion.major === 3) {
            var path = parsedVersion.minor <= 10 ? "js/" : "";
            return "".concat(baseUrl).concat(path, "esri/css/esri.css");
          } else {
            return "".concat(baseUrl, "esri/themes/light/main.css");
          }
        }
        function createStylesheetLink(href) {
          var link = document.createElement("link");
          link.rel = "stylesheet";
          link.href = href;
          return link;
        }
        function insertLink(link, before) {
          if (before) {
            var beforeNode = document.querySelector(before);
            beforeNode.parentNode.insertBefore(link, beforeNode);
          } else {
            document.head.appendChild(link);
          }
        }
        function getCss(url) {
          return document.querySelector('link[href*="'.concat(url, '"]'));
        }
        function getCssUrl(urlOrVersion) {
          return !urlOrVersion || parseVersion(urlOrVersion) ? getCdnCssUrl(urlOrVersion) : urlOrVersion;
        }
        function loadCss(urlOrVersion, before) {
          var url = getCssUrl(urlOrVersion);
          var link = getCss(url);
          if (!link) {
            link = createStylesheetLink(url);
            insertLink(link, before);
          }
          return link;
        }
        var defaultOptions = {};
        function createScript(url) {
          var script = document.createElement("script");
          script.type = "text/javascript";
          script.src = url;
          script.setAttribute("data-esri-loader", "loading");
          return script;
        }
        function handleScriptLoad(script, callback, errback) {
          var onScriptError;
          if (errback) {
            onScriptError = handleScriptError(script, errback);
          }
          var onScriptLoad = function() {
            callback(script);
            script.removeEventListener("load", onScriptLoad, false);
            if (onScriptError) {
              script.removeEventListener("error", onScriptError, false);
            }
          };
          script.addEventListener("load", onScriptLoad, false);
        }
        function handleScriptError(script, callback) {
          var onScriptError = function(e) {
            callback(e.error || new Error("There was an error attempting to load ".concat(script.src)));
            script.removeEventListener("error", onScriptError, false);
          };
          script.addEventListener("error", onScriptError, false);
          return onScriptError;
        }
        function setDefaultOptions(options) {
          if (options === void 0) {
            options = {};
          }
          defaultOptions = options;
        }
        function getScript() {
          return document.querySelector("script[data-esri-loader]");
        }
        function isLoaded() {
          var globalRequire = window["require"];
          return globalRequire && globalRequire.on;
        }
        function loadScript(options) {
          if (options === void 0) {
            options = {};
          }
          var opts = {};
          [defaultOptions, options].forEach(function(obj) {
            for (var prop in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                opts[prop] = obj[prop];
              }
            }
          });
          var version = opts.version;
          var url = opts.url || getCdnUrl(version);
          return new utils.Promise(function(resolve, reject) {
            var script = getScript();
            if (script) {
              var src = script.getAttribute("src");
              if (src !== url) {
                reject(new Error("The ArcGIS API for JavaScript is already loaded (".concat(src, ").")));
              } else {
                if (isLoaded()) {
                  resolve(script);
                } else {
                  handleScriptLoad(script, resolve, reject);
                }
              }
            } else {
              if (isLoaded()) {
                reject(new Error("The ArcGIS API for JavaScript is already loaded."));
              } else {
                var css = opts.css;
                if (css) {
                  var useVersion = css === true;
                  loadCss(useVersion ? version : css, opts.insertCssBefore);
                }
                script = createScript(url);
                handleScriptLoad(script, function() {
                  script.setAttribute("data-esri-loader", "loaded");
                  resolve(script);
                }, reject);
                document.body.appendChild(script);
              }
            }
          });
        }
        function requireModules(modules) {
          return new utils.Promise(function(resolve, reject) {
            var errorHandler = window["require"].on("error", reject);
            window["require"](modules, function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              errorHandler.remove();
              resolve(args);
            });
          });
        }
        function loadModules(modules, loadScriptOptions) {
          if (loadScriptOptions === void 0) {
            loadScriptOptions = {};
          }
          if (!isLoaded()) {
            var script = getScript();
            var src = script && script.getAttribute("src");
            if (!loadScriptOptions.url && src) {
              loadScriptOptions.url = src;
            }
            return loadScript(loadScriptOptions).then(function() {
              return requireModules(modules);
            });
          } else {
            return requireModules(modules);
          }
        }
        exports2.utils = utils;
        exports2.loadModules = loadModules;
        exports2.getScript = getScript;
        exports2.isLoaded = isLoaded;
        exports2.loadScript = loadScript;
        exports2.setDefaultOptions = setDefaultOptions;
        exports2.loadCss = loadCss;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    loadArcGISModules: () => loadArcGISModules
  });

  // ../core/bundle/peer-dependency.ts
  var peer_dependency_exports = {};
  var import_core = __toESM(require_core(), 1);
  __reExport(peer_dependency_exports, __toESM(require_core(), 1));
  if (!import_core.Layer) {
    throw new Error("@deck.gl/core is not found");
  }

  // bundle.ts
  __reExport(bundle_exports, peer_dependency_exports);

  // dist/deck-props.js
  var properties = {
    layers: {},
    layerFilter: {},
    parameters: {},
    effects: {},
    pickingRadius: {},
    onBeforeRender: {},
    onAfterRender: {},
    onClick: {},
    onHover: {},
    onDragStart: {},
    onDrag: {},
    onDragEnd: {},
    onError: {},
    debug: {},
    drawPickingColors: {},
    getCursor: {},
    getTooltip: {}
  };
  function createDeckProps(Accessor) {
    const DeckProps = Accessor.createSubclass({
      properties,
      constructor() {
        this._callbacks = {};
        this.watch(Object.keys(properties), (newValue, oldValue, propName) => {
          this.emit("change", { [propName]: newValue });
        });
      },
      on(eventName, cb) {
        this._callbacks[eventName] = this._callbacks[eventName] || [];
        this._callbacks[eventName].push(cb);
      },
      emit(eventName, details) {
        const callbacks = this._callbacks[eventName];
        if (callbacks) {
          for (const cb of callbacks) {
            cb(details);
          }
        }
      },
      toJSON() {
        const result = {};
        for (const key of this.keys()) {
          if (this[key] !== void 0) {
            result[key] = this[key];
          }
        }
        return result;
      }
    });
    return DeckProps;
  }

  // dist/deck-layer.js
  function createDeckLayer(DeckProps, Layer2, DeckLayerView2D) {
    return Layer2.createSubclass({
      properties: {
        deck: {},
        blendMode: {},
        effect: {}
      },
      constructor() {
        this.deck = new DeckProps();
      },
      createLayerView(view) {
        if (view.type === "2d") {
          return new DeckLayerView2D({
            view,
            layer: this
          });
        }
        console.error("DeckLayer does not support SceneView at the moment. Use DeckRenderer instead.");
        return null;
      }
    });
  }

  // dist/commons.js
  var import_engine = __toESM(require_engine(), 1);
  var import_core2 = __toESM(require_core(), 1);
  async function createDeckInstance(gl) {
    return new Promise((resolve) => {
      const deckInstance = new import_core2.Deck({
        controller: false,
        gl,
        parameters: {
          depthCompare: "less-equal"
        },
        width: null,
        height: null,
        onDeviceInitialized: (device) => {
          resolve({ deckInstance, device });
        }
      });
    });
  }
  async function initializeResources(gl) {
    const { deckInstance, device } = await createDeckInstance(gl);
    const texture = device.createTexture({
      format: "rgba8unorm",
      width: 1,
      height: 1,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    });
    const model = new import_engine.Model(device, {
      vs: `#version 300 es
in vec2 pos;
out vec2 v_texcoord;
void main(void) {
    gl_Position = vec4(pos, 0.0, 1.0);
    v_texcoord = (pos + 1.0) / 2.0;
}
    `,
      fs: `#version 300 es
precision mediump float;
uniform sampler2D deckglTexture;
in vec2 v_texcoord;
out vec4 fragColor;

void main(void) {
    vec4 imageColor = texture(deckglTexture, v_texcoord);
    imageColor.rgb *= imageColor.a;
    fragColor = imageColor;
}
    `,
      bindings: {
        deckglTexture: texture
      },
      parameters: {
        depthWriteEnabled: true,
        depthCompare: "less-equal",
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one-minus-src-alpha",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one-minus-src-alpha",
        blendColorOperation: "add",
        blendAlphaOperation: "add"
      },
      geometry: new import_engine.Geometry({
        topology: "triangle-strip",
        attributes: {
          pos: { size: 2, value: new Int8Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1]) }
        }
      }),
      vertexCount: 6
    });
    const fbo = device.createFramebuffer({
      id: "deckfbo",
      width: 1,
      height: 1,
      colorAttachments: [texture],
      depthStencilAttachment: "depth16unorm"
    });
    deckInstance.setProps({
      _framebuffer: fbo,
      _customRender: (redrawReason) => {
        if (redrawReason === "arcgis") {
          deckInstance._drawLayers(redrawReason);
        } else {
          this.redraw();
        }
      }
    });
    return { deck: deckInstance, texture, fbo, model };
  }
  function render(resources, viewport) {
    const { model, deck, fbo } = resources;
    const device = model.device;
    const screenFbo = device.getParametersWebGL(36006);
    const { width, height, ...viewState } = viewport;
    const dpr = window.devicePixelRatio;
    const pixelWidth = Math.round(width * dpr);
    const pixelHeight = Math.round(height * dpr);
    fbo.resize({ width: pixelWidth, height: pixelHeight });
    deck.setProps({ viewState });
    deck.redraw("arcgis");
    const textureToScreenPass = device.beginRenderPass({
      framebuffer: screenFbo,
      parameters: { viewport: [0, 0, pixelWidth, pixelHeight] },
      clearColor: false,
      clearDepth: false
    });
    try {
      model.draw(textureToScreenPass);
    } finally {
      textureToScreenPass.end();
    }
  }
  function finalizeResources(resources) {
    resources.deck.finalize();
    resources.model.destroy();
    resources.fbo.destroy();
    resources.texture.destroy();
  }

  // dist/deck-layer-view-2d.js
  function createDeckLayerView2D(BaseLayerViewGL2D) {
    return BaseLayerViewGL2D.createSubclass({
      properties: {
        cancelInitialization: null,
        resources: null
      },
      async attach() {
        const gl = this.context;
        let cancelled = false;
        this.cancelInitialization = () => cancelled = true;
        const resources = await initializeResources.call(this, gl);
        if (cancelled) {
          finalizeResources(resources);
          return;
        }
        this.resources = resources;
        this.layer.deck.on("change", (props) => resources.deck.setProps(props));
        resources.deck.setProps(this.layer.deck.toJSON());
      },
      redraw() {
        this.requestRender();
      },
      detach() {
        this.cancelInitialization?.();
        if (this.resources) {
          finalizeResources(this.resources);
          this.resources = null;
        }
      },
      render(renderParameters) {
        if (!this.resources) {
          return;
        }
        const [width, height] = this.view.state.size;
        const state = renderParameters.state;
        render(this.resources, {
          width,
          height,
          latitude: this.view.center.latitude,
          longitude: this.view.center.longitude,
          zoom: this.view.featuresTilingScheme.scaleToLevel(state.scale),
          bearing: -state.rotation,
          pitch: 0
        });
      }
    });
  }

  // dist/deck-renderer.js
  function arcgisFOVToDeckAltitude(fov, aspectRatio) {
    const D = Math.sqrt(1 + aspectRatio ** 2);
    const halfFOV = fov / 2 / 180 * Math.PI;
    return D / 2 / Math.tan(halfFOV);
  }
  function createDeckRenderer(DeckProps, externalRenderers) {
    class DeckRenderer {
      constructor(view, props) {
        this.resources = null;
        this.cancelInitialization = null;
        this.view = view;
        this.deck = new DeckProps(props);
      }
      async setup(context) {
        const gl = context.gl;
        let cancelled = false;
        this.cancelInitialization = () => cancelled = true;
        const resources = await initializeResources.call(this, gl);
        if (cancelled) {
          finalizeResources(resources);
          return;
        }
        this.deck.on("change", (props) => resources.deck.setProps(props));
        resources.deck.setProps(this.deck.toJSON());
        this.resources = resources;
      }
      dispose() {
        this.cancelInitialization?.();
        if (this.resources) {
          finalizeResources(this.resources);
        }
      }
      redraw() {
        externalRenderers.requestRender(this.view);
      }
      render() {
        const [width, height] = this.view.size;
        render(this.resources, {
          width,
          height,
          latitude: this.view.center.latitude,
          longitude: this.view.center.longitude,
          altitude: arcgisFOVToDeckAltitude(this.view.camera.fov, width / height),
          zoom: this.view.zoom,
          bearing: this.view.camera.heading,
          pitch: this.view.camera.tilt
        });
      }
    }
    return DeckRenderer;
  }

  // dist/load-modules.js
  var import_esri_loader = __toESM(require_esri_loader(), 1);
  var arcGIS;
  async function loadArcGISModules(modules, loadScriptOptions) {
    const namespace = Array.isArray(modules) ? null : modules;
    await loadArcGISModule(namespace, loadScriptOptions);
    if (Array.isArray(modules)) {
      return (0, import_esri_loader.loadModules)(modules, loadScriptOptions).then((array) => {
        return { ...arcGIS, modules: array };
      });
    }
    return arcGIS;
  }
  async function loadArcGISModule(esri, loadScriptOptions) {
    if (arcGIS) {
      return arcGIS;
    }
    if (esri) {
      const Layer3 = esri.layers.Layer;
      const Accessor2 = esri.core.Accessor;
      const BaseLayerViewGL2D2 = esri.views["2d"].layers.BaseLayerViewGL2D;
      const externalRenderers2 = esri.views["3d"].externalRenderers;
      return initialize(Layer3, Accessor2, BaseLayerViewGL2D2, externalRenderers2);
    }
    const [Layer2, Accessor, BaseLayerViewGL2D, externalRenderers] = await (0, import_esri_loader.loadModules)([
      "esri/layers/Layer",
      "esri/core/Accessor",
      "esri/views/2d/layers/BaseLayerViewGL2D",
      "esri/views/3d/externalRenderers"
    ], loadScriptOptions);
    return initialize(Layer2, Accessor, BaseLayerViewGL2D, externalRenderers);
  }
  function initialize(Layer2, Accessor, BaseLayerViewGL2D, externalRenderers) {
    const DeckProps = createDeckProps(Accessor);
    const DeckLayerView2D = createDeckLayerView2D(BaseLayerViewGL2D);
    const DeckLayer = createDeckLayer(DeckProps, Layer2, DeckLayerView2D);
    const DeckRenderer = createDeckRenderer(DeckProps, externalRenderers);
    arcGIS = { DeckLayer, DeckRenderer };
    return arcGIS;
  }
  return __toCommonJS(bundle_exports);
})();
      return __exports__;
      });
