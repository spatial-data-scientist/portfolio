(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";var __exports__=(()=>{var It=Object.create;var Q=Object.defineProperty;var kt=Object.getOwnPropertyDescriptor;var St=Object.getOwnPropertyNames;var Rt=Object.getPrototypeOf,Nt=Object.prototype.hasOwnProperty;var Fe=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),Oe=(r,e)=>{for(var t in e)Q(r,t,{get:e[t],enumerable:!0})},X=(r,e,t,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of St(e))!Nt.call(r,i)&&i!==t&&Q(r,i,{get:()=>e[i],enumerable:!(o=kt(e,i))||o.enumerable});return r},P=(r,e,t)=>(X(r,e,"default"),t&&X(t,e,"default")),_=(r,e,t)=>(t=r!=null?It(Rt(r)):{},X(e||!r||!r.__esModule?Q(t,"default",{value:r,enumerable:!0}):t,r)),wt=r=>X(Q({},"__esModule",{value:!0}),r);var d=Fe((Po,Le)=>{Le.exports=globalThis.deck});var ze=Fe((Ao,je)=>{je.exports=globalThis.luma});var Z={};Oe(Z,{BrushingExtension:()=>F,ClipExtension:()=>D,CollisionFilterExtension:()=>z,DataFilterExtension:()=>O,FillStyleExtension:()=>B,Fp64Extension:()=>S,MaskExtension:()=>q,PathStyleExtension:()=>N,_TerrainExtension:()=>K,project64:()=>se});var v={},Ce=_(d(),1);P(v,_(d(),1));if(!Ce.Layer)throw new Error("@deck.gl/core is not found");P(Z,v);var Se=_(d(),1);var Ie=_(d(),1);var Bt=`
uniform bool brushing_enabled;
uniform int brushing_target;
uniform vec2 brushing_mousePos;
uniform float brushing_radius;
in vec2 brushingTargets;
out float brushing_isVisible;
bool brushing_isPointInRange(vec2 position) {
if (!brushing_enabled) {
return true;
}
vec2 source_commonspace = project_position(position);
vec2 target_commonspace = project_position(brushing_mousePos);
float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);
return distance <= brushing_radius;
}
bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {
return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);
}
void brushing_setVisible(bool visible) {
brushing_isVisible = float(visible);
}
`,Dt=`
uniform bool brushing_enabled;
in float brushing_isVisible;
`,Vt={source:0,target:1,custom:2,source_target:3},jt={"vs:DECKGL_FILTER_GL_POSITION":`
vec2 brushingTarget;
vec2 brushingSource;
if (brushing_target == 3) {
brushingTarget = geometry.worldPositionAlt.xy;
brushingSource = geometry.worldPosition.xy;
} else if (brushing_target == 0) {
brushingTarget = geometry.worldPosition.xy;
} else if (brushing_target == 1) {
brushingTarget = geometry.worldPositionAlt.xy;
} else {
brushingTarget = brushingTargets;
}
bool visible;
if (brushing_target == 3) {
visible = brushing_arePointsInRange(brushingSource, brushingTarget);
} else {
visible = brushing_isPointInRange(brushingTarget);
}
brushing_setVisible(visible);
`,"fs:DECKGL_FILTER_COLOR":`
    if (brushing_enabled && brushing_isVisible < 0.5) {
      discard;
    }
  `},ke={name:"brushing",dependencies:[Ie.project],vs:Bt,fs:Dt,inject:jt,getUniforms:r=>{if(!r||!("viewport"in r))return{};let{brushingEnabled:e=!0,brushingRadius:t=1e4,brushingTarget:o="source",mousePosition:i,viewport:s}=r;return{brushing_enabled:Boolean(e&&i&&s.containsPixel(i)),brushing_radius:t,brushing_target:Vt[o]||0,brushing_mousePos:i?s.unproject([i.x-s.x,i.y-s.y]):[0,0]}}};var zt={getBrushingTarget:{type:"accessor",value:[0,0]},brushingTarget:"source",brushingEnabled:!0,brushingRadius:1e4},J=class extends Se.LayerExtension{getShaders(){return{modules:[ke]}}initializeState(e,t){let o=this.getAttributeManager();o&&o.add({brushingTargets:{size:2,stepMode:"dynamic",accessor:"getBrushingTarget"}});let i=()=>{this.getCurrentLayer()?.setNeedsRedraw()};this.state.onMouseMove=i,e.deck&&e.deck.eventManager.on({pointermove:i,pointerleave:i})}finalizeState(e,t){if(e.deck){let o=this.state.onMouseMove;e.deck.eventManager.off({pointermove:o,pointerleave:o})}}},F=J;(()=>{J.defaultProps=zt})(),(()=>{J.extensionName="BrushingExtension"})();var b=_(d(),1);var Re=`
uniform bool filter_useSoftMargin;
uniform bool filter_enabled;
uniform bool filter_transformSize;
uniform ivec4 filter_categoryBitMask;
#ifdef DATAFILTER_TYPE
uniform DATAFILTER_TYPE filter_min;
uniform DATAFILTER_TYPE filter_softMin;
uniform DATAFILTER_TYPE filter_softMax;
uniform DATAFILTER_TYPE filter_max;
in DATAFILTER_TYPE filterValues;
#ifdef DATAFILTER_DOUBLE
in DATAFILTER_TYPE filterValues64Low;
uniform DATAFILTER_TYPE filter_min64High;
uniform DATAFILTER_TYPE filter_max64High;
#endif
#endif
#ifdef DATACATEGORY_TYPE
in DATACATEGORY_TYPE filterCategoryValues;
#endif
out float dataFilter_value;
float dataFilter_reduceValue(float value) {
return value;
}
float dataFilter_reduceValue(vec2 value) {
return min(value.x, value.y);
}
float dataFilter_reduceValue(vec3 value) {
return min(min(value.x, value.y), value.z);
}
float dataFilter_reduceValue(vec4 value) {
return min(min(value.x, value.y), min(value.z, value.w));
}
#ifdef DATAFILTER_TYPE
void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {
if (filter_useSoftMargin) {
DATAFILTER_TYPE leftInRange = mix(
smoothstep(filter_min, filter_softMin, valueFromMin),
step(filter_min, valueFromMin),
step(filter_softMin, filter_min)
);
DATAFILTER_TYPE rightInRange = mix(
1.0 - smoothstep(filter_softMax, filter_max, valueFromMax),
step(valueFromMax, filter_max),
step(filter_max, filter_softMax)
);
dataFilter_value = dataFilter_reduceValue(leftInRange * rightInRange);
} else {
dataFilter_value = dataFilter_reduceValue(
step(filter_min, valueFromMin) * step(valueFromMax, filter_max)
);
}
}
#endif
#ifdef DATACATEGORY_TYPE
void dataFilter_setCategoryValue(DATACATEGORY_TYPE category) {
#if DATACATEGORY_CHANNELS == 1
int dataFilter_masks = filter_categoryBitMask[int(category / 32.0)];
#elif DATACATEGORY_CHANNELS == 2
ivec2 dataFilter_masks = ivec2(
filter_categoryBitMask[int(category.x / 32.0)],
filter_categoryBitMask[int(category.y / 32.0) + 2]
);
#elif DATACATEGORY_CHANNELS == 3
ivec3 dataFilter_masks = filter_categoryBitMask.xyz;
#else
ivec4 dataFilter_masks = filter_categoryBitMask;
#endif
DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) / pow(DATACATEGORY_TYPE(2.0), mod(category, 32.0));
dataFilter_bits = mod(floor(dataFilter_bits), 2.0);
#if DATACATEGORY_CHANNELS == 1
if(dataFilter_bits == 0.0) dataFilter_value = 0.0;
#else
if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0.0)))) dataFilter_value = 0.0;
#endif
}
#endif
`,Ne=`
uniform bool filter_transformColor;
in float dataFilter_value;
`;function we(r){if(!r||!("extensions"in r))return{};let{filterRange:e=[-1,1],filterEnabled:t=!0,filterTransformSize:o=!0,filterTransformColor:i=!0}=r,s=r.filterSoftRange||e;return{...Number.isFinite(e[0])?{filter_min:e[0],filter_softMin:s[0],filter_softMax:s[1],filter_max:e[1]}:{filter_min:e.map(n=>n[0]),filter_softMin:s.map(n=>n[0]),filter_softMax:s.map(n=>n[1]),filter_max:e.map(n=>n[1])},filter_enabled:t,filter_useSoftMargin:Boolean(r.filterSoftRange),filter_transformSize:t&&o,filter_transformColor:t&&i}}function Gt(r){if(!r||!("extensions"in r))return{};let e=we(r);if(Number.isFinite(e.filter_min)){let t=Math.fround(e.filter_min);e.filter_min-=t,e.filter_softMin-=t,e.filter_min64High=t;let o=Math.fround(e.filter_max);e.filter_max-=o,e.filter_softMax-=o,e.filter_max64High=o}else{let t=e.filter_min.map(Math.fround);e.filter_min=e.filter_min.map((i,s)=>i-t[s]),e.filter_softMin=e.filter_softMin.map((i,s)=>i-t[s]),e.filter_min64High=t;let o=e.filter_max.map(Math.fround);e.filter_max=e.filter_max.map((i,s)=>i-o[s]),e.filter_softMax=e.filter_softMax.map((i,s)=>i-o[s]),e.filter_max64High=o}return e}var Be={"vs:#main-start":`
dataFilter_value = 1.0;
if (filter_enabled) {
#ifdef DATAFILTER_TYPE
#ifdef DATAFILTER_DOUBLE
dataFilter_setValue(
filterValues - filter_min64High + filterValues64Low,
filterValues - filter_max64High + filterValues64Low
);
#else
dataFilter_setValue(filterValues, filterValues);
#endif
#endif
#ifdef DATACATEGORY_TYPE
dataFilter_setCategoryValue(filterCategoryValues);
#endif
}
`,"vs:#main-end":`
if (dataFilter_value == 0.0) {
gl_Position = vec4(0.);
}
`,"vs:DECKGL_FILTER_SIZE":`
if (filter_transformSize) {
size = size * dataFilter_value;
}
`,"fs:DECKGL_FILTER_COLOR":`
if (dataFilter_value == 0.0) discard;
if (filter_transformColor) {
color.a *= dataFilter_value;
}
`},De={name:"data-filter",vs:Re,fs:Ne,inject:Be,getUniforms:we},Ve={name:"data-filter-fp64",vs:Re,fs:Ne,inject:Be,getUniforms:Gt};var Ge=_(ze(),1);var Ut=`#version 300 es
#define SHADER_NAME data-filter-vertex-shader

#ifdef FLOAT_TARGET
  in float filterIndices;
  in float filterPrevIndices;
#else
  in vec2 filterIndices;
  in vec2 filterPrevIndices;
#endif

out vec4 vColor;
const float component = 1.0 / 255.0;

void main() {
  #ifdef FLOAT_TARGET
    dataFilter_value *= float(filterIndices != filterPrevIndices);
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
    vColor = vec4(0.0, 0.0, 0.0, 1.0);
  #else
    // Float texture is not supported: pack result into 4 channels x 256 px x 64px
    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);
    float col = filterIndices.x;
    float row = filterIndices.y * 4.0;
    float channel = floor(row);
    row = fract(row);
    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));
    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);
  #endif
  gl_PointSize = 1.0;
}
`,qt=`#version 300 es
#define SHADER_NAME data-filter-fragment-shader
precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main() {
  if (dataFilter_value < 0.5) {
    discard;
  }
  fragColor = vColor;
}
`,Ht=["float32-renderable-webgl","texture-blend-float-webgl"];function Ue(r){return Ht.every(e=>r.features.has(e))}function qe(r,e){return e?r.createFramebuffer({width:1,height:1,colorAttachments:[r.createTexture({format:"rgba32float",type:5126,mipmaps:!1})]}):r.createFramebuffer({width:256,height:64,colorAttachments:[r.createTexture({format:"rgba8unorm",type:5126,mipmaps:!1})]})}function He(r,e,t){return e.defines.NON_INSTANCED_MODEL=1,t&&(e.defines.FLOAT_TARGET=1),new Ge.Model(r,{id:"data-filter-aggregation-model",vertexCount:1,isInstanced:!1,drawMode:0,vs:Ut,fs:qt,...e})}var Ye={blend:!0,blendFunc:[1,1,1,1],blendEquation:[32774,32774],depthTest:!1};var Wt={getFilterValue:{type:"accessor",value:0},getFilterCategory:{type:"accessor",value:0},onFilteredItemsChange:{type:"function",value:null,optional:!0},filterEnabled:!0,filterRange:[-1,1],filterSoftRange:null,filterCategories:[0],filterTransformSize:!0,filterTransformColor:!0},Kt={categorySize:0,filterSize:1,fp64:!1,countItems:!1},We={1:"float",2:"vec2",3:"vec3",4:"vec4"},ee=class extends b.LayerExtension{constructor(e={}){super({...Kt,...e})}getShaders(e){let{categorySize:t,filterSize:o,fp64:i}=e.opts,s={};return t&&(s.DATACATEGORY_TYPE=We[t],s.DATACATEGORY_CHANNELS=t),o&&(s.DATAFILTER_TYPE=We[o],s.DATAFILTER_DOUBLE=Boolean(i)),{modules:[i?Ve:De],defines:s}}initializeState(e,t){let o=this.getAttributeManager(),{categorySize:i,filterSize:s,fp64:n}=t.opts;o&&(s&&o.add({filterValues:{size:s,type:n?"float64":"float32",stepMode:"dynamic",accessor:"getFilterValue"}}),i&&o.add({filterCategoryValues:{size:i,stepMode:"dynamic",accessor:"getFilterCategory",transform:i===1?l=>t._getCategoryKey.call(this,l,0):l=>l.map((f,c)=>t._getCategoryKey.call(this,f,c))}}));let{device:a}=this.context;if(o&&t.opts.countItems){let l=Ue(a);o.add({filterIndices:{size:l?1:2,vertexOffset:1,type:"unorm8",accessor:(u,{index:p})=>{let m=u&&u.__source?u.__source.index:p;return l?(m+1)%255:[(m+1)%255,Math.floor(m/255)%255]},shaderAttributes:{filterPrevIndices:{vertexOffset:0},filterIndices:{vertexOffset:1}}}});let f=qe(a,l),c=He(a,t.getShaders.call(this,t),l);this.setState({filterFBO:f,filterModel:c})}}updateState({props:e,oldProps:t,changeFlags:o},i){let s=this.getAttributeManager(),{categorySize:n}=i.opts;if(this.state.filterModel){let a=s.attributes.filterValues?.needsUpdate()||s.attributes.filterCategoryValues?.needsUpdate()||e.filterEnabled!==t.filterEnabled||e.filterRange!==t.filterRange||e.filterSoftRange!==t.filterSoftRange||e.filterCategories!==t.filterCategories;a&&this.setState({filterNeedsUpdate:a})}s?.attributes.filterCategoryValues&&((s.attributes.filterCategoryValues.needsUpdate()||!(0,b._deepEqual)(e.filterCategories,t.filterCategories,2))&&this.setState({categoryBitMask:null}),o.dataChanged&&(this.setState({categoryMap:Array(n).fill(0).map(()=>({}))}),s.attributes.filterCategoryValues.setNeedsUpdate("categoryMap")))}draw(e,t){let o=this.state.filterFBO,i=this.state.filterModel,s=this.state.filterNeedsUpdate,{onFilteredItemsChange:n}=this.props;if(this.state.categoryBitMask||t._updateCategoryBitMask.call(this,e,t),e.uniforms.filter_categoryBitMask=this.state.categoryBitMask,s&&n&&i){let{attributes:{filterValues:a,filterCategoryValues:l,filterIndices:f}}=this.getAttributeManager();i.setVertexCount(this.getNumInstances()),this.context.device.clearWebGL({framebuffer:o,color:[0,0,0,0]}),i.updateModuleSettings(e.moduleParameters),i.setAttributes({...a?.getValue(),...l?.getValue(),...f?.getValue()}),i.setUniforms(e.uniforms),i.device.withParametersWebGL({framebuffer:o,...Ye,viewport:[0,0,o.width,o.height]},()=>{i.draw(this.context.renderPass)});let c=i.device.readPixelsToArrayWebGL(o),u=0;for(let p=0;p<c.length;p++)u+=c[p];n({id:this.id,count:u}),this.state.filterNeedsUpdate=!1}}finalizeState(){let e=this.state.filterFBO,t=this.state.filterModel;e?.destroy(),t?.destroy()}_updateCategoryBitMask(e,t){let{categorySize:o}=t.opts;if(!o)return;let{filterCategories:i}=this.props,s=new Uint32Array([0,0,0,0]),n=o===1?[i]:i,a=o===1?128:o===2?64:32;for(let l=0;l<n.length;l++){let f=n[l];for(let c of f){let u=t._getCategoryKey.call(this,c,l);if(u<a){let p=l*(a/32)+Math.floor(u/32);s[p]+=Math.pow(2,u%32)}else b.log.warn(`Exceeded maximum number of categories (${a})`)()}}this.state.categoryBitMask=s}_getCategoryKey(e,t){let o=this.state.categoryMap[t];return e in o||(o[e]=Object.keys(o).length),o[e]}},O=ee;(()=>{ee.defaultProps=Wt})(),(()=>{ee.extensionName="DataFilterExtension"})();var k=_(d(),1);function te(r,e=[],t=0){let o=Math.fround(r),i=r-o;return e[t]=o,e[t+1]=i,e}function ge(r){return r-Math.fround(r)}function xe(r){let e=new Float32Array(32);for(let t=0;t<4;++t)for(let o=0;o<4;++o){let i=t*4+o;te(r[o*4+t],e,i*2)}return e}var Ke=`uniform float ONE;
vec2 split(float a) {
const float SPLIT = 4097.0;
float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float a_hi = t * ONE - (t - a);
float a_lo = a * ONE - a_hi;
#else
float a_hi = t - (t - a);
float a_lo = a - a_hi;
#endif
return vec2(a_hi, a_lo);
}
vec2 split2(vec2 a) {
vec2 b = split(a.x);
b.y += a.y;
return b;
}
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float sum = (a + b) * ONE;
float err = b - (sum - a) * ONE;
#else
float sum = a + b;
float err = b - (sum - a);
#endif
return vec2(sum, err);
}
vec2 twoSum(float a, float b) {
float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
float v = s - a;
float err = (a - (s - v)) + (b - v);
#endif
return vec2(s, err);
}
vec2 twoSub(float a, float b) {
float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
float v = s - a;
float err = (a - (s - v)) - (b + v);
#endif
return vec2(s, err);
}
vec2 twoSqr(float a) {
float prod = a * a;
vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
return vec2(prod, err);
}
vec2 twoProd(float a, float b) {
float prod = a * b;
vec2 a_fp64 = split(a);
vec2 b_fp64 = split(b);
float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
return vec2(prod, err);
}
vec2 sum_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSum(a.x, b.x);
t = twoSum(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 sub_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSub(a.x, b.x);
t = twoSub(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 mul_fp64(vec2 a, vec2 b) {
vec2 prod = twoProd(a.x, b.x);
prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
return prod;
}
vec2 div_fp64(vec2 a, vec2 b) {
float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
vec2 yn = a * xn;
#endif
float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
vec2 prod = twoProd(xn, diff);
return sum_fp64(yn, prod);
}
vec2 sqrt_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
float x = 1.0 / sqrt(a.x);
float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
vec2 yn_sqr = twoSqr(yn) * ONE;
#else
vec2 yn_sqr = twoSqr(yn);
#endif
float diff = sub_fp64(a, yn_sqr).x;
vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
return sum_fp64(split(yn), prod);
#else
return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`;var Ze=`const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);
const vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);
const vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);
const vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);
const vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);
const vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);
const vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);
const vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);
const vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);
const vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);
const vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);
const vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);
const vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);
const vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);
const vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);
const vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);
const vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);
const vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);
const vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);
const vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);
const vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);
const vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);
const vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);
const vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);
const vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);
const vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);
float nint(float d) {
if (d == floor(d)) return d;
return floor(d + 0.5);
}
vec2 nint_fp64(vec2 a) {
float hi = nint(a.x);
float lo;
vec2 tmp;
if (hi == a.x) {
lo = nint(a.y);
tmp = quickTwoSum(hi, lo);
} else {
lo = 0.0;
if (abs(hi - a.x) == 0.5 && a.y < 0.0) {
hi -= 1.0;
}
tmp = vec2(hi, lo);
}
return tmp;
}
vec2 exp_fp64(vec2 a) {
const int k_power = 4;
const float k = 16.0;
const float inv_k = 1.0 / k;
if (a.x <= -88.0) return vec2(0.0, 0.0);
if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);
if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);
if (a.x == 1.0 && a.y == 0.0) return E_FP64;
float m = floor(a.x / LOG2_FP64.x + 0.5);
vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;
vec2 s, t, p;
p = mul_fp64(r, r);
s = sum_fp64(r, p * 0.5);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);
s = sum_fp64(s, t);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);
s = sum_fp64(s, t);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);
s = sum_fp64(s, t);
for (int i = 0; i < k_power; i++) {
s = sum_fp64(s * 2.0, mul_fp64(s, s));
}
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
s = sum_fp64(s, vec2(ONE, 0.0));
#else
s = sum_fp64(s, vec2(1.0, 0.0));
#endif
return s * pow(2.0, m);
}
vec2 log_fp64(vec2 a)
{
if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
vec2 x = vec2(log(a.x), 0.0);
vec2 s;
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
s = vec2(ONE, 0.0);
#else
s = vec2(1.0, 0.0);
#endif
x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);
return x;
}
vec2 sin_taylor_fp64(vec2 a) {
vec2 r, s, t, x;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
x = -mul_fp64(a, a);
s = a;
r = a;
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);
s = sum_fp64(s, t);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);
s = sum_fp64(s, t);
return s;
}
vec2 cos_taylor_fp64(vec2 a) {
vec2 r, s, t, x;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(1.0, 0.0);
}
x = -mul_fp64(a, a);
r = x;
s = sum_fp64(vec2(1.0, 0.0), r * 0.5);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);
s = sum_fp64(s, t);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);
s = sum_fp64(s, t);
return s;
}
void sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {
if (a.x == 0.0 && a.y == 0.0) {
sin_t = vec2(0.0, 0.0);
cos_t = vec2(1.0, 0.0);
}
sin_t = sin_taylor_fp64(a);
cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));
}
vec2 sin_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
if (k == 0) {
if (j == 0) {
return sin_taylor_fp64(t);
} else if (j == 1) {
return cos_taylor_fp64(t);
} else if (j == -1) {
return -cos_taylor_fp64(t);
} else {
return -sin_taylor_fp64(t);
}
}
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
vec2 sin_t, cos_t;
sincos_taylor_fp64(t, sin_t, cos_t);
vec2 result = vec2(0.0, 0.0);
if (j == 0) {
if (k > 0) {
result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
}
} else if (j == 1) {
if (k > 0) {
result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
} else if (j == -1) {
if (k > 0) {
result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
} else {
result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
}
} else {
if (k > 0) {
result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
}
}
return result;
}
vec2 cos_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) {
return vec2(1.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
if (k == 0) {
if (j == 0) {
return cos_taylor_fp64(t);
} else if (j == 1) {
return -sin_taylor_fp64(t);
} else if (j == -1) {
return sin_taylor_fp64(t);
} else {
return -cos_taylor_fp64(t);
}
}
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
vec2 sin_t, cos_t;
sincos_taylor_fp64(t, sin_t, cos_t);
vec2 result = vec2(0.0, 0.0);
if (j == 0) {
if (k > 0) {
result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
} else if (j == 1) {
if (k > 0) {
result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
}
} else if (j == -1) {
if (k > 0) {
result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
}
} else {
if (k > 0) {
result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
} else {
result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
}
return result;
}
vec2 tan_fp64(vec2 a) {
vec2 sin_a;
vec2 cos_a;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
vec2 sin_t, cos_t;
vec2 s, c;
sincos_taylor_fp64(t, sin_t, cos_t);
if (k == 0) {
s = sin_t;
c = cos_t;
} else {
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
if (k > 0) {
s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
}
if (j == 0) {
sin_a = s;
cos_a = c;
} else if (j == 1) {
sin_a = c;
cos_a = -s;
} else if (j == -1) {
sin_a = -c;
cos_a = s;
} else {
sin_a = -s;
cos_a = -c;
}
return div_fp64(sin_a, cos_a);
}
vec2 radians_fp64(vec2 degree) {
return mul_fp64(degree, PI_180_FP64);
}
vec2 mix_fp64(vec2 a, vec2 b, float x) {
vec2 range = sub_fp64(b, a);
return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}
void vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = sum_fp64(a[0], b[0]);
out_val[1] = sum_fp64(a[1], b[1]);
}
void vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = sub_fp64(a[0], b[0]);
out_val[1] = sub_fp64(a[1], b[1]);
}
void vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = mul_fp64(a[0], b[0]);
out_val[1] = mul_fp64(a[1], b[1]);
}
void vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = div_fp64(a[0], b[0]);
out_val[1] = div_fp64(a[1], b[1]);
}
void vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {
vec2 range[2];
vec2_sub_fp64(y, x, range);
vec2 portion[2];
portion[0] = range[0] * a;
portion[1] = range[1] * a;
vec2_sum_fp64(x, portion, out_val);
}
vec2 vec2_length_fp64(vec2 x[2]) {
return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));
}
void vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {
vec2 length = vec2_length_fp64(x);
vec2 length_vec2[2];
length_vec2[0] = length;
length_vec2[1] = length;
vec2_div_fp64(x, length_vec2, out_val);
}
vec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {
vec2 diff[2];
vec2_sub_fp64(x, y, diff);
return vec2_length_fp64(diff);
}
vec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {
vec2 v[2];
v[0] = mul_fp64(a[0], b[0]);
v[1] = mul_fp64(a[1], b[1]);
return sum_fp64(v[0], v[1]);
}
void vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
for (int i = 0; i < 3; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
void vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
for (int i = 0; i < 3; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
vec2 vec3_length_fp64(vec2 x[3]) {
return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),
mul_fp64(x[2], x[2])));
}
vec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {
vec2 diff[3];
vec3_sub_fp64(x, y, diff);
return vec3_length_fp64(diff);
}
void vec4_fp64(vec4 a, out vec2 out_val[4]) {
out_val[0].x = a[0];
out_val[0].y = 0.0;
out_val[1].x = a[1];
out_val[1].y = 0.0;
out_val[2].x = a[2];
out_val[2].y = 0.0;
out_val[3].x = a[3];
out_val[3].y = 0.0;
}
void vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {
out_val[0] = mul_fp64(a[0], b);
out_val[1] = mul_fp64(a[1], b);
out_val[2] = mul_fp64(a[2], b);
out_val[3] = mul_fp64(a[3], b);
}
void vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {
for (int i = 0; i < 4; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
void vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {
vec2 v[4];
v[0] = mul_fp64(a[0], b[0]);
v[1] = mul_fp64(a[1], b[1]);
v[2] = mul_fp64(a[2], b[2]);
v[3] = mul_fp64(a[3], b[3]);
out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));
}
void mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {
vec2 tmp[4];
for (int i = 0; i < 4; i++)
{
for (int j = 0; j < 4; j++)
{
tmp[j] = b[j + i * 4];
}
vec4_dot_fp64(a, tmp, out_val[i]);
}
}
`;var Zt={ONE:1};function $t(){return Zt}var $e={name:"fp64-arithmetic",vs:Ke,getUniforms:$t,fp64ify:te,fp64LowPart:ge,fp64ifyMatrix4:xe},re={name:"fp64",vs:Ze,dependencies:[$e],fp64ify:te,fp64LowPart:ge,fp64ifyMatrix4:xe};var wo=1/Math.PI*180,Bo=1/180*Math.PI,Xt={EPSILON:1e-12,debug:!1,precision:4,printTypes:!1,printDegrees:!1,printRowMajor:!0,_cartographicRadians:!1};globalThis.mathgl=globalThis.mathgl||{config:{...Xt}};var L=globalThis.mathgl.config;function Pe(r){return Array.isArray(r)||ArrayBuffer.isView(r)&&!(r instanceof DataView)}function M(r,e,t){let o=L.EPSILON;t&&(L.EPSILON=t);try{if(r===e)return!0;if(Pe(r)&&Pe(e)){if(r.length!==e.length)return!1;for(let i=0;i<r.length;++i)if(!M(r[i],e[i]))return!1;return!0}return r&&r.equals?r.equals(e):e&&e.equals?e.equals(r):typeof r=="number"&&typeof e=="number"?Math.abs(r-e)<=L.EPSILON*Math.max(1,Math.abs(r),Math.abs(e)):!1}finally{L.EPSILON=o}}var C=typeof Float32Array<"u"?Float32Array:Array,ye=Math.random;function oe(r){return r>=0?Math.round(r):r%.5===0?Math.floor(r):Math.round(r)}var Vo=Math.PI/180;var I={};Oe(I,{add:()=>or,angle:()=>Ar,bezier:()=>gr,ceil:()=>ir,clone:()=>Jt,copy:()=>tr,create:()=>Xe,cross:()=>dr,dist:()=>Rr,distance:()=>rt,div:()=>Sr,divide:()=>tt,dot:()=>Me,equals:()=>Cr,exactEquals:()=>Lr,floor:()=>sr,forEach:()=>Dr,fromValues:()=>er,hermite:()=>vr,inverse:()=>pr,len:()=>wr,length:()=>Qe,lerp:()=>mr,max:()=>ar,min:()=>nr,mul:()=>kr,multiply:()=>et,negate:()=>ur,normalize:()=>_r,random:()=>xr,rotateX:()=>Mr,rotateY:()=>Er,rotateZ:()=>Tr,round:()=>lr,scale:()=>fr,scaleAndAdd:()=>cr,set:()=>rr,slerp:()=>hr,sqrDist:()=>Nr,sqrLen:()=>Br,squaredDistance:()=>ot,squaredLength:()=>it,str:()=>Or,sub:()=>Ir,subtract:()=>Je,transformMat3:()=>yr,transformMat4:()=>Pr,transformQuat:()=>br,zero:()=>Fr});function Xe(){let r=new C(3);return C!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r}function Jt(r){let e=new C(3);return e[0]=r[0],e[1]=r[1],e[2]=r[2],e}function Qe(r){let e=r[0],t=r[1],o=r[2];return Math.sqrt(e*e+t*t+o*o)}function er(r,e,t){let o=new C(3);return o[0]=r,o[1]=e,o[2]=t,o}function tr(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r}function rr(r,e,t,o){return r[0]=e,r[1]=t,r[2]=o,r}function or(r,e,t){return r[0]=e[0]+t[0],r[1]=e[1]+t[1],r[2]=e[2]+t[2],r}function Je(r,e,t){return r[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r}function et(r,e,t){return r[0]=e[0]*t[0],r[1]=e[1]*t[1],r[2]=e[2]*t[2],r}function tt(r,e,t){return r[0]=e[0]/t[0],r[1]=e[1]/t[1],r[2]=e[2]/t[2],r}function ir(r,e){return r[0]=Math.ceil(e[0]),r[1]=Math.ceil(e[1]),r[2]=Math.ceil(e[2]),r}function sr(r,e){return r[0]=Math.floor(e[0]),r[1]=Math.floor(e[1]),r[2]=Math.floor(e[2]),r}function nr(r,e,t){return r[0]=Math.min(e[0],t[0]),r[1]=Math.min(e[1],t[1]),r[2]=Math.min(e[2],t[2]),r}function ar(r,e,t){return r[0]=Math.max(e[0],t[0]),r[1]=Math.max(e[1],t[1]),r[2]=Math.max(e[2],t[2]),r}function lr(r,e){return r[0]=oe(e[0]),r[1]=oe(e[1]),r[2]=oe(e[2]),r}function fr(r,e,t){return r[0]=e[0]*t,r[1]=e[1]*t,r[2]=e[2]*t,r}function cr(r,e,t,o){return r[0]=e[0]+t[0]*o,r[1]=e[1]+t[1]*o,r[2]=e[2]+t[2]*o,r}function rt(r,e){let t=e[0]-r[0],o=e[1]-r[1],i=e[2]-r[2];return Math.sqrt(t*t+o*o+i*i)}function ot(r,e){let t=e[0]-r[0],o=e[1]-r[1],i=e[2]-r[2];return t*t+o*o+i*i}function it(r){let e=r[0],t=r[1],o=r[2];return e*e+t*t+o*o}function ur(r,e){return r[0]=-e[0],r[1]=-e[1],r[2]=-e[2],r}function pr(r,e){return r[0]=1/e[0],r[1]=1/e[1],r[2]=1/e[2],r}function _r(r,e){let t=e[0],o=e[1],i=e[2],s=t*t+o*o+i*i;return s>0&&(s=1/Math.sqrt(s)),r[0]=e[0]*s,r[1]=e[1]*s,r[2]=e[2]*s,r}function Me(r,e){return r[0]*e[0]+r[1]*e[1]+r[2]*e[2]}function dr(r,e,t){let o=e[0],i=e[1],s=e[2],n=t[0],a=t[1],l=t[2];return r[0]=i*l-s*a,r[1]=s*n-o*l,r[2]=o*a-i*n,r}function mr(r,e,t,o){let i=e[0],s=e[1],n=e[2];return r[0]=i+o*(t[0]-i),r[1]=s+o*(t[1]-s),r[2]=n+o*(t[2]-n),r}function hr(r,e,t,o){let i=Math.acos(Math.min(Math.max(Me(e,t),-1),1)),s=Math.sin(i),n=Math.sin((1-o)*i)/s,a=Math.sin(o*i)/s;return r[0]=n*e[0]+a*t[0],r[1]=n*e[1]+a*t[1],r[2]=n*e[2]+a*t[2],r}function vr(r,e,t,o,i,s){let n=s*s,a=n*(2*s-3)+1,l=n*(s-2)+s,f=n*(s-1),c=n*(3-2*s);return r[0]=e[0]*a+t[0]*l+o[0]*f+i[0]*c,r[1]=e[1]*a+t[1]*l+o[1]*f+i[1]*c,r[2]=e[2]*a+t[2]*l+o[2]*f+i[2]*c,r}function gr(r,e,t,o,i,s){let n=1-s,a=n*n,l=s*s,f=a*n,c=3*s*a,u=3*l*n,p=l*s;return r[0]=e[0]*f+t[0]*c+o[0]*u+i[0]*p,r[1]=e[1]*f+t[1]*c+o[1]*u+i[1]*p,r[2]=e[2]*f+t[2]*c+o[2]*u+i[2]*p,r}function xr(r,e){e=e===void 0?1:e;let t=ye()*2*Math.PI,o=ye()*2-1,i=Math.sqrt(1-o*o)*e;return r[0]=Math.cos(t)*i,r[1]=Math.sin(t)*i,r[2]=o*e,r}function Pr(r,e,t){let o=e[0],i=e[1],s=e[2],n=t[3]*o+t[7]*i+t[11]*s+t[15];return n=n||1,r[0]=(t[0]*o+t[4]*i+t[8]*s+t[12])/n,r[1]=(t[1]*o+t[5]*i+t[9]*s+t[13])/n,r[2]=(t[2]*o+t[6]*i+t[10]*s+t[14])/n,r}function yr(r,e,t){let o=e[0],i=e[1],s=e[2];return r[0]=o*t[0]+i*t[3]+s*t[6],r[1]=o*t[1]+i*t[4]+s*t[7],r[2]=o*t[2]+i*t[5]+s*t[8],r}function br(r,e,t){let o=t[0],i=t[1],s=t[2],n=t[3],a=e[0],l=e[1],f=e[2],c=i*f-s*l,u=s*a-o*f,p=o*l-i*a,m=i*p-s*u,x=s*c-o*p,$=o*u-i*c,h=n*2;return c*=h,u*=h,p*=h,m*=2,x*=2,$*=2,r[0]=a+c+m,r[1]=l+u+x,r[2]=f+p+$,r}function Mr(r,e,t,o){let i=[],s=[];return i[0]=e[0]-t[0],i[1]=e[1]-t[1],i[2]=e[2]-t[2],s[0]=i[0],s[1]=i[1]*Math.cos(o)-i[2]*Math.sin(o),s[2]=i[1]*Math.sin(o)+i[2]*Math.cos(o),r[0]=s[0]+t[0],r[1]=s[1]+t[1],r[2]=s[2]+t[2],r}function Er(r,e,t,o){let i=[],s=[];return i[0]=e[0]-t[0],i[1]=e[1]-t[1],i[2]=e[2]-t[2],s[0]=i[2]*Math.sin(o)+i[0]*Math.cos(o),s[1]=i[1],s[2]=i[2]*Math.cos(o)-i[0]*Math.sin(o),r[0]=s[0]+t[0],r[1]=s[1]+t[1],r[2]=s[2]+t[2],r}function Tr(r,e,t,o){let i=[],s=[];return i[0]=e[0]-t[0],i[1]=e[1]-t[1],i[2]=e[2]-t[2],s[0]=i[0]*Math.cos(o)-i[1]*Math.sin(o),s[1]=i[0]*Math.sin(o)+i[1]*Math.cos(o),s[2]=i[2],r[0]=s[0]+t[0],r[1]=s[1]+t[1],r[2]=s[2]+t[2],r}function Ar(r,e){let t=r[0],o=r[1],i=r[2],s=e[0],n=e[1],a=e[2],l=Math.sqrt((t*t+o*o+i*i)*(s*s+n*n+a*a)),f=l&&Me(r,e)/l;return Math.acos(Math.min(Math.max(f,-1),1))}function Fr(r){return r[0]=0,r[1]=0,r[2]=0,r}function Or(r){return`vec3(${r[0]}, ${r[1]}, ${r[2]})`}function Lr(r,e){return r[0]===e[0]&&r[1]===e[1]&&r[2]===e[2]}function Cr(r,e){let t=r[0],o=r[1],i=r[2],s=e[0],n=e[1],a=e[2];return Math.abs(t-s)<=1e-6*Math.max(1,Math.abs(t),Math.abs(s))&&Math.abs(o-n)<=1e-6*Math.max(1,Math.abs(o),Math.abs(n))&&Math.abs(i-a)<=1e-6*Math.max(1,Math.abs(i),Math.abs(a))}var Ir=Je,kr=et,Sr=tt,Rr=rt,Nr=ot,wr=Qe,Br=it,Dr=function(){let r=Xe();return function(e,t,o,i,s,n){let a,l;for(t||(t=3),o||(o=0),i?l=Math.min(i*t+o,e.length):l=e.length,a=o;a<l;a+=t)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],s(r,r,n),e[a]=r[0],e[a+1]=r[1],e[a+2]=r[2];return e}}();var ie=_(d(),1);var st=`const vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);
uniform vec2 project_uViewProjectionMatrixFP64[16];
void mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {
#if defined(NVIDIA_FP64_WORKAROUND)
out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);
#else
out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);
#endif
out_val[1] = sum_fp64(PI_FP64,
log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));
return;
}
void project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {
vec2 pos_fp64[2];
mercatorProject_fp64(position_fp64, pos_fp64);
out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);
out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);
return;
}
void project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {
vec4 position64xy = vec4(
position.x, position64xyLow.x,
position.y, position64xyLow.y);
project_position_fp64(position64xy, out_val);
}
vec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {
vec2 vertex_pos_clipspace[4];
mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,
vertex_pos_clipspace);
return vec4(
vertex_pos_clipspace[0].x,
vertex_pos_clipspace[1].x,
vertex_pos_clipspace[2].x,
vertex_pos_clipspace[3].x
);
}
vec4 project_position_to_clipspace(
vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition
) {
vec2 offset64[4];
vec4_fp64(vec4(offset, 0.0), offset64);
float z = project_size(position.z);
vec2 projectedPosition64xy[2];
project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);
vec2 commonPosition64[4];
commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);
commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);
commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));
commonPosition64[3] = vec2(1.0, 0.0);
commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);
return project_common_position_to_clipspace_fp64(commonPosition64);
}
vec4 project_position_to_clipspace(
vec3 position, vec3 position64xyLow, vec3 offset
) {
vec4 commonPosition;
return project_position_to_clipspace(
position, position64xyLow, offset, commonPosition
);
}
`;var{fp64ify:Vr,fp64ifyMatrix4:jr}=re,se={name:"project64",dependencies:[ie.project,re],vs:st,getUniforms:Gr},zr=(0,ie._memoize)(Ur);function Gr(r){if(r&&"viewport"in r){let{viewProjectionMatrix:e,scale:t}=r.viewport;return zr({viewProjectionMatrix:e,scale:t})}return{}}function Ur({viewProjectionMatrix:r,scale:e}){let t=jr(r),o=Vr(e);return{project_uViewProjectionMatrixFP64:t,project64_uViewProjectionMatrix:t,project64_uScale:o}}var Ee=class extends k.LayerExtension{getShaders(){let{coordinateSystem:e}=this.props;if(e!==k.COORDINATE_SYSTEM.LNGLAT&&e!==k.COORDINATE_SYSTEM.DEFAULT)throw new Error("fp64: coordinateSystem must be LNGLAT");return{modules:[se]}}},S=Ee;(()=>{Ee.extensionName="Fp64Extension"})();var R=_(d(),1);var nt={inject:{"vs:#decl":`
in vec2 instanceDashArrays;
in float instanceDashOffsets;
out vec2 vDashArray;
out float vDashOffset;
`,"vs:#main-end":`
vDashArray = instanceDashArrays;
vDashOffset = instanceDashOffsets / width.x;
`,"fs:#decl":`
uniform float dashAlignMode;
uniform float capType;
uniform bool dashGapPickable;
in vec2 vDashArray;
in float vDashOffset;
`,"fs:#main-start":`
float solidLength = vDashArray.x;
float gapLength = vDashArray.y;
float unitLength = solidLength + gapLength;
float offset;
if (unitLength > 0.0) {
if (dashAlignMode == 0.0) {
offset = vDashOffset;
} else {
unitLength = vPathLength / round(vPathLength / unitLength);
offset = solidLength / 2.0;
}
float unitOffset = mod(vPathPosition.y + offset, unitLength);
if (gapLength > 0.0 && unitOffset > solidLength) {
if (capType <= 0.5) {
if (!(dashGapPickable && bool(picking.isActive))) {
discard;
}
} else {
float distToEnd = length(vec2(
min(unitOffset - solidLength, unitLength - unitOffset),
vPathPosition.x
));
if (distToEnd > 1.0) {
if (!(dashGapPickable && bool(picking.isActive))) {
discard;
}
}
}
}
}
`}},at={inject:{"vs:#decl":`
in float instanceOffsets;
`,"vs:DECKGL_FILTER_SIZE":`
float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
size *= offsetWidth;
`,"vs:#main-end":`
float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
float offsetDir = sign(instanceOffsets);
vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;
vPathPosition.y *= offsetWidth;
vPathLength *= offsetWidth;
`,"fs:#main-start":`
float isInside;
isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);
if (isInside == 0.0) {
discard;
}
`}};var qr={getDashArray:{type:"accessor",value:[0,0]},getOffset:{type:"accessor",value:0},dashJustified:!1,dashGapPickable:!1},ne=class extends R.LayerExtension{constructor({dash:e=!1,offset:t=!1,highPrecisionDash:o=!1}={}){super({dash:e||o,offset:t,highPrecisionDash:o})}isEnabled(e){return"pathTesselator"in e.state}getShaders(e){if(!e.isEnabled(this))return null;let t={};return e.opts.dash&&(t=(0,R._mergeShaders)(t,nt)),e.opts.offset&&(t=(0,R._mergeShaders)(t,at)),t}initializeState(e,t){let o=this.getAttributeManager();!o||!t.isEnabled(this)||(t.opts.dash&&o.addInstanced({instanceDashArrays:{size:2,accessor:"getDashArray"},instanceDashOffsets:t.opts.highPrecisionDash?{size:1,accessor:"getPath",transform:t.getDashOffsets.bind(this)}:{size:1,update:i=>{i.constant=!0,i.value=[0]}}}),t.opts.offset&&o.addInstanced({instanceOffsets:{size:1,accessor:"getOffset"}}))}updateState(e,t){if(!t.isEnabled(this))return;let o={};t.opts.dash&&(o.dashAlignMode=this.props.dashJustified?1:0,o.dashGapPickable=Boolean(this.props.dashGapPickable)),this.state.model?.setUniforms(o)}getDashOffsets(e){let t=[0],o=this.props.positionFormat==="XY"?2:3,i=Array.isArray(e[0]),s=i?e.length:e.length/o,n,a;for(let l=0;l<s-1;l++)n=i?e[l]:e.slice(l*o,l*o+o),n=this.projectPosition(n),l>0&&(t[l]=t[l-1]+I.dist(a,n)),a=n;return t[s-1]=0,t}},N=ne;(()=>{ne.defaultProps=qr})(),(()=>{ne.extensionName="PathStyleExtension"})();var ft=_(d(),1);var w=_(d(),1);var Hr=`
in vec4 fillPatternFrames;
in float fillPatternScales;
in vec2 fillPatternOffsets;
uniform bool fill_patternEnabled;
uniform vec2 fill_patternTextureSize;
out vec2 fill_uv;
out vec4 fill_patternBounds;
out vec4 fill_patternPlacement;
`,Yr=`
uniform bool fill_patternEnabled;
uniform bool fill_patternMask;
uniform sampler2D fill_patternTexture;
uniform vec2 fill_uvCoordinateOrigin;
uniform vec2 fill_uvCoordinateOrigin64Low;
in vec4 fill_patternBounds;
in vec4 fill_patternPlacement;
in vec2 fill_uv;
const float FILL_UV_SCALE = 512.0 / 40000000.0;
`,Wr={"vs:DECKGL_FILTER_GL_POSITION":`
fill_uv = geometry.position.xy;
`,"vs:DECKGL_FILTER_COLOR":`
if (fill_patternEnabled) {
fill_patternBounds = fillPatternFrames / vec4(fill_patternTextureSize, fill_patternTextureSize);
fill_patternPlacement.xy = fillPatternOffsets;
fill_patternPlacement.zw = fillPatternScales * fillPatternFrames.zw;
}
`,"fs:DECKGL_FILTER_COLOR":`
if (fill_patternEnabled) {
vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;
vec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uvCoordinateOrigin64Low + fill_uv, scale) / scale;
patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);
vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;
vec4 patternColor = texture(fill_patternTexture, texCoords);
color.a *= patternColor.a;
if (!fill_patternMask) {
color.rgb = patternColor.rgb;
}
}
`};function Kr(r,e){if(!r)return{};if("fillPatternTexture"in r){let{fillPatternTexture:t}=r;return{fill_patternTexture:t,fill_patternTextureSize:[t.width,t.height]}}if("viewport"in r){let{fillPatternMask:t=!0,fillPatternEnabled:o=!0}=r,{project_uCommonOrigin:i}=e,s=[(0,w.fp64LowPart)(i[0]),(0,w.fp64LowPart)(i[1])];return{fill_uvCoordinateOrigin:i.slice(0,2),fill_uvCoordinateOrigin64Low:s,fill_patternMask:t,fill_patternEnabled:o}}return{}}var lt={name:"fill-pattern",vs:Hr,fs:Yr,inject:Wr,dependencies:[w.project],getUniforms:Kr};var Zr={fillPatternEnabled:!0,fillPatternAtlas:{type:"image",value:null,async:!0,parameters:{lodMaxClamp:0}},fillPatternMapping:{type:"object",value:{},async:!0},fillPatternMask:!0,getFillPattern:{type:"accessor",value:r=>r.pattern},getFillPatternScale:{type:"accessor",value:1},getFillPatternOffset:{type:"accessor",value:[0,0]}},ae=class extends ft.LayerExtension{constructor({pattern:e=!1}={}){super({pattern:e})}isEnabled(e){return e.getAttributeManager()!==null&&!("pathTesselator"in e.state)}getShaders(e){return e.isEnabled(this)?{modules:[e.opts.pattern&&lt].filter(Boolean)}:null}initializeState(e,t){if(!t.isEnabled(this))return;let o=this.getAttributeManager();t.opts.pattern&&o.add({fillPatternFrames:{size:4,stepMode:"dynamic",accessor:"getFillPattern",transform:t.getPatternFrame.bind(this)},fillPatternScales:{size:1,stepMode:"dynamic",accessor:"getFillPatternScale",defaultValue:1},fillPatternOffsets:{size:2,stepMode:"dynamic",accessor:"getFillPatternOffset"}}),this.setState({emptyTexture:this.context.device.createTexture({data:new Uint8Array(4),width:1,height:1})})}updateState({props:e,oldProps:t},o){o.isEnabled(this)&&e.fillPatternMapping&&e.fillPatternMapping!==t.fillPatternMapping&&this.getAttributeManager().invalidate("getFillPattern")}draw(e,t){if(!t.isEnabled(this))return;let{fillPatternAtlas:o}=this.props;this.setModuleParameters({fillPatternTexture:o||this.state.emptyTexture})}finalizeState(){this.state.emptyTexture?.delete()}getPatternFrame(e){let{fillPatternMapping:t}=this.getCurrentLayer().props,o=t&&t[e];return o?[o.x,o.y,o.width,o.height]:[0,0,0,0]}},B=ae;(()=>{ae.defaultProps=Zr})(),(()=>{ae.extensionName="FillStyleExtension"})();var ct=_(d(),1);var $r={clipBounds:[0,0,1,1],clipByInstance:void 0},ut=`
uniform vec4 clip_bounds;
bool clip_isInBounds(vec2 position) {
return position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];
}
`,Xr={name:"clip-vs",vs:ut},Qr={"vs:#decl":`
out float clip_isVisible;
`,"vs:DECKGL_FILTER_GL_POSITION":`
clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));
`,"fs:#decl":`
in float clip_isVisible;
`,"fs:DECKGL_FILTER_COLOR":`
if (clip_isVisible < 0.5) discard;
`},Jr={name:"clip-fs",fs:ut},eo={"vs:#decl":`
out vec2 clip_commonPosition;
`,"vs:DECKGL_FILTER_GL_POSITION":`
clip_commonPosition = geometry.position.xy;
`,"fs:#decl":`
in vec2 clip_commonPosition;
`,"fs:DECKGL_FILTER_COLOR":`
if (!clip_isInBounds(clip_commonPosition)) discard;
`},le=class extends ct.LayerExtension{getShaders(){let e="instancePositions"in this.getAttributeManager().attributes;return this.props.clipByInstance!==void 0&&(e=Boolean(this.props.clipByInstance)),this.state.clipByInstance=e,e?{modules:[Xr],inject:Qr}:{modules:[Jr],inject:eo}}draw({uniforms:e}){let{clipBounds:t}=this.props;if(this.state.clipByInstance)e.clip_bounds=t;else{let o=this.projectPosition([t[0],t[1],0]),i=this.projectPosition([t[2],t[3],0]);e.clip_bounds=[Math.min(o[0],i[0]),Math.min(o[1],i[1]),Math.max(o[0],i[0]),Math.max(o[1],i[1])]}}},D=le;(()=>{le.defaultProps=$r})(),(()=>{le.extensionName="ClipExtension"})();var ht=_(d(),1);var pt=_(d(),1);var to=`
in float collisionPriorities;
uniform sampler2D collision_texture;
uniform bool collision_sort;
uniform bool collision_enabled;
vec2 collision_getCoords(vec4 position) {
vec4 collision_clipspace = project_common_position_to_clipspace(position);
return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;
}
float collision_match(vec2 tex, vec3 pickingColor) {
vec4 collision_pickingColor = texture(collision_texture, tex);
float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));
float e = 0.001;
return step(delta, e);
}
float collision_isVisible(vec2 texCoords, vec3 pickingColor) {
if (!collision_enabled) {
return 1.0;
}
const int N = 2;
float accumulator = 0.0;
vec2 step = vec2(1.0 / project_uViewportSize);
const float floatN = float(N);
vec2 delta = -floatN * step;
for(int i = -N; i <= N; i++) {
delta.x = -step.x * floatN;
for(int j = -N; j <= N; j++) {
accumulator += collision_match(texCoords + delta, pickingColor);
delta.x += step.x;
}
delta.y += step.y;
}
float W = 2.0 * floatN + 1.0;
return pow(accumulator / (W * W), 2.2);
}
`,ro={"vs:#decl":`
float collision_fade = 1.0;
`,"vs:DECKGL_FILTER_GL_POSITION":`
if (collision_sort) {
float collisionPriority = collisionPriorities;
position.z = -0.001 * collisionPriority * position.w;
}
if (collision_enabled) {
vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));
vec2 collision_texCoords = collision_getCoords(collision_common_position);
collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);
if (collision_fade < 0.0001) {
position = vec4(0.0, 0.0, 2.0, 1.0);
}
}
`,"vs:DECKGL_FILTER_COLOR":`
color.a *= collision_fade;
`},oo=(r,e)=>{if(!r||!("dummyCollisionMap"in r))return{};let{collisionFBO:t,drawToCollisionMap:o,dummyCollisionMap:i}=r;return{collision_sort:Boolean(o),collision_texture:!o&&t?t.colorAttachments[0]:i}},_t={name:"collision",dependencies:[pt.project],vs:to,inject:ro,getUniforms:oo};var mt=_(d(),1);var dt=_(d(),1),V=class extends dt._LayersPass{renderCollisionMap(e,t){let i=[0,0,0,0],s=[1,1,e.width-2*1,e.height-2*1];this.render({...t,clearColor:i,scissorRect:s,target:e,pass:"collision"})}getLayerParameters(e,t,o){return{...e.props.parameters,blend:!1,depthRange:[0,1],depthTest:!0}}getModuleParameters(){return{drawToCollisionMap:!0,picking:{isActive:1,isAttribute:!1},lightSources:{}}}};var Te=2,j=class{constructor(){this.id="collision-filter-effect",this.props=null,this.useInPicking=!0,this.order=1,this.channels={},this.collisionFBOs={}}setup(e){this.context=e;let{device:t}=e;this.dummyCollisionMap=t.createTexture({width:1,height:1}),this.collisionFilterPass=new V(t,{id:"default-collision-filter"})}preRender({effects:e,layers:t,layerFilter:o,viewports:i,onViewportActive:s,views:n,isPicking:a,preRenderStats:l={}}){let{device:f}=this.context;if(a)return;let c=t.filter(({props:{visible:h,collisionEnabled:ve}})=>h&&ve);if(c.length===0){this.channels={};return}let u=e?.filter(h=>h.useInPicking&&l[h.id]),p=l["mask-effect"]?.didRender,m=this._groupByCollisionGroup(f,c),x=i[0],$=!this.lastViewport||!this.lastViewport.equals(x)||p;for(let h in m){let ve=this.collisionFBOs[h],Ot=m[h],[Lt,Ct]=f.canvasContext.getPixelSize();ve.resize({width:Lt/Te,height:Ct/Te}),this._render(Ot,{effects:u,layerFilter:o,onViewportActive:s,views:n,viewport:x,viewportChanged:$})}}_render(e,{effects:t,layerFilter:o,onViewportActive:i,views:s,viewport:n,viewportChanged:a}){let{collisionGroup:l}=e,f=this.channels[l];if(!f)return;let c=a||e===f||!(0,mt._deepEqual)(f.layers,e.layers,1)||e.layerBounds.some((u,p)=>!M(u,f.layerBounds[p]))||e.allLayersLoaded!==f.allLayersLoaded||e.layers.some(u=>u.props.transitions);if(this.channels[l]=e,c){this.lastViewport=n;let u=this.collisionFBOs[l];this.collisionFilterPass.renderCollisionMap(u,{pass:"collision-filter",isPicking:!0,layers:e.layers,effects:t,layerFilter:o,viewports:n?[n]:[],onViewportActive:i,views:s,moduleParameters:{dummyCollisionMap:this.dummyCollisionMap,devicePixelRatio:u.device.canvasContext.getDevicePixelRatio()/Te}})}}_groupByCollisionGroup(e,t){let o={};for(let i of t){let{collisionGroup:s}=i.props,n=o[s];n||(n={collisionGroup:s,layers:[],layerBounds:[],allLayersLoaded:!0},o[s]=n),n.layers.push(i),n.layerBounds.push(i.getBounds()),i.isLoaded||(n.allLayersLoaded=!1)}for(let i of Object.keys(o))this.collisionFBOs[i]||this.createFBO(e,i),this.channels[i]||(this.channels[i]=o[i]);for(let i of Object.keys(this.collisionFBOs))o[i]||this.destroyFBO(i);return o}getModuleParameters(e){let{collisionGroup:t}=e.props,{collisionFBOs:o,dummyCollisionMap:i}=this;return{collisionFBO:o[t],dummyCollisionMap:i}}cleanup(){this.dummyCollisionMap&&(this.dummyCollisionMap.delete(),this.dummyCollisionMap=void 0),this.channels={};for(let e of Object.keys(this.collisionFBOs))this.destroyFBO(e);this.collisionFBOs={},this.lastViewport=void 0}createFBO(e,t){let{width:o,height:i}=e.gl.canvas,s=e.createTexture({format:"rgba8unorm",width:o,height:i,sampler:{minFilter:"nearest",magFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}}),n=e.createTexture({format:"depth16unorm",width:o,height:i,mipmaps:!1,dataFormat:6402,type:5125});this.collisionFBOs[t]=e.createFramebuffer({id:`collision-${t}`,width:o,height:i,colorAttachments:[s],depthStencilAttachment:n})}destroyFBO(e){let t=this.collisionFBOs[e];t.colorAttachments[0]?.destroy(),t.depthStencilAttachment?.destroy(),t.destroy(),delete this.collisionFBOs[e]}};var io={getCollisionPriority:{type:"accessor",value:0},collisionEnabled:!0,collisionGroup:{type:"string",value:"default"},collisionTestProps:{}},fe=class extends ht.LayerExtension{getShaders(){return{modules:[_t]}}draw({uniforms:e,context:t,moduleParameters:o}){let{collisionEnabled:i}=this.props,{collisionFBO:s,drawToCollisionMap:n}=o,a=i&&Boolean(s);e.collision_enabled=a,n&&(this.props=this.clone(this.props.collisionTestProps).props)}initializeState(e,t){if(this.getAttributeManager()===null)return;this.context.deck?._addDefaultEffect(new j),this.getAttributeManager().add({collisionPriorities:{size:1,stepMode:"dynamic",accessor:"getCollisionPriority"}})}getNeedsPickingBuffer(){return this.props.collisionEnabled}},z=fe;(()=>{fe.defaultProps=io})(),(()=>{fe.extensionName="CollisionFilterExtension"})();var y=_(d(),1);var vt=_(d(),1);var so=`
uniform vec4 mask_bounds;
uniform bool mask_maskByInstance;
vec2 mask_getCoords(vec4 position) {
return (position.xy - mask_bounds.xy) / (mask_bounds.zw - mask_bounds.xy);
}
`,no=`
uniform sampler2D mask_texture;
uniform int mask_channel;
uniform bool mask_enabled;
uniform bool mask_inverted;
bool mask_isInBounds(vec2 texCoords) {
if (!mask_enabled) {
return true;
}
vec4 maskColor = texture(mask_texture, texCoords);
float maskValue = 1.0;
if (mask_channel == 0) {
maskValue = maskColor.r;
} else if (mask_channel == 1) {
maskValue = maskColor.g;
} else if (mask_channel == 2) {
maskValue = maskColor.b;
} else if (mask_channel == 3) {
maskValue = maskColor.a;
}
if (mask_inverted) {
return maskValue >= 0.5;
} else {
return maskValue < 0.5;
}
}
`,ao={"vs:#decl":`
out vec2 mask_texCoords;
`,"vs:#main-end":`
vec4 mask_common_position;
if (mask_maskByInstance) {
mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));
} else {
mask_common_position = geometry.position;
}
mask_texCoords = mask_getCoords(mask_common_position);
`,"fs:#decl":`
in vec2 mask_texCoords;
`,"fs:#main-start":`
if (mask_enabled) {
bool mask = mask_isInBounds(mask_texCoords);
fragColor = texture(mask_texture, mask_texCoords);
if (!mask) discard;
}
`},lo=r=>r&&"maskMap"in r?{mask_texture:r.maskMap}:{},gt={name:"mask",dependencies:[vt.project],vs:so,fs:no,inject:ao,getUniforms:lo};var Ae=_(d(),1);var xt=_(d(),1),fo={blendColorOperation:"subtract",blendColorSrcFactor:"zero",blendColorDstFactor:"one",blendAlphaOperation:"subtract",blendAlphaSrcFactor:"zero",blendAlphaDstFactor:"one"},G=class extends xt._LayersPass{constructor(e,t){super(e,t);let{mapSize:o=2048}=t;this.maskMap=e.createTexture({format:"rgba8unorm",width:o,height:o,sampler:{minFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}}),this.fbo=e.createFramebuffer({id:"maskmap",width:o,height:o,colorAttachments:[this.maskMap]})}render(e){let t=2**e.channel,o=[255,255,255,255];super.render({...e,clearColor:o,colorMask:t,target:this.fbo,pass:"mask"})}getLayerParameters(e,t,o){return{...e.props.parameters,blend:!0,depthTest:!1,...fo}}shouldDrawLayer(e){return e.props.operation.includes("mask")}delete(){this.fbo.delete(),this.maskMap.delete()}};var ce=_(d(),1);function E(r,e){let t=[1/0,1/0,-1/0,-1/0];for(let o of r){let i=o.getBounds();if(i){let s=o.projectPosition(i[0],{viewport:e,autoOffset:!1}),n=o.projectPosition(i[1],{viewport:e,autoOffset:!1});t[0]=Math.min(t[0],s[0]),t[1]=Math.min(t[1],s[1]),t[2]=Math.max(t[2],n[0]),t[3]=Math.max(t[3],n[1])}}return Number.isFinite(t[0])?t:null}var co=2048;function T(r){let{bounds:e,viewport:t,border:o=0}=r,{isGeospatial:i}=t;if(e[2]<=e[0]||e[3]<=e[1])return null;let s=t.unprojectPosition([(e[0]+e[2])/2,(e[1]+e[3])/2,0]),{width:n,height:a,zoom:l}=r;if(l===void 0){n=n-o*2,a=a-o*2;let f=Math.min(n/(e[2]-e[0]),a/(e[3]-e[1]));l=Math.min(Math.log2(f),20)}else if(!n||!a){let f=2**l;n=Math.round(Math.abs(e[2]-e[0])*f),a=Math.round(Math.abs(e[3]-e[1])*f);let c=co-o*2;if(n>c||a>c){let u=c/Math.max(n,a);n=Math.round(n*u),a=Math.round(a*u),l+=Math.log2(u)}}return i?new ce.WebMercatorViewport({id:t.id,x:o,y:o,width:n,height:a,longitude:s[0],latitude:s[1],zoom:l,orthographic:!0}):new ce.OrthographicViewport({id:t.id,x:o,y:o,width:n,height:a,target:s,zoom:l,flipY:!1})}function uo(r,e){let t;if(e&&e.length===2){let[s,n]=e,a=r.getBounds({z:s}),l=r.getBounds({z:n});t=[Math.min(a[0],l[0]),Math.min(a[1],l[1]),Math.max(a[2],l[2]),Math.max(a[3],l[3])]}else t=r.getBounds();let o=r.projectPosition(t.slice(0,2)),i=r.projectPosition(t.slice(2,4));return[o[0],o[1],i[0],i[1]]}function A(r,e,t){if(!r)return[0,0,1,1];let o=uo(e,t),i=po(o);return r[2]-r[0]<=i[2]-i[0]&&r[3]-r[1]<=i[3]-i[1]?r:[Math.max(r[0],i[0]),Math.max(r[1],i[1]),Math.min(r[2],i[2]),Math.min(r[3],i[3])]}function po(r){let e=r[2]-r[0],t=r[3]-r[1],o=(r[0]+r[2])/2,i=(r[1]+r[3])/2;return[o-e,i-t,o+e,i+t]}var U=class{constructor(){this.id="mask-effect",this.props=null,this.useInPicking=!0,this.order=0,this.channels=[],this.masks=null}setup({device:e}){this.dummyMaskMap=e.createTexture({width:1,height:1}),this.maskPass=new G(e,{id:"default-mask"}),this.maskMap=this.maskPass.maskMap}preRender({layers:e,layerFilter:t,viewports:o,onViewportActive:i,views:s,isPicking:n}){let a=!1;if(n)return{didRender:a};let l=e.filter(p=>p.props.visible&&p.props.operation.includes("mask"));if(l.length===0)return this.masks=null,this.channels.length=0,{didRender:a};this.masks={};let f=this._sortMaskChannels(l),c=o[0],u=!this.lastViewport||!this.lastViewport.equals(c);if(c.resolution!==void 0)return Ae.log.warn("MaskExtension is not supported in GlobeView")(),{didRender:a};for(let p in f){let m=this._renderChannel(f[p],{layerFilter:t,onViewportActive:i,views:s,viewport:c,viewportChanged:u});a||=m}return{didRender:a}}_renderChannel(e,{layerFilter:t,onViewportActive:o,views:i,viewport:s,viewportChanged:n}){let a=!1,l=this.channels[e.index];if(!l)return a;let f=e===l||e.layers.length!==l.layers.length||e.layers.some((c,u)=>c!==l.layers[u]||c.props.transitions)||e.layerBounds.some((c,u)=>c!==l.layerBounds[u]);if(e.bounds=l.bounds,e.maskBounds=l.maskBounds,this.channels[e.index]=e,f||n){this.lastViewport=s;let c=E(e.layers,s);if(e.bounds=c&&A(c,s),f||!M(e.bounds,l.bounds)){let{maskPass:u,maskMap:p}=this,m=c&&T({bounds:e.bounds,viewport:s,width:p.width,height:p.height,border:1});e.maskBounds=m?m.getBounds():[0,0,1,1],u.render({pass:"mask",channel:e.index,layers:e.layers,layerFilter:t,viewports:m?[m]:[],onViewportActive:o,views:i,moduleParameters:{devicePixelRatio:1}}),a=!0}}return this.masks[e.id]={index:e.index,bounds:e.maskBounds,coordinateOrigin:e.coordinateOrigin,coordinateSystem:e.coordinateSystem},a}_sortMaskChannels(e){let t={},o=0;for(let i of e){let{id:s}=i.root,n=t[s];if(!n){if(++o>4){Ae.log.warn("Too many mask layers. The max supported is 4")();continue}n={id:s,index:this.channels.findIndex(a=>a?.id===s),layers:[],layerBounds:[],coordinateOrigin:i.root.props.coordinateOrigin,coordinateSystem:i.root.props.coordinateSystem},t[s]=n}n.layers.push(i),n.layerBounds.push(i.getBounds())}for(let i=0;i<4;i++){let s=this.channels[i];(!s||!(s.id in t))&&(this.channels[i]=null)}for(let i in t){let s=t[i];s.index<0&&(s.index=this.channels.findIndex(n=>!n),this.channels[s.index]=s)}return t}getModuleParameters(){return{maskMap:this.masks?this.maskMap:this.dummyMaskMap,maskChannels:this.masks}}cleanup(){this.dummyMaskMap&&(this.dummyMaskMap.delete(),this.dummyMaskMap=void 0),this.maskPass&&(this.maskPass.delete(),this.maskPass=void 0,this.maskMap=void 0),this.lastViewport=void 0,this.masks=null,this.channels.length=0}};var _o={maskId:"",maskByInstance:void 0,maskInverted:!1},ue=class extends y.LayerExtension{initializeState(){this.context.deck?._addDefaultEffect(new U)}getShaders(){let e="instancePositions"in this.getAttributeManager().attributes;return this.props.maskByInstance!==void 0&&(e=Boolean(this.props.maskByInstance)),this.state.maskByInstance=e,{modules:[gt]}}draw({uniforms:e,context:t,moduleParameters:o}){e.mask_maskByInstance=this.state.maskByInstance;let{maskId:i,maskInverted:s}=this.props,{maskChannels:n}=o,{viewport:a}=t;if(n&&n[i]){let{index:l,bounds:f,coordinateOrigin:c}=n[i],{coordinateSystem:u}=n[i];e.mask_enabled=!0,e.mask_channel=l,e.mask_inverted=s,u===y.COORDINATE_SYSTEM.DEFAULT&&(u=a.isGeospatial?y.COORDINATE_SYSTEM.LNGLAT:y.COORDINATE_SYSTEM.CARTESIAN);let p={modelMatrix:null,fromCoordinateOrigin:c,fromCoordinateSystem:u},m=this.projectPosition([f[0],f[1],0],p),x=this.projectPosition([f[2],f[3],0],p);e.mask_bounds=[m[0],m[1],x[0],x[1]]}else i&&y.log.warn(`Could not find a mask layer with id: ${i}`)(),e.mask_enabled=!1}},q=ue;(()=>{ue.defaultProps=_o})(),(()=>{ue.extensionName="MaskExtension"})();var Ft=_(d(),1);var At=_(d(),1);var yt=_(d(),1);var g={NONE:0,WRITE_HEIGHT_MAP:1,USE_HEIGHT_MAP:2,USE_COVER:3,USE_COVER_ONLY:4,SKIP:5},Pt=Object.keys(g).map(r=>`const float TERRAIN_MODE_${r} = ${g[r]}.0;`).join(`
`),H={name:"terrain",dependencies:[yt.project],inject:{"vs:#decl":`
uniform float terrain_mode;
uniform sampler2D terrain_map;
uniform vec4 terrain_bounds;
out vec3 commonPos;
`+Pt,"vs:#main-start":`
if (terrain_mode == TERRAIN_MODE_SKIP) {
gl_Position = vec4(0.0);
return;
}
`,"vs:DECKGL_FILTER_GL_POSITION":`
commonPos = geometry.position.xyz;
if (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;
position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);
commonPos.z += project_uCommonOrigin.z;
}
if (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {
vec3 anchor = geometry.worldPosition;
anchor.z = 0.0;
vec3 anchorCommon = project_position(anchor);
vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;
if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {
float terrainZ = texture(terrain_map, texCoords).r;
geometry.position.z += terrainZ;
position = project_common_position_to_clipspace(geometry.position);
}
}
`,"fs:#decl":`
uniform float terrain_mode;
uniform sampler2D terrain_map;
uniform vec4 terrain_bounds;
in vec3 commonPos;
`+Pt,"fs:#main-start":`
if (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
fragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);
return;
}
`,"fs:DECKGL_FILTER_COLOR":`
if ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {
vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;
vec4 pixel = texture(terrain_map, texCoords);
if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {
color = pixel;
} else {
color = pixel + color * (1.0 - pixel.a);
}
return;
}
`},getUniforms:(r={},e)=>{if("dummyHeightMap"in r){let{drawToTerrainHeightMap:t,heightMap:o,heightMapBounds:i,dummyHeightMap:s,terrainCover:n,useTerrainHeightMap:a,terrainSkipRender:l}=r,{project_uCommonOrigin:f}=e,c=l?g.SKIP:g.NONE,u=s,p=null;if(t)c=g.WRITE_HEIGHT_MAP,p=i;else if(a&&o)c=g.USE_HEIGHT_MAP,u=o,p=i;else if(n){let m=r.picking?.isActive;u=(m?n.getPickingFramebuffer():n.getRenderFramebuffer())?.colorAttachments[0].texture,m&&(c=g.SKIP),u?(c=c===g.SKIP?g.USE_COVER_ONLY:g.USE_COVER,p=n.bounds):u=s}return{terrain_mode:c,terrain_map:u,terrain_bounds:p?[p[0]-f[0],p[1]-f[1],p[2]-p[0],p[3]-p[1]]:[0,0,0,0]}}return null}};function Y(r,e){return r.createFramebuffer({id:e.id,colorAttachments:[r.createTexture({id:e.id,...e.float&&{format:"rgba32float",type:5126},mipmaps:!1,sampler:e.interpolate===!1?{minFilter:"nearest",magFilter:"nearest"}:{minFilter:"linear",magFilter:"linear"}})]})}var pe=class{constructor(e){this.isDirty=!0,this.renderViewport=null,this.bounds=null,this.layers=[],this.targetBounds=null,this.targetBoundsCommon=null,this.targetLayer=e,this.tile=bt(e)}get id(){return this.targetLayer.id}get isActive(){return Boolean(this.targetLayer.getCurrentLayer())}shouldUpdate({targetLayer:e,viewport:t,layers:o,layerNeedsRedraw:i}){e&&(this.targetLayer=e);let s=t?this._updateViewport(t):!1,n=o?this._updateLayers(o):!1;if(i){for(let a of this.layers)if(i[a]){n=!0;break}}return n||s}_updateLayers(e){let t=!1;if(e=this.tile?mo(this.tile,e):e,e.length!==this.layers.length)t=!0;else for(let o=0;o<e.length;o++)if(e[o].id!==this.layers[o]){t=!0;break}return t&&(this.layers=e.map(o=>o.id)),t}_updateViewport(e){let t=this.targetLayer,o=!1;if(this.tile&&"boundingBox"in this.tile){if(!this.targetBounds){o=!0,this.targetBounds=this.tile.boundingBox;let s=e.projectPosition(this.targetBounds[0]),n=e.projectPosition(this.targetBounds[1]);this.targetBoundsCommon=[s[0],s[1],n[0],n[1]]}}else this.targetBounds!==t.getBounds()&&(o=!0,this.targetBounds=t.getBounds(),this.targetBoundsCommon=E([t],e));if(!this.targetBoundsCommon)return!1;let i=Math.ceil(e.zoom+.5);if(this.tile)this.bounds=this.targetBoundsCommon;else{let s=this.renderViewport?.zoom;o=o||i!==s;let n=A(this.targetBoundsCommon,e),a=this.bounds;o=o||!a||n.some((l,f)=>l!==a[f]),this.bounds=n}return o&&(this.renderViewport=T({bounds:this.bounds,zoom:i,viewport:e})),o}getRenderFramebuffer(){return!this.renderViewport||this.layers.length===0?null:(this.fbo||(this.fbo=Y(this.targetLayer.context.device,{id:this.id})),this.fbo)}getPickingFramebuffer(){return!this.renderViewport||this.layers.length===0&&!this.targetLayer.props.pickable?null:(this.pickingFbo||(this.pickingFbo=Y(this.targetLayer.context.device,{id:`${this.id}-picking`,interpolate:!1})),this.pickingFbo)}filterLayers(e){return e.filter(({id:t})=>this.layers.includes(t))}delete(){let{fbo:e,pickingFbo:t}=this;e&&(e.colorAttachments[0].destroy(),e.destroy()),t&&(t.colorAttachments[0].destroy(),t.destroy())}};function mo(r,e){return e.filter(t=>{let o=bt(t);return o?ho(r.boundingBox,o.boundingBox):!0})}function bt(r){for(;r;){let{tile:e}=r.props;if(e)return e;r=r.parent}return null}function ho(r,e){return r&&e?r[0][0]<e[1][0]&&e[0][0]<r[1][0]&&r[0][1]<e[1][1]&&e[0][1]<r[1][1]:!1}var Mt=_(d(),1),vo={blendColorOperation:"max",blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaOperation:"max",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one"},_e=class extends Mt._LayersPass{getRenderableLayers(e,t){let{layers:o}=t,i=[],s=this._getDrawLayerParams(e,t,!0);for(let n=0;n<o.length;n++){let a=o[n];!a.isComposite&&s[n].shouldDrawLayer&&i.push(a)}return i}renderHeightMap(e,t){let o=e.getRenderFramebuffer(),i=e.renderViewport;!o||!i||(o.resize(i),this.render({...t,target:o,pass:"terrain-height-map",layers:t.layers,viewports:[i],effects:[],clearColor:[0,0,0,0]}))}renderTerrainCover(e,t){let o=e.getRenderFramebuffer(),i=e.renderViewport;if(!o||!i)return;let s=e.filterLayers(t.layers);o.resize(i),this.render({...t,target:o,pass:`terrain-cover-${e.id}`,layers:s,effects:[],viewports:[i],clearColor:[0,0,0,0]})}getLayerParameters(e,t,o){return{...e.props.parameters,blend:!0,depthTest:!1,...e.props.operation.includes("terrain")&&vo}}};var Et=_(d(),1),de=class extends Et._PickLayersPass{constructor(){super(...arguments),this.drawParameters={}}getRenderableLayers(e,t){let{layers:o}=t,i=[];this.drawParameters={},this._resetColorEncoder(t.pickZ);let s=this._getDrawLayerParams(e,t);for(let n=0;n<o.length;n++){let a=o[n];!a.isComposite&&s[n].shouldDrawLayer&&(i.push(a),this.drawParameters[a.id]=s[n].layerParameters)}return i}renderTerrainCover(e,t){let o=e.getPickingFramebuffer(),i=e.renderViewport;if(!o||!i)return;let s=e.filterLayers(t.layers),n=e.targetLayer;n.props.pickable&&s.unshift(n),o.resize(i),this.render({...t,pickingFBO:o,pass:`terrain-cover-picking-${e.id}`,layers:s,effects:[],viewports:[i],cullRect:void 0,deviceRect:i,pickZ:!1})}getLayerParameters(e,t,o){let i;return this.drawParameters[e.id]?i=this.drawParameters[e.id]:(i=super.getLayerParameters(e,t,o),i.blend=!0),{...i,depthTest:!1}}};var Tt=2048,W=class{static isSupported(e){return e.isTextureFormatRenderable("rgba32float")}constructor(e){this.renderViewport=null,this.bounds=null,this.layers=[],this.layersBounds=[],this.layersBoundsCommon=null,this.lastViewport=null,this.device=e}getRenderFramebuffer(){return this.renderViewport?(this.fbo||(this.fbo=Y(this.device,{id:"height-map",float:!0})),this.fbo):null}shouldUpdate({layers:e,viewport:t}){let o=e.length!==this.layers.length||e.some((s,n)=>s!==this.layers[n]||s.props.transitions||s.getBounds()!==this.layersBounds[n]);o&&(this.layers=e,this.layersBounds=e.map(s=>s.getBounds()),this.layersBoundsCommon=E(e,t));let i=!this.lastViewport||!t.equals(this.lastViewport);if(!this.layersBoundsCommon)this.renderViewport=null;else if(o||i){let s=A(this.layersBoundsCommon,t);if(s[2]<=s[0]||s[3]<=s[1])return this.renderViewport=null,!1;this.bounds=s,this.lastViewport=t;let n=t.scale,a=(s[2]-s[0])*n,l=(s[3]-s[1])*n;return this.renderViewport=a>0||l>0?T({bounds:[t.center[0]-1,t.center[1]-1,t.center[0]+1,t.center[1]+1],zoom:t.zoom,width:Math.min(a,Tt),height:Math.min(l,Tt),viewport:t}):null,!0}return!1}delete(){this.fbo&&(this.fbo.colorAttachments[0].delete(),this.fbo.delete())}};var me=class{constructor(){this.id="terrain-effect",this.props=null,this.useInPicking=!0,this.isPicking=!1,this.isDrapingEnabled=!1,this.terrainCovers=new Map}setup({device:e,deck:t}){this.dummyHeightMap=e.createTexture({width:1,height:1,data:new Uint8Array([0,0,0,0])}),this.terrainPass=new _e(e,{id:"terrain"}),this.terrainPickingPass=new de(e,{id:"terrain-picking"}),W.isSupported(e)?this.heightMap=new W(e):At.log.warn("Terrain offset mode is not supported by this browser")(),t._addDefaultShaderModule(H)}preRender(e){if(e.pickZ){this.isDrapingEnabled=!1;return}let{viewports:t}=e,o=e.pass.startsWith("picking");this.isPicking=o,this.isDrapingEnabled=!0;let i=t[0],s=(o?this.terrainPickingPass:this.terrainPass).getRenderableLayers(i,e),n=s.filter(l=>l.props.operation.includes("terrain"));if(n.length===0)return;o||s.filter(f=>f.state.terrainDrawMode==="offset").length>0&&this._updateHeightMap(n,i,e);let a=s.filter(l=>l.state.terrainDrawMode==="drape");this._updateTerrainCovers(n,a,i,e)}getModuleParameters(e){let{terrainDrawMode:t}=e.state;return{heightMap:this.heightMap?.getRenderFramebuffer()?.colorAttachments[0].texture||null,heightMapBounds:this.heightMap?.bounds,dummyHeightMap:this.dummyHeightMap,terrainCover:this.isDrapingEnabled?this.terrainCovers.get(e.id):null,useTerrainHeightMap:t==="offset",terrainSkipRender:t==="drape"||!e.props.operation.includes("draw")}}cleanup({deck:e}){this.dummyHeightMap&&(this.dummyHeightMap.delete(),this.dummyHeightMap=void 0),this.heightMap&&(this.heightMap.delete(),this.heightMap=void 0);for(let t of this.terrainCovers.values())t.delete();this.terrainCovers.clear(),e._removeDefaultShaderModule(H)}_updateHeightMap(e,t,o){!this.heightMap||!this.heightMap.shouldUpdate({layers:e,viewport:t})||this.terrainPass.renderHeightMap(this.heightMap,{...o,layers:e,moduleParameters:{heightMapBounds:this.heightMap.bounds,dummyHeightMap:this.dummyHeightMap,devicePixelRatio:1,drawToTerrainHeightMap:!0}})}_updateTerrainCovers(e,t,o,i){let s={};for(let n of t)n.state.terrainCoverNeedsRedraw&&(s[n.id]=!0,n.state.terrainCoverNeedsRedraw=!1);for(let n of this.terrainCovers.values())n.isDirty=n.isDirty||n.shouldUpdate({layerNeedsRedraw:s});for(let n of e)this._updateTerrainCover(n,t,o,i);this.isPicking||this._pruneTerrainCovers()}_updateTerrainCover(e,t,o,i){let s=this.isPicking?this.terrainPickingPass:this.terrainPass,n=this.terrainCovers.get(e.id);n||(n=new pe(e),this.terrainCovers.set(e.id,n));try{let a=n.shouldUpdate({targetLayer:e,viewport:o,layers:t});(this.isPicking||n.isDirty||a)&&(s.renderTerrainCover(n,{...i,layers:t,moduleParameters:{dummyHeightMap:this.dummyHeightMap,terrainSkipRender:!1,devicePixelRatio:1}}),this.isPicking||(n.isDirty=!1))}catch(a){e.raiseError(a,`Error rendering terrain cover ${n.id}`)}}_pruneTerrainCovers(){let e=[];for(let[t,o]of this.terrainCovers)o.isActive||e.push(t);for(let t of e)this.terrainCovers.delete(t)}};var go={terrainDrawMode:void 0},he=class extends Ft.LayerExtension{getShaders(){return{modules:[H]}}initializeState(){this.context.deck?._addDefaultEffect(new me)}updateState(e){let{props:t,oldProps:o}=e;if(this.state.terrainDrawMode&&t.terrainDrawMode===o.terrainDrawMode&&t.extruded===o.extruded)return;let{terrainDrawMode:i}=t;if(!i){let s=this.props.extruded,n=this.getAttributeManager()?.attributes,a=n&&"instancePositions"in n;i=s||a?"offset":"drape"}this.setState({terrainDrawMode:i})}onNeedsRedraw(){let e=this.state;e.terrainDrawMode==="drape"&&(e.terrainCoverNeedsRedraw=!0)}},K=he;(()=>{he.defaultProps=go})(),(()=>{he.extensionName="TerrainExtension"})();return wt(Z);})();
      return __exports__;
      });
