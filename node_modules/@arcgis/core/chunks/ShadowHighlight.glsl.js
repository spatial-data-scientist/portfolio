/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{invert as e,translate as i}from"../core/libs/gl-matrix-2/math/mat4.js";import{create as o}from"../core/libs/gl-matrix-2/factories/mat4f64.js";import{n as t,h as a}from"./vec32.js";import{create as r}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import{NormalFromDepth as l}from"../views/3d/webgl-engine/core/shaderLibrary/NormalFromDepth.glsl.js";import{ScreenSpacePass as s}from"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js";import{unoccludedHighlightFlag as d}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{ReadShadowMapPass as h}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{RgbaFloatEncoding as n}from"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js";import{Float3PassUniform as c}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{Float4PassUniform as g}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as p}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as m}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{Matrix4PassUniform as w}from"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js";import{ShaderBuilder as u}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as f}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{SnapshotSlot as v}from"../views/3d/webgl-engine/lib/ShadowMap.js";const x=.99999,b=.025;function M(o){const r=new u;r.include(h,o),r.include(s),r.include(l);const M=r.fragment;return M.include(n),M.uniforms.add(new f("defaultDepthTex",((e,i)=>i.shadowMap.getSnapshot(v.ExcludeHighlight))),new f("highlightDepthTex",((e,i)=>i.shadowMap.getSnapshot(v.Highlight))),new f("depthMap",((e,i)=>i.depth?.attachment)),new f("highlightTexture",(e=>e.highlight)),new g("uColor",(e=>e.shadowColor)),new p("opacity",(e=>e.shadowOpacity)),new p("occludedOpacity",(e=>e.occludedShadowOpacity)),new p("terminationFactor",(e=>e.opacityElevation*e.dayNightTerminator)),new c("lightingMainDirectionView",((e,i)=>t(S,a(S,i.lighting.mainLight.direction,i.camera.viewInverseTransposeMatrix)))),new w("inverseViewMatrix",((o,t)=>e(y,i(y,t.camera.viewMatrix,t.camera.center))))),M.constants.add("unoccludedHighlightFlag","vec4",d),M.code.add(m`
    void main(void) {
      vec4 highlightInfo = texture(highlightTexture, uv);
      float visiblyHighlighted = (1.0 - clamp(distance(unoccludedHighlightFlag, highlightInfo), 0.0, 1.0)) * highlightInfo.a;
      if (visiblyHighlighted > ${m.float(x)}) {
        discard;
      }

      float depth = depthFromTexture(depthMap, uv);

      // 1.0 is the clear value of depthMap, which means nothing has been drawn there and we should discard
      if (depth >= 1.0 || depth <= 0.0) {
        discard;
      }

      float currentPixelDepth = linearizeDepth(depth);
      vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);
      vec4 worldSpacePos = inverseViewMatrix * currentPixelPos;

      mat4 shadowMatrix;
      float linearDepth = -currentPixelDepth;
      int i = chooseCascade(linearDepth, shadowMatrix);
      if (i >= numCascades) {
        discard;
      }

      vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);

      // vertex completely outside? -> no shadow
      if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
        discard;
      }

      ivec2 texSize = textureSize(highlightDepthTex, 0);
      ivec2 uvShadow = ivec2(cascadeCoordinates(i, texSize, lvpos) * vec2(texSize));

      float depthHighlight = readShadowMapDepth(uvShadow, highlightDepthTex);
      bool shadowHighlight = depthHighlight < lvpos.z;
      if (!shadowHighlight) {
        discard;
      }

      float depthDefault = readShadowMapDepth(uvShadow, defaultDepthTex);
      bool shadowDefault = depthDefault < lvpos.z;

      vec3 normal = normalFromDepth(depthMap, currentPixelPos.xyz, gl_FragCoord.xy, uv);
      bool shaded = dot(normal, lightingMainDirectionView) < ${m.float(b)};

      float fragOpacity = (shadowDefault || shaded) ? occludedOpacity : opacity;
      fragColor = vec4(uColor.rgb, uColor.a * fragOpacity * terminationFactor);
    }
  `),r}const y=o(),S=r(),D=Object.freeze(Object.defineProperty({__proto__:null,build:M},Symbol.toStringTag,{value:"Module"}));export{D as S,M as b};
