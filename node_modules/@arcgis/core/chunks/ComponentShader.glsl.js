/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{earth as e,mars as o,moon as r}from"../geometry/support/Ellipsoid.js";import{OverlayContent as a}from"../views/3d/terrain/OverlayContent.js";import{IntegratedMeshMode as i}from"../views/3d/webgl-engine/collections/Component/Material/ComponentTechniqueConfiguration.js";import{ComponentData as l,ComponentDataType as t}from"../views/3d/webgl-engine/collections/Component/Material/shader/ComponentData.glsl.js";import{VertexDiscardByOpacity as d}from"../views/3d/webgl-engine/collections/Component/Material/shader/VertexDiscardByOpacity.glsl.js";import{ForwardLinearDepth as n}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{ShaderOutput as s}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SlicePass as c}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{NormalType as m}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js";import{TextureCoordinateAttribute as g}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js";import{VertexColor as u}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js";import{VertexNormal as v}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js";import{VertexPosition as h}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js";import{OutputDepth as p}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js";import{OutputHighlight as w}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{ReadLinearDepth as C}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js";import{ComputeMaterialColor as b}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl.js";import{ComputeNormalTexture as f}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js";import{ComputeShadingNormal as y}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeShadingNormal.glsl.js";import{EvaluateSceneLighting as x,addLightingGlobalFactor as L}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightIntensity as j}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{multipassTerrainTest as S}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{PBRMode as M,PhysicallyBasedRenderingParameters as N}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadBaseColorTexture as O}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl.js";import{ReadShadowMapPass as T}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{OverlayIM as A,getIMColorTexture as W}from"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js";import{symbolAlphaCutoff as P}from"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js";import{DiscardOrAdjustAlphaDraw as B}from"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js";import{EllipsoidMode as R}from"../views/3d/webgl-engine/core/shaderLibrary/util/EllipsoidMode.js";import{glsl as D}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as $}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as z}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{TransparencyPassType as E}from"../views/3d/webgl-engine/lib/TransparencyPassType.js";function V(V){const I=new $;I.include(h,V),I.include(v,V),I.include(u,V),I.include(g,V),I.include(n,V),I.include(l,V),I.include(B,V),I.include(c,V),I.include(O,V),I.include(d,V);const{vertex:_,fragment:G}=I;V.pbrMode!==M.Normal&&V.pbrMode!==M.Schematic||(I.include(N,V),V.hasNormalTexture&&I.include(f,V));const F=V.output===s.Shadow||V.output===s.ShadowHighlight||V.output===s.ShadowExcludeHighlight;F&&V.componentData===t.Varying?_.code.add(D`#define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`):_.code.add(D`#define discardShadows(castShadows) {}`);const H=V.integratedMeshMode===i.ColorOverlay||V.integratedMeshMode===i.ColorOverlayWithWater,k=H&&V.output===s.Color&&V.pbrMode===M.WaterOnIntegratedMesh;H&&(I.include(x,V),I.include(A,V),V.spherical?_.code.add(D`
      const float invEllipsoidRadius = ${D.float(1/(V.ellipsoidMode===R.Earth?e.radius:V.ellipsoidMode===R.Mars?o.radius:r.radius))};
      vec2 projectOverlay(vec3 pos) {
        return pos.xy / (1.0 + invEllipsoidRadius * pos.z);
      }
      `):_.code.add(D`vec2 projectOverlay(vec3 pos) { return pos.xy; }`)),k&&(I.varyings.add("tbnTangent","vec3"),I.varyings.add("tbnBiTangent","vec3"),I.varyings.add("groundNormal","vec3")),_.code.add(D`
    void main() {
      bool castShadows;
      vec4 externalColor = forwardExternalColor(castShadows);
      discardShadows(castShadows);

      vertexDiscardByOpacity(externalColor.a);

      ${V.output===s.ObjectAndLayerIdColor?D`externalColor.a = 1.0;`:""}

      if (externalColor.a < ${D.float(P)}) {
        // Discard this vertex
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }

      forwardPosition(readElevationOffset());
      forwardNormal();
      forwardTextureCoordinates();
      forwardVertexColor();
      forwardLinearDepth();
      ${V.output===s.ObjectAndLayerIdColor?D`forwardObjectAndLayerIdColor();`:""}
      ${k?V.spherical?D`
                groundNormal = normalize(positionWorld());
                tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));
                tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`:D`
                groundNormal = vec3(0.0, 0.0, 1.0);
                tbnTangent = vec3(1.0, 0.0, 0.0);
                tbnBiTangent = vec3(0.0, 1.0, 0.0);`:""}
      ${H?D`setOverlayVTC(projectOverlay(position));`:""}
    }
  `),V.output===s.Color&&(G.include(C),I.include(S,V),I.include(b,V),I.include(y,V),I.include(x,V),V.transparencyPassType===E.ColorAlpha&&(I.outputs.add("fragColor","vec4",0),I.outputs.add("fragAlpha","float",1)),V.receiveShadows?(I.include(T,V),G.code.add(D`float evaluateShadow() {
return readShadowMap(vPositionWorldCameraRelative, linearDepth);
}`)):G.code.add(D`float evaluateShadow() { return 0.0; }`),H&&G.uniforms.add(new z("ovColorTex",((e,o)=>W(e,o)))),G.code.add(D`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);
        ${V.multipassEnabled?D`terrainDepthTest(vPosition_view.z);`:""}

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        vec4 externalColor;
        int externalColorMixMode;
        readExternalColor(externalColor, externalColorMixMode);

        vec4 materialColor = computeMaterialColor(
          textureColor,
          externalColor,
          externalColorMixMode
        );
        ${H?D`vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);`:""}
    `),V.pbrMode===M.Normal||V.pbrMode===M.Schematic?(j(G),G.code.add(D`
        ${V.pbrMode===M.Normal?D`
                applyPBRFactors();
                if (int(externalColorMixMode) == 3) {
                  mrr = vec3(0.0, 0.6, 0.2);
                }`:""}
        vec3 normalVertex = shadingNormalWorld();
        float additionalIrradiance = 0.02 * mainLightIntensity[2];
      `),V.hasNormalTexture?G.code.add(D`mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);
vec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);`):G.code.add(D`vec3 shadingNormal = normalVertex;`),G.code.add(D`${V.spherical?D`vec3 normalGround = normalize(positionWorld());`:D`vec3 normalGround = vec3(0.0, 0.0, 1.0);`}
      `),G.code.add(D`
        vec3 viewDir = normalize(vPositionWorldCameraRelative);
        float ssao = 1.0 - occlusion * evaluateAmbientOcclusionInverse();
        ${V.snowCover?D`
                vec3 surfaceNormal = normalize(shadingNormalWorld());
                float snow = smoothstep(0.5, 0.55, dot(surfaceNormal, normalize(positionWorld())));
                materialColor.rgb = mix(materialColor.rgb, vec3(1.1), snow);
                ssao = mix(ssao, 0.5 * ssao, snow);
                shadingNormal = mix(shadingNormal, surfaceNormal, snow);`:""}

        ${H?D` materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`:""}

        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());
        vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);
        `)):(V.receiveShadows?G.code.add(D`float shadow = evaluateShadow();`):V.spherical?(L(G),G.code.add(D`float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());
float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);`)):G.code.add(D`float shadow = 0.0;`),k&&G.uniforms.add(new z("ovNormalTex",((e,o)=>o.overlay?.getTexture(a.WaterNormal)))),V.snowCover&&G.code.add(D`vec3 surfaceNormal = normalize(cross(dFdx(vPositionWorldCameraRelative), dFdy(vPositionWorldCameraRelative)));
float snow = smoothstep(0.5, 0.55, dot(surfaceNormal, normalize(positionWorld())));
materialColor.rgb = mix(materialColor.rgb, vec3(1), snow);`),G.code.add(D`
        float ambientOcclusion = evaluateAmbientOcclusion();
        vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());

        ${H?D` materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`:""}

        vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);
      ${k?D`
              vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);
              float waterNormalLength = length(overlayWaterMask);
              if (waterNormalLength > 0.95) {
                mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);
                vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, vPosition_view, positionWorld());
                vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
                // un-gamma the ground color to mix in linear space
                shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);
              }`:""}
      `)),G.code.add(D`
        fragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);
        ${V.transparencyPassType===E.ColorAlpha?D`
                fragColor = premultiplyAlpha(fragColor);
                fragAlpha = fragColor.a;`:""}
      }
    `));const q=V.output===s.Depth;return(q||F||V.output===s.ViewshedShadow)&&(q||I.include(p,V),G.code.add(D`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        ${q?"":D`outputDepth(linearDepth);`}
      }
    `)),V.output===s.Normal&&(I.include(y,V),G.code.add(D`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        // note: the alpha component needs to be 1.0 in order for this material to influence ambient occlusion,
        // see the ssao fragment shader
        float alpha = ${V.normalType===m.Ground?"0.0":"1.0"};
        fragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);
      }
    `)),V.output===s.ObjectAndLayerIdColor&&I.fragment.code.add(D`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        ${H?D`fragColor = getOverlayColorTexel(vtcOverlay);`:"outputObjectAndLayerIdColor();"}
      }
    `),V.output===s.Highlight&&(I.include(w),G.code.add(D`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        ${H?D`
                vec4 overlayColor = getCombinedOverlayColor();
                if (overlayColor.a == 0.0) {
                  fragColor = vec4(0.0);
                  return;
                }`:""}

        outputHighlight();
      }
    `)),I}const I=Object.freeze(Object.defineProperty({__proto__:null,build:V},Symbol.toStringTag,{value:"Module"}));export{I as C,V as b};
