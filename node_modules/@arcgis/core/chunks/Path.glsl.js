/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{ForwardLinearDepth as e,addNearFar as o}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{ShaderOutput as i}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SliceDraw as a}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as r}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{ObjectAndLayerIdColor as l}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js";import{PathVertexPosition as s}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl.js";import{OutputDepth as d}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js";import{OutputHighlight as n}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{EvaluateAmbientOcclusion as t}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js";import{EvaluateSceneLighting as c,addAmbientBoostFactor as g,addLightingGlobalFactor as m}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightIntensity as p}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{multipassTerrainTest as v}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{Normals as h}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl.js";import{NormalUtils as u}from"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js";import{ReadShadowMapDraw as b}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{ColorConversion as w}from"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js";import{addProjViewLocalOrigin as f,addViewNormal as y,addCameraPosition as j}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float3PassUniform as L}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{FloatPassUniform as P}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as S}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as C}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{TransparencyPassType as A}from"../views/3d/webgl-engine/lib/TransparencyPassType.js";function O(O){const D=new C,{vertex:_,fragment:F}=D;switch(f(_,O),D.varyings.add("vpos","vec3"),D.include(s,O),O.output!==i.Color&&O.output!==i.ObjectAndLayerIdColor||(D.include(r,O),D.include(b,O),D.include(e,O),D.include(l,O),D.varyings.add("vnormal","vec3"),D.varyings.add("vcolor","vec4"),O.multipassEnabled&&D.varyings.add("depth","float"),_.code.add(S`
      void main() {
        vpos = calculateVPos();
        vnormal = normalize(localNormal());

        ${O.multipassEnabled?"depth = (view * vec4(vpos, 1.0)).z;":""}
        gl_Position = transformPosition(proj, view, vpos);

        ${O.output===i.Color?"forwardLinearDepth();":""}
        forwardObjectAndLayerIdColor();

        vcolor = getColor();
      }
    `)),D.include(v,O),O.output){case i.Color:D.include(a,O),D.include(c,O),D.include(t,O),D.include(b,O),D.include(h,O),j(F,O),g(F),m(F),F.uniforms.add(_.uniforms.get("localOrigin"),new L("ambient",(e=>e.ambient)),new L("diffuse",(e=>e.diffuse)),new L("specular",(e=>e.specular)),new P("opacity",(e=>e.opacity))),F.include(w),O.transparencyPassType===A.ColorAlpha&&(D.outputs.add("fragColor","vec4",0),D.outputs.add("fragAlpha","float",1)),p(F),F.code.add(S`
        void main() {
          discardBySlice(vpos);
          ${O.multipassEnabled?"terrainDepthTest(depth);":""}

          shadingParams.viewDirection = normalize(vpos - cameraPosition);
          shadingParams.normalView = vnormal;
          vec3 normal = shadingNormal(shadingParams);
          float ssao = evaluateAmbientOcclusionInverse();

          float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
          vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
          ${O.receiveShadows?"float shadow = readShadowMap(vpos, linearDepth);":O.spherical?"float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);":"float shadow = 0.0;"}
          vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one
          float combinedOpacity = vcolor.a * opacity;
          albedo += 0.25 * specular; // don't completely ignore specular for now

          vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);
          fragColor = vec4(shadedColor, combinedOpacity);
          fragColor = highlightSlice(fragColor, vpos);
          ${O.transparencyPassType===A.ColorAlpha?S`
                  fragColor = premultiplyAlpha(fragColor);
                  fragAlpha = fragColor.a;`:""}
        }
      `);break;case i.Depth:D.include(r,O),_.code.add(S`void main() {
vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);
}`),D.include(a,O),F.code.add(S`void main() {
discardBySlice(vpos);
}`);break;case i.Shadow:case i.ShadowHighlight:case i.ShadowExcludeHighlight:case i.ViewshedShadow:D.include(r,O),o(D),D.varyings.add("depth","float"),_.code.add(S`void main() {
vpos = calculateVPos();
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
}`),D.include(a,O),D.include(d,O),F.code.add(S`void main() {
discardBySlice(vpos);
outputDepth(depth);
}`);break;case i.ObjectAndLayerIdColor:D.include(a,O),F.code.add(S`void main() {
discardBySlice(vpos);
outputObjectAndLayerIdColor();
}`);break;case i.Normal:D.include(r,O),D.include(u,O),y(_),D.varyings.add("vnormal","vec3"),_.code.add(S`void main(void) {
vpos = calculateVPos();
vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);
gl_Position = transformPosition(proj, view, vpos);
}`),D.include(a,O),F.code.add(S`void main() {
discardBySlice(vpos);
vec3 normal = normalize(vnormal);
if (gl_FrontFacing == false) normal = -normal;
fragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);
}`);break;case i.Highlight:D.include(r,O),D.include(u,O),D.varyings.add("vnormal","vec3"),_.code.add(S`void main(void) {
vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);
}`),D.include(a,O),D.include(n,O),F.code.add(S`void main() {
discardBySlice(vpos);
outputHighlight();
}`)}return D}const D=Object.freeze(Object.defineProperty({__proto__:null,build:O},Symbol.toStringTag,{value:"Module"}));export{D as P,O as b};
