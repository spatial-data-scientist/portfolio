/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{invertOrIdentity as e}from"../core/libs/gl-matrix-2/math/mat4.js";import{IDENTITY as i,create as o}from"../core/libs/gl-matrix-2/factories/mat4f64.js";import{NormalFromDepth as t}from"../views/3d/webgl-engine/core/shaderLibrary/NormalFromDepth.glsl.js";import{ScreenSpacePass as r}from"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js";import{ReadDepth as a}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js";import{LocalFromScreenSpacePassParameters as s,LocalFromScreenSpace as n}from"../views/3d/webgl-engine/core/shaderLibrary/util/LocalFromScreenSpace.glsl.js";import{Rgba4FloatEncoding as d}from"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloat16Encoding.glsl.js";import{TextureAtlasLookup as l}from"../views/3d/webgl-engine/core/shaderLibrary/util/TextureAtlasLookup.glsl.js";import{Float2PassUniform as h}from"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js";import{Float3PassUniform as c}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{FloatsPassUniform as v}from"../views/3d/webgl-engine/core/shaderModules/FloatsPassUniform.js";import{IntegerPassUniform as w}from"../views/3d/webgl-engine/core/shaderModules/IntegerPassUniform.js";import{glsl as m}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{Matrix4PassUniform as p}from"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js";import{Matrix4sPassUniform as u}from"../views/3d/webgl-engine/core/shaderModules/Matrix4sPassUniform.js";import{ShaderBuilder as f}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as g}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";class x extends s{constructor(){super(...arguments),this.targetVector=[1,0,0],this.upVector=[0,0,1],this.fovs=[45,45],this.headingAndTilt=[0,0],this.shadowMap={depthTexture:null,nearFar:[1,100],numActiveFaces:1,atlasRegions:[[0,0,1,1]]},this.projectionMatrices=i.flat(),this.viewMatrices=i.flat()}}function b(i){const o=new f,s=o.fragment;o.include(r),o.include(n),o.include(l),s.include(a),s.include(d),s.uniforms.add(new g("depthTexture",((e,i)=>i.depth?.attachment))),s.uniforms.add(new p("inverseProjectionMatrix",((e,i)=>i.camera.inverseProjectionMatrix)),new p("inverseViewNormalMatrix",((i,o)=>e(M,o.camera.viewInverseTransposeMatrix)))),s.uniforms.add(new c("viewshedTargetVector",((e,i)=>e.targetVector)),new c("viewshedUpVector",((e,i)=>e.upVector)),new h("viewshedFOVs",((e,i)=>e.fovs)),new h("viewshedHeadingAndTilt",((e,i)=>e.headingAndTilt)),new h("viewshedNearFar",((e,i)=>e.shadowMap.nearFar??[1,100]))),s.uniforms.add(new g("viewshedShadowMap",(e=>e.shadowMap.depthTexture)),new u("viewshedProjectionMatrices",((e,i)=>e.projectionMatrices),6),new u("viewshedViewMatrices",((e,i)=>e.viewMatrices),6),new w("viewshedNumFaces",((e,i)=>e.shadowMap.numActiveFaces)),new v("viewshedAtlasRegions",((e,i)=>e.shadowMap.atlasRegions.flat()),24)),s.constants.add("visibleColor","vec4",[0,1,0,.5]),s.constants.add("occludedColor","vec4",[1,0,0,.5]);const x=i.useNormalMap;return x?(s.uniforms.add(new g("normalMap",((e,i)=>e.normalTexture))),s.code.add(m`vec3 normalFromTexture() {
vec4 norm4 = texture(normalMap, uv);
vec3 nNormal = vec3(-1.0) + 2.0 * norm4.xyz;
return normalize((inverseViewNormalMatrix * vec4(nNormal, 1.0)).xyz);
}`)):o.include(t),s.code.add(m`
    // UV coordinates of point projected onto viewshed shadow map
    vec2 getViewshedUv(vec4 worldPosition, int face) {
      mat4 viewshedMatrix = viewshedProjectionMatrices[face];
      vec4 viewshedUv4 = viewshedMatrix * worldPosition;
      vec3 viewshedUv = viewshedUv4.xyz / viewshedUv4.w;
      return viewshedUv.xy;
    }

    float viewshedDepthToFloat(float depth) {
      return (depth - viewshedNearFar[0]) / (viewshedNearFar[1] - viewshedNearFar[0]);
    }

    // Orthographic depth to viewshed of given point and given cube map face in range [0, 1].
    float getOrthographicDepthToViewshed(vec4 worldPosition, int face) {
      mat4 viewshedViewMatrix = viewshedViewMatrices[face];
      vec4 viewshedUv4 = viewshedViewMatrix * worldPosition;
      vec3 viewshedUv = viewshedUv4.xyz / viewshedUv4.w;
      float depth = -viewshedUv.z;
      return viewshedDepthToFloat(depth);
    }

    // Read depth from shadow map given uv and cube map face
    float getDepthFromShadowMap(vec2 uv, int face) {
      int index = 4 * face;

      float umin = viewshedAtlasRegions[index];
      float umax = viewshedAtlasRegions[index + 1];
      float vmin = viewshedAtlasRegions[index + 2];
      float vmax = viewshedAtlasRegions[index + 3];

      vec4 atlasRegion = vec4(umin, vmin, umax, vmax);
      return rgba4ToFloat(textureAtlasLookup(viewshedShadowMap, uv, atlasRegion));
    }

    struct ViewshedPoint {
      int face;
      vec2 uv;
      bool isWithin;
      float orthographicDepth;
    };

    // Find cube map face the given position lies in and return relevant information about it
    bool getViewshedPoint(vec4 worldPosition, out ViewshedPoint point) {
      vec3 nUp = normalize(viewshedUpVector);

      // Try with all active cube map faces
      for(int i=0; i < viewshedNumFaces; i++) {

        // Check if when projected, point lies within shadow map texture
        vec2 viewshedUv = getViewshedUv(worldPosition, i);
        if (viewshedUv.x > 0.0 && viewshedUv.x < 1.0 && viewshedUv.y > 0.0 && viewshedUv.y < 1.0) {
          float orthoDepth = getOrthographicDepthToViewshed(worldPosition, i);
          if (orthoDepth >= 0.0) { // found a cube map face

            // Check whether point is really inside viewshed geometry, not just within the camera frustum

            // outside farDistance
            vec3 position = worldPosition.xyz;
            bool isWithin = length(position) <= viewshedNearFar[1];

            // horizontally outside fov
            float t = dot(nUp, position);
            bool isBottomHalf = t > 0.0;
            vec3 nProjVector = normalize(position - t * nUp);
            if (isWithin) {
              float angle = acos(dot(normalize(viewshedTargetVector), nProjVector));
              if (angle > viewshedFOVs[0] / 2.0) {
                isWithin = false;
              }
            }

            // vertically outside fov
            if (isWithin) {
              float angle = acos(dot(nProjVector, normalize(position)));
              if (!isBottomHalf) {
                angle = -angle;
              }
              float tilt = viewshedHeadingAndTilt[1];
              float limit = viewshedFOVs[1] / 2.0;
              if (angle > limit || angle < -limit) {
                isWithin = false;
              }
            }

            point = ViewshedPoint(i, viewshedUv, isWithin, orthoDepth);
            return true;
          }
        }
      }

      // no cube face matches
      return false;
    }

    float normalCosAngle(float linearDepth, vec3 localPosition) {
      ${x?m`vec3 normal = normalFromTexture();`:m`
        vec3 cameraSpacePosition = reconstructPosition(gl_FragCoord.xy, linearDepth);
        vec3 normal = normalFromDepth(depthTexture, cameraSpacePosition, gl_FragCoord.xy, uv);
        normal = (inverseViewNormalMatrix * vec4(normal, 1.0)).xyz;
        `};

      vec3 viewingDir = normalize(localPosition);
      return dot(normal, viewingDir);
    }

    void main() {
      float depth = depthFromTexture(depthTexture, uv);

      // Outside camera planes
      if (depth >= 1.0 || depth <= 0.0) {
        return;
      }

      float linearDepth = linearizeDepth(depth);

      // Relative to viewshed position
      vec4 localPosition = reconstructLocalPosition(gl_FragCoord.xy, linearDepth);

      ViewshedPoint point;
      bool foundFace = getViewshedPoint(localPosition, point);

      // Outside every viewshed
      if (!foundFace || !point.isWithin) {
        return;
      }

      float viewshedDepth = getDepthFromShadowMap(point.uv, point.face);
      float distance = point.orthographicDepth;

      bool visible = distance < viewshedDepth;
      fragColor = visible ? visibleColor : occludedColor;

      float cosAngle = normalCosAngle(linearDepth, localPosition.xyz);

      // Everything facing away, and close to parallel is considered occluded.
      // Theshold corresponds to around 0.6 degrees, tuned empirically.
      if (cosAngle > -0.01) {
        fragColor = occludedColor;
      }
    }`),o}const M=o(),P=Object.freeze(Object.defineProperty({__proto__:null,ViewshedPassParameters:x,build:b},Symbol.toStringTag,{value:"Module"}));export{x as V,P as a,b};
