/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{on as t}from"../../../../core/events.js";import r from"../../../../core/Logger.js";import{disposeMaybe as s}from"../../../../core/maybe.js";import{getProjectiveTransform as i}from"../../../../core/perspectiveUtils.js";import{watch as o,when as n,initial as a}from"../../../../core/reactiveUtils.js";import{create as l}from"../../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{set as m}from"../../../../core/libs/gl-matrix-2/math/vec2.js";import{create as h}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{AnimatedSymbolRepeatType as p}from"../../../../symbols/cim/enums.js";import{DisplayObject as c}from"../DisplayObject.js";import{play as u}from"./animatedFormats/utils.js";import{BufferObject as d}from"../../../webgl/BufferObject.js";import{TextureWrapMode as f,PrimitiveType as w,Usage as y}from"../../../webgl/enums.js";import{Texture as g}from"../../../webgl/Texture.js";import{TextureDescriptor as x}from"../../../webgl/TextureDescriptor.js";import{VertexArrayObject as v}from"../../../webgl/VertexArrayObject.js";const _=[1,1],V=4,b=l(),j={none:p.None,loop:p.Loop,oscillate:p.Oscillate};function A(e){return e?{...e,playAnimation:e.playing,repeatType:e.repeatType?j[e.repeatType]:void 0}:{}}class T extends c{constructor(i){super(),this.elementView=i,this.isWrapAround=!1,this.wrapAroundShift=0,this.perspectiveTransform=h(),this._playHandle=null,this._vertices=new Float32Array(20),this._handles=[],this._handles.push(o((()=>this.elementView.element.opacity),(e=>this.opacity=e),a),o((()=>[this.elementView.coords]),(()=>{this.requestRender()}),a),o((()=>["animationOptions"in this.elementView.element&&this.elementView.element.animationOptions]),(()=>{this._playHandle?.remove(),this.texture=s(this.texture),this.requestRender()}),a),n((()=>this.elementView.element.loaded),(()=>{const e=this.elementView.element;this.ready(),"video"===e.type&&null!=e.content&&this._handles.push(t(e.content,"play",(()=>this.requestRender())))}),a)),i.element.load().catch((t=>{r.getLogger("esri.views.2d.layers.MediaLayerView2D").error(new e("element-load-error","Element cannot be displayed",{element:i,error:t}))}))}getMesh(e){throw new Error("Method not implemented.")}destroy(){this._playHandle?.remove(),this._handles.forEach((e=>e.remove())),this.texture=s(this.texture)}get textureSize(){return _}get dvsMat3(){return this.parent.dvsMat3}beforeRender(e){const{context:t}=e,r=this.elementView.element.content;if(null!=r){const e=r instanceof HTMLImageElement,s=r instanceof HTMLVideoElement,i=e?r.naturalWidth:s?r.videoWidth:r.width,o=e?r.naturalHeight:s?r.videoHeight:r.height;if(this._updatePerspectiveTransform(i,o),this.texture)s&&!r.paused&&(this.texture.setData(r),this.requestRender(),this.texture.generateMipmap());else{const e=new x;if(e.wrapMode=f.CLAMP_TO_EDGE,e.preMultiplyAlpha=!0,e.width=i,e.height=o,"getFrame"in r){const s=r=>{this.texture?this.texture.setData(r):this.texture=new g(t,e,r),this.requestRender()};"animationOptions"in this.elementView.element&&(this._playHandle=u(r,A(this.elementView.element.animationOptions),null,s))}else this.texture=new g(t,e,r);this.texture.generateMipmap(),s&&!r.paused&&this.requestRender()}}super.beforeRender(e)}_createTransforms(){return null}draw(e){e.drawArrays(w.TRIANGLE_STRIP,0,V)}updateDrawCoords(e,t,r,s){const{coords:i,bounds:o}=this.elementView;if(null==i||null==o)return;const[n,a,l,m]=i.rings[0],h=this._vertices,{x:p,y:c}=e;h.set([a[0]-p,a[1]-c,n[0]-p,n[1]-c,l[0]-p,l[1]-c,m[0]-p,m[1]-c]);let u=t;if(s){const[e,,t]=o,{worldWidth:r,xBounds:i}=s,[n,a]=i;e<n&&t>n?u=r:t>a&&e<a&&(u=-r)}this.wrapAroundShift=u,this.isWrapAround=0!==u}getVAO(e,t,r){if(null==this.elementView.coords)return null;const s=this._vertices;if(this._vao)this._geometryVbo.setData(s);else{this._geometryVbo=d.createVertex(e,y.DYNAMIC_DRAW,s);const i=d.createVertex(e,y.STATIC_DRAW,new Uint16Array([0,0,0,1,1,0,1,1,1,1,0,0,0,0,0,1,1,0,1,1]));this._vao=new v(e,r,t,{geometry:this._geometryVbo,tex:i})}return this._vao}_updatePerspectiveTransform(e,t){const r=this._vertices;i(b,[0,0,e,0,0,t,e,t],[r[0],r[1],r[4],r[5],r[2],r[3],r[6],r[7]]),m(this.perspectiveTransform,b[6]/b[8]*e,b[7]/b[8]*t)}}export{T as default};
