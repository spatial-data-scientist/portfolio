/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{cyclical2PI as e}from"../../../core/Cyclical.js";import{createAngle as t,valueInUnit as r}from"../../../core/quantityUtils.js";import{subtract as i,dot as s,squaredLength as n,scaleAndAdd as o}from"../../../core/libs/gl-matrix-2/math/vec2.js";import{create as a}from"../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{r as c,f as p,s as g}from"../../../chunks/vec32.js";import{create as h}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{absoluteHeightElevationInfo as l}from"../../../support/elevationInfoUtils.js";import{VerticalHalfPlaneConstraint as f}from"../sketch/constraints.js";import{fromAnyMapPoint as d,asVec2 as m,markAsTarget as u,fromValues as x,fromVec3 as V}from"../sketch/normalizedPoint.js";import{SnappingAlgorithm as E}from"./SnappingAlgorithm.js";import{squaredScreenDistance as j}from"./snappingUtils.js";import{SelfSnappingRightAngleType as v,RightAngleSnappingCandidate as S,OtherVertexType as k}from"./candidates/RightAngleSnappingCandidate.js";import{vectorToScreenPoint as C}from"../support/viewUtils.js";import{radiansGeographicBetweenVec as w,pointFromDistanceAlongAzimuth as y}from"../../support/angularMeasurementUtils.js";import{geodesicDistance as F}from"../../support/geodesicLengthMeasurementUtils.js";class R extends E{snapNewVertex(e,t){const r=t.editGeometryOperations.data.components[0],i=[];if(r.vertices.length<2)return i;const{view:s}=this,n=C(e,t.spatialReference,l,s),o=r.vertices.at(-1);this._checkForSnappingCandidate(v.LastVertex,i,o.leftEdge,o,o.leftEdge.leftVertex,e,n,t);const a=r.vertices[0];return this._checkForSnappingCandidate(v.FirstVertex,i,a.rightEdge,a,a.rightEdge.rightVertex,e,n,t),i}snapExistingVertex(e,t){const r=[],i=t.vertexHandle;if(i.component.vertices.length<3)return r;const{view:s}=this,n=C(e,t.spatialReference,l,s),o=i.leftEdge,a=i.rightEdge;if(o?.leftVertex.leftEdge){const i=o.leftVertex.leftEdge;this._checkForSnappingCandidate(v.ExistingEdge,r,i,i.rightVertex,i.leftVertex,e,n,t)}if(a?.rightVertex.rightEdge){const i=a.rightVertex.rightEdge;this._checkForSnappingCandidate(v.ExistingEdge,r,i,i.leftVertex,i.rightVertex,e,n,t)}return r}_checkForSnappingCandidate(e,t,r,i,s,n,o,a){if(!this.edgeExceedsShortLineThreshold(r,a))return;const c=this.view,p=d(i.pos,c,a),g=d(s.pos,c,a);_(T,g,p,n,a),this._checkForSnappingCandidateAlongProjectedRay(e,t,g,p,T,n,o,a)}_checkForSnappingCandidateAlongProjectedRay(e,t,r,a,p,g,d,E){const{spatialReference:v,pointer:w}=E,y=i(M,m(g),m(a)),F=s(p,y)/n(p),R=o(M,m(a),p,F),_=u(x(R[0],R[1],g[2]));if(j(d,C(_,v,l,this.view))>this.squaredProximityThreshold(w)||this.isVertical(_,a,E)||this.isVertical(a,r,E))return;const P=c(h(),a,p,Math.sign(F));t.push(new S({targetPoint:_,constraint:new f(a,V(P)),previousVertex:r,otherVertex:a,otherVertexType:k.CENTER,selfSnappingType:e,isDraped:"on-the-ground"===E.elevationInfo?.mode}))}}function _(e,t,r,i,s){P(e,t,r,i,s)||U(e,t,r)}function P(i,s,n,o,{spatialReference:a}){const c=w(s,n,a,a);if(null==c)return!1;const g=w(n,o,a,a);if(null==g)return!1;const l=Math.sign(e.shortestSignedDiff(c,g))*Math.PI*.5,f=t(c+l,"radians","geographic"),d=h(),m=F(n,o,a);return null!=m&&(y(d,n,a,r(m,"meters"),f,"geodesic"),p(i,d,n),!0)}function U(e,t,r){const s=i(M,m(r),m(t));g(e,s[1],-s[0],0)}const M=a(),T=h();export{R as RightAngleSnapper};
