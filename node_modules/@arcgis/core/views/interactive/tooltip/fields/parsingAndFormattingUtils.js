/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{Cyclical as t}from"../../../../core/Cyclical.js";import{formatArea as n,formatLength as e,formatRelativeLength as r,formatVerticalLength as i,formatRelativeVerticalLength as o,formatAngle as u}from"../../../../core/quantityFormatUtils.js";import{toUnit as l,createScalar as a,createAngle as c}from"../../../../core/quantityUtils.js";import{isLoaded as s,fromLatitudeLongitude as f,fromLongitude as m,fromLatitude as g}from"../../../../geometry/coordinateFormatter.js";import{formatNumber as p,parseNumber as d}from"../../../../intl/number.js";import{getDegreesGeographic as h}from"../../../support/angularMeasurementUtils.js";const v=1,y=6;function D(t,u){return{angleRelative:x,direction:j,directionRelative:R,directionRelativeBilateral:$,latitudeDecimalDegrees:w,longitudeDecimalDegrees:F,area:(e,r)=>n(t,e,r??u.area),length:(n,r,i)=>e(t,n,r??u.length,i),lengthRelative:(n,e)=>r(t,n,e??u.length),totalLength:(n,r)=>e(t,n,r??u.length),verticalLength:(n,e)=>i(t,n,e??u.length),verticalLengthRelative:(n,e)=>o(t,n,e??u.verticalLength),percentage:T,scalar:b,scale:Z}}function x(t){return p(t,{signDisplay:"exceptZero",...z(v)})}function j(t){return u(t,t.rotationType,v)}function R(t){const n=h(t);return p(n,{style:"unit",unitDisplay:"narrow",unit:"degree",signDisplay:n>0?"never":"exceptZero",...z(v)})}function $(t){return u(t,t.rotationType,v)}function F(t){return U(t,N)}function w(t){return U(t,O)}function L(t){return q(t,N)}function A(t){return q(t,O)}function U(t,n){const e=!1,r="geographic";return u(l(t,"degrees"),r,y,n,e)}function q(t,n){const e=!1,r=n.normalize(l(t,"degrees").value,void 0,e);return b(a(r),y)}function T(t){return p(t.value,{style:"percent"})}function Z(t){return p(t,{style:"percent",maximumFractionDigits:0})}function b(t,n){return p(t.value,z(n))}function z(t){return{minimumFractionDigits:t,maximumFractionDigits:t}}function B(t){return(n,e)=>{const r=d(n);return null!=r?t(r,e):null}}const C=t=>{let n=`[-+]?[0-9${t.thousands}]+`;return""!==t.decimal&&(n+=`${t.decimal}[0-9]+`),new RegExp(`^(${n}\\s*)${t.separator}(\\s*${n})$`,"i")},E="â€¯",I=[];for(const P of[",","\\|","\\s+"])for(const t of["\\.",",",""])for(const n of["",",","\\.",E,"\\s+"])P!==t&&P!==n&&t!==n&&I.push({separator:P,decimal:t,thousands:n,pattern:C({decimal:t,thousands:n,separator:P})});function M(t){for(const{decimal:n,thousands:e,pattern:r}of I){r.lastIndex=0;const i=t.match(r);if(!i)continue;const o=d(k(i[1],n,e)),u=d(k(i[2],n,e));if(null!=o&&null!=u)return{x:a(o),y:a(u)}}return null}function k(t,n,e){let r=t.replaceAll(/[\s+]/g,"");return""!==e&&(r=r.replaceAll(e,"")),""!==n&&(r=r.replaceAll(n,".")),r}function G(t){if(!t||null!=d(t)||!s())return null;const n=f(t),e=K(n?.latitude),r=K(n?.longitude);return null!=r&&null!=e?{latitude:e,longitude:r}:null}function H(t){return K(m(t))}function J(t){return K(g(t))}function K(t){return null!=t?c(t,"degrees","geographic"):null}const N=new t(-180,180),O=new t(-90,90);export{k as cleanNumber,K as createGeographicCoordinate,A as formatLatitudeDecimalDegreesForInputMode,L as formatLongitudeDecimalDegreesForInputMode,D as getFormatters,B as makeQuantityParser,J as parseLatitude,G as parseLatitudeLongitude,H as parseLongitude,M as parseXY};
