/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{lerp as t}from"../../../core/mathUtils.js";import{n as e,s as i,g as s,j as o,H as n,b as r,m as l,F as a,z as h}from"../../../chunks/vec32.js";import{create as u}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{lonLatToSphericalPCPF as d}from"../../../geometry/projection/lonLatToSphericalPCPF.js";import{newDoubleArray as c}from"../../../geometry/support/DoubleArray.js";import{intersectsSphere as p,numPlanes as f,PlaneIndex as m}from"../../../geometry/support/frustum.js";import{c as g,g as x}from"../../../chunks/sphere.js";import{PatchType as $}from"./interfaces.js";import{createSphericalGlobePatch as _,updateCornerSpherical as v,updateEdgesAndCornersSpherical as M,updateEdgeElevationsAndResolutionsSpherical as b}from"./PatchGeometryFactory.js";import{enableTerrainInternalChecks as j,internalAssert as S,almostEquals as T}from"./terrainUtils.js";import{Tile as E,CenterPosition as H}from"./Tile.js";import{TileFrustumVisibility as B}from"./TileFrustumVisibility.js";import{compareTilesByLij as I}from"./tileUtils.js";class y extends E{constructor(t,e,i,s,o){super(),this._convexHull=new Array(24),this._boundingSphere=g(),this._baseUsedMemory=1816,this.init(t,e,i,s,o)}init(i,s,o,n,r){super.init(i,s,o,n,r);const l=this.ellipsoid.radius,a=this.extentInRadians[0],h=this.extentInRadians[1],u=this.extentInRadians[2],c=this.extentInRadians[3],p=t(h,c,.5),f=t(a,u,.5),m=0===i?0:Math.min(Math.abs(h),Math.abs(c));this._edgeLen=(u-a)*Math.cos(m)*l,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=l-Math.sqrt(l*l-this._edgeLen2/4),d(this.centerAtSeaLevel,f,p,this.ellipsoid.radius),e(this.up,this.centerAtSeaLevel),this.updateRadiusAndCenter()}updateRadiusAndCenter(){this._updateBoundingVolumes();const t=this._center;if(0===this.lij[0])i(x(t[H.MIDDLE]),0,0,0),i(t[H.TOP],0,0,0),i(t[H.BOTTOM],0,0,0),t[H.MIDDLE][3]=this.ellipsoid.radius+this.elevationBoundsMax;else{this._updateCenter();const e=t[H.MIDDLE],i=this.convexHull;let s=0;for(let t=0;t<8;++t)s=Math.max(s,L(x(e),i,3*t));t[H.MIDDLE][3]=Math.sqrt(s)}}_calculateFrustumVisibilityStatus(t){if(!p(t,this._boundingSphere))return B.OUTSIDE;if(this.lij[0]<10)return B.INTERSECTS;const e=this.convexHull,i=this.surface.view.state.camera.near;let s=!0;for(let o=0;o<f;o++){const n=o===m.NEAR,r=t[o],l=r[0],a=r[1],h=r[2],u=r[3]-(n?i:0);let d=!1;for(let t=0;t<8;++t){const i=3*t;if(l*e[i]+a*e[i+1]+h*e[i+2]+u<0){if(d=!0,!s)break}else s=!1}if(!d)return B.OUTSIDE}return s?B.INSIDE:B.INTERSECTS}computeElevationBounds(){super.computeElevationBounds(),this._updateBoundingVolumes()}createGeometry(){_(this.renderData,this._getPatchType()),this._updateBoundingVolumes(),this.setMemoryDirty()}_updateBoundingVolumes(){this._updateConvexHull(),this._updateBoundingSphere(),j&&this._checkBVs()}_updateBoundingSphere(){const t=this._boundingSphere,e=x(t),r=this.elevationBoundsMin,l=this.elevationBoundsMax,a=this.ellipsoid.radius,h=l;if(0===this.level)i(e,0,0,0),t[3]=a+h;else{const i=this.extentInRadians,h=.5*(i[0]+i[2]),u=i[1],d=i[3];O(V,h,u,a),O(A,h,d,a),s(e,V,A);o(e,e,(a+.5*(r+l))/n(e));const c=this.convexHull;let p=0;const f=(t,e)=>{const i=t[0]-c[3*e],s=t[1]-c[3*e+1],o=t[2]-c[3*e+2];return Math.sqrt(i*i+s*s+o*o)};for(let t=0;t<8;++t){const i=f(e,t);p=Math.max(p,i)}const m=p;t[3]=m+2}}_updateConvexHull(){const t=this.extentInRadians,i=this.ellipsoid.radius;if(0===this.level)return;const a=this.elevationBoundsMin,d=this.elevationBoundsMax,c=this._getPatchType(),p=this.surface.isWebMercator,f=p&&c===$.HAS_NORTH_POLE,m=p&&c===$.HAS_SOUTH_POLE,g=m||f,x=Math.PI/2,_=t[0],v=t[2],M=m?-x:t[1],b=f?x:t[3],j=.5*(_+v),E=a,H=i+(g?Math.min(0,E-1):E),B=(t,e,i)=>O(t,e,i,H),I=u(),y=u(),D=u(),L=u();B(I,_,M),B(y,_,b),B(D,v,b),B(L,v,M);const R=(t,e)=>{for(let i=0;i<3;++i)this._convexHull[3*e+i]=t[i]};R(I,0),R(y,1),R(D,2),R(L,3);const V=d,A=i+(g?Math.max(0,V+1):V),C=u(),F=u(),N=u();O(F,j,b,H),O(N,j,M,H),s(C,F,N),e(C,C);const U=u(),k=u(),w=(t,i)=>{h(k,t,i),e(k,k);const n=-l(t,U)/l(k,U);S(n>=0),o(k,k,n),s(t,t,k)};if(2**this.lij[0]>2*this.lij[1]){const t=N,i=u();r(i,P,t),e(i,i),r(U,t,i),e(U,U),S(T(l(U,t)/n(t),0)),w(I,y),w(L,D),R(I,0),R(L,3)}else if(2**this.lij[0]!==2*this.lij[1]){const t=F,i=u();r(i,P,t),e(i,i),r(U,i,t),e(U,U),w(y,I),w(D,L),R(y,1),R(D,2)}const q=(t,e)=>{const i=A/l(e,C);for(let s=0;s<3;++s)this._convexHull[3*t+s]=e[s]*i};q(4,I),q(5,y),q(6,D),q(7,L)}_getPatchType(){const t=this.lij[1],e=0===t,i=t===(1<<this.level)-1;return e?i?$.HAS_BOTH_POLES:$.HAS_NORTH_POLE:i?$.HAS_SOUTH_POLE:$.REGULAR}intersectsRay(t,e,i,s){const o=this._boundingSphere,n=o[3]+i,r=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],l=o[0]-t[0],a=o[1]-t[1],h=o[2]-t[2],u=(l*e[0]+a*e[1]+h*e[2])/r,d=e[0]*u-l,c=e[1]*u-a,p=e[2]*u-h;return d*d+c*c+p*p<n*n}getDefaultVerticesPerSide(){return this.level<D.length?D[this.level]+1:2}updateCornerElevations(){v(this.renderData),this._updateBoundingVolumes()}updateEdgeElevations(){M(this.renderData),this._updateBoundingVolumes()}updateEdgeElevationsAndResolutions(){b(this.renderData),this._updateBoundingVolumes()}_checkBVs(){if(!j)return;if(this.level<=2)return;const t=this._boundingSphere,i=t[3],o=x(t),d=u(),p=this.ellipsoid.radius,f=this.elevationBoundsMin,m=this.elevationBoundsMax,g=p+f,$=1,_=0,v=this._center[H.MIDDLE][3],M=this.convexHull,b=(t,e)=>{for(let i=0;i<3;++i)t[i]=M[3*e+i]};{const t=u(),i=u(),s=u(),o=u(),n=u(),a=(a,u,d,c)=>{b(i,a),b(s,u),b(o,d),h(i,i,s),h(o,o,s),r(t,i,o),e(t,t);const p=l(t,s);b(n,c);const f=l(t,n),m=Math.abs(f-p);S(T(m,0),`Non coplanar ${a},${u},${d},${c} diff = ${m}`)};a(0,1,2,3),a(4,5,6,7),a(0,1,4,5),a(1,2,5,6),a(2,3,6,7),a(3,0,7,4)}const E=c(24),B=(t,e,i)=>{const s=4*t;for(let o=0;o<3;++o)E[s+o]=e[o];E[s+3]=i},y=u(),D=u(),L=u(),P=u(),V=(t,i,s,o)=>{b(y,i),b(D,s),b(L,o),h(y,y,D),e(y,y),h(L,L,D),e(L,L),r(P,y,L),e(P,P);const n=l(P,D);B(t,P,n)};V(0,0,1,2),V(1,1,0,4),V(2,1,5,2),V(3,3,2,6),V(4,4,0,3),V(5,4,6,5);const A=1,C=(t,e,i,s)=>{const o=4*t;return E[o]*e+E[o+1]*i+E[o+2]*s-E[o+3]},F=(t,e,i,s)=>C(t,e,i,s)>=-A,N=(t,e)=>F(t,e[0],e[1],e[2]),U=2**this.lij[0]>2*this.lij[1],k=(t,e,s)=>Math.sqrt(R(t,e,s,o[0],o[1],o[2]))<i,w=t=>k(t[0],t[1],t[2]),q=(t,e)=>k(t[e],t[e+1],t[e+2]),G=this.extentInRadians,z=.5*(G[0]+G[2]),W=G[1],J=G[3],K=u(),Q=u();O(K,z,J,g),O(Q,z,W,g);const X=U?"Upper":"Lower";let Y=!0;for(let e=0;e<6;++e){for(let t=0;t<8;++t){const i=3*t,s=F(e,M[i],M[i+1],M[i+2]);Y&&=s,S(s,`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}S(N(e,Q),`Tile[${this.lij}] (${X}) bottom mid outside of plane ${e}`),S(N(e,K),`Tile[${this.lij}] (${X}) top mid outside of plane ${e}`)}S(Y,"Not all convex hull points are inside  convex hull polyhedron"),S(w(Q),`Tile[${this.lij}] (${X}) bottom mid outside of bounding sphere`),S(w(K),`Tile[${this.lij}] (${X}) top mid outside of bounding sphere`);for(let e=0;e<8;++e){const t=q(M,3*e);S(t,`Tile[${this.lij}] Convex hull point ${e} outside of bounding sphere`)}for(let e=0;e<6;++e)for(let t=0;t<8;++t){const i=3*t;F(e,M[i],M[i+1],M[i+2])||console.error(`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}const{extentInRadians:Z}=this,tt=Math.max(Z[2]-Z[0],Z[3]-Z[1]),et=Math.round(tt*p),{renderData:it}=this;if(!it)return;const{geometry:st,geometryState:ot,localOrigin:nt}=it,rt=st.vertexAttributes?.position;if(!rt)return;const lt=u(),at=st.numVerticesPerSide-2,{indices:ht,indexCount:ut,edgeVerticesStartIndex:dt,poleVerticesStartIndex:ct}=st;if(!ht)return;const pt=new Set;for(let e=0;e<ut;++e){const t=ht[e];if(pt.has(t))continue;pt.add(t);const r=t<ct,l=t>=dt;let h=!1,u=-1;if(l){let e=dt;for(let i=0;i<4;++i){const s=ot.edgeResolutions[i];if(t===e||t===e+s-1){h=!0;break}if(e+=s,t<e){u=i;break}}}const c=l?ot.edgePeerNeighbors[u]:null,g=l&&c&&I(this,c)>0;rt.getVec(t,d),s(lt,d,nt);const x=n(lt)-p;let M=0,b=!1;const j=f-x,S=x-m,T=j>$,E=S>$,H=T||E,B=()=>{const e=r?"internal":l&&!h?"edge":h?"corner":"pole";return`Tile[${this.lij}].vertex[${t}]:${e}`+(T?"(below)":E?"(above)":"")+(g?"(Neighbor)":"")},y=a(lt,o);if(y>=i+_){const t=y-i;H||(console.error(`${B()} is out of the bounding sphere by ${t.toFixed(0)} / ${i.toFixed(0)}[tol=${_}] h=${x.toFixed(0)} / [${f.toFixed(0)}..${m.toFixed(0)}] (${(t/i).toFixed(0)})`),b=!0)}for(let e=0;e<6;++e)if(!F(e,lt[0],lt[1],lt[2])){const s=C(e,lt[0],lt[1],lt[2]),o=t%at,n=(t-o)/at;0===e&&j||5===e&&S||(console.error(`${B()} (${o},${n})|${at}] is out of the bounding trapezoid plane ${e} h=${Math.round(x)} / [${Math.round(f)}..${Math.round(m)}] dist=${Math.round(s)} radii = ${Math.round(i)}/${Math.round(v)}} : maxL = ${et}`),++M)}if(b||M>0)break}}get convexHull(){return this._convexHull}}const D=[128,64,64,32,16,8,8,4];function L(t,e,i){return R(t[0],t[1],t[2],e[i],e[i+1],e[i+2])}function R(t,e,i,s,o,n){const r=s-t,l=o-e,a=n-i;return r*r+l*l+a*a}const O=(t,e,i,s)=>{const o=Math.cos(e),n=Math.sin(e),r=Math.cos(i),l=Math.sin(i);t[0]=s*r*o,t[1]=s*r*n,t[2]=s*l},P=[0,0,1],V=u(),A=u();export{y as SphericalPatch};
