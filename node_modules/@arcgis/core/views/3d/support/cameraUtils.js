/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import{Cyclical as t}from"../../../core/Cyclical.js";import n from"../../../core/Logger.js";import{deg2rad as r,rad2deg as o}from"../../../core/mathUtils.js";import{throwIfAborted as i}from"../../../core/promiseUtils.js";import{j as a,g as l,F as c,c as s,p as u}from"../../../chunks/vec32.js";import{clone as f,create as m}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as p}from"../../../geometry/ellipsoidUtils.js";import d from"../../../geometry/Point.js";import{projectWithZConversion as h,project as g}from"../../../geometry/projection.js";import y from"../../../geometry/SpatialReference.js";import{projectPointToVector as v,projectPointToVectorAsync as w}from"../../../geometry/projection/projectPointToVector.js";import{projectVectorToPoint as R,projectVectorToPointAsync as x}from"../../../geometry/projection/projectVectorToPoint.js";import{projectVectorToVector as j}from"../../../geometry/projection/projectVectorToVector.js";import{getCGSForPlanet as M}from"../../../geometry/support/planetGCSUtils.js";import{ViewingMode as T}from"../../ViewingMode.js";import{cameraOnContentAlongViewDirection as S}from"../camera/intersectionUtils.js";import{t as C,c as z}from"../../../chunks/cameraUtilsPlanar.js";import{t as U,c as b}from"../../../chunks/cameraUtilsSpherical.js";import{getGreatCircleSpanAt as P}from"./earthUtils.js";import{getElevationAtPoint as A}from"./ElevationProvider.js";import{isSpatialReferenceSupported as D}from"../../support/spatialReferenceSupport.js";const H=()=>n.getLogger("esri.views.3d.support.cameraUtils"),L=39.37,G=96,E=1,O=8,q=5,I=1,k=m(),F={heading:0,tilt:0},J=m(),V=new t(-20037508.342788905,20037508.342788905),X=new t(-180,180);var K;function W(e){return e.spatialReference??y.WGS84}function Y(e){return"global"===e.viewingMode?b:z}function N(e,t,n,r,o){return Y(e).headingTiltToDirectionUp(t,n,r,o)}function Z(e,t){if(null==t)return null;const n=e.renderSpatialReference,o=Y(e).headingTiltToDirectionUp,i=m();if(!v(t.position,i,n))return null;const c=o(i,t.heading,t.tilt);a(c.direction,c.direction,e.state.camera.distance),l(c.direction,c.direction,i);const s=S(e,i,c.direction,c.up);return s.fov=r(t.fov),s.row=t.layout.row,s.rows=t.layout.rows,s.column=t.layout.column,s.columns=t.layout.columns,s}!function(e){e[e.LOCKED=0]="LOCKED",e[e.ADJUST=1]="ADJUST"}(K||(K={}));const B=m();function Q(t,n,r){const i=t.renderSpatialReference,a=re(t,n.eye,n.viewForward,n.up,F);let l=W(t);return j(n.eye,i,B,l)||(l=y.WGS84,j(n.eye,i,B,l)),null==r?r=new e(new d(B,l),a.heading,a.tilt,o(n.fov)):(r.position.x=B[0],r.position.y=B[1],r.position.z=B[2],r.position.spatialReference=l,r.heading=a.heading,r.tilt=a.tilt,r.fov=o(n.fov)),r.layout.row=n.row,r.layout.rows=n.rows,r.layout.column=n.column,r.layout.columns=n.columns,r}function $(e,t,n){const o=e.state.camera,i=o.width/2/o.pixelRatio;e.renderCoordsHelper.viewingMode===T.Global&&null!=n&&(t*=Math.cos(r(n))),t/=e.renderCoordsHelper.unitInMeters;return i/(G*L/t)/Math.tan(o.fovX/2)}function _(e,t,n){const o=e.state.camera,i=t*Math.tan(o.fovX/2),a=o.width/2/o.pixelRatio;let l=G*L/(a/i);return e.renderCoordsHelper.viewingMode===T.Global&&null!=n&&(l/=Math.cos(r(n))),l*e.renderCoordsHelper.unitInMeters}async function ee(e,t,n,r,o,i){return ne(e,t,$(e,n,t.latitude),r,o,i)}function te(e,t,n,r,o,i){return Ue(e,ce(e,r.heading,r.tilt,t,n,o),r.fov,i)}async function ne(e,t,n,r,o,a){const l=await se(e,r.heading,r.tilt,t,n,o,a);return i(a),be(e,l,r.fov,a)}function re(e,t,n,r,o){return Y(e).directionToHeadingTilt(t,n,r,o)}function oe(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,J,e.spatialReference)&&e.elevationProvider&&(A(e.elevationProvider,J)??0)>J[2]-I)}async function ie(e,t,n){if(oe(e,t))return!0;const{elevationProvider:r,spatialReference:o,renderCoordsHelper:a}=e;if(null==r||!a.fromRenderCoords(t,J,o))return!1;const[l,c,s]=J,u=await r.queryElevation(l,c,s,o,"ground",n)??0;return i(n),u>s-I}async function ae(e,t,n){const r=m();if(null==t)return s(r,e.state.camera.center);if(t instanceof d){const{renderSpatialReference:o,basemapTerrain:a,elevationProvider:l}=e,c=t.spatialReference;if(await w(t,r,o,0,{signal:n}),i(n),null==t.z&&null!=a&&null!=l){const o=await l.queryElevation(t.x,t.y,t.z??0,c,"ground",n);i(n),null!=o&&e.renderCoordsHelper.setAltitude(r,o)}return r}return s(r,t)}function le(e,t){const n=m();if(null==t)return s(n,e.state.camera.center);if(t instanceof d){if(!v(t,n,e.renderSpatialReference))return null;const{basemapTerrain:r,elevationProvider:o}=e;if(null==t.z&&null!=r&&null!=o){const r=A(o,t);null!=r&&e.renderCoordsHelper.setAltitude(n,r)}return n}return s(n,t)}function ce(e,t,n,r,o,i){return ue(e,t,n,r instanceof d?r:null,le(e,r),o,i)}async function se(e,t,n,r,o,a,l){const c=r instanceof d?r:null,s=await ae(e,r,l);return i(l),fe(e,t,n,c,s,o,a,l)}function ue(e,t,n,r,o,i,a){if(null==o)return null;if(!r&&(r=new d({spatialReference:W(e)}),!R(o,e.renderSpatialReference,r)))return null;const l=me(e,t,n,o,i,a);if(pe(e,n,a)&&oe(e,l.eye)){const{tilt:a,mode:l}=de(e,n,o,i);return ue(e,t,a,r,o,i,l)}return he(l,o)}async function fe(e,t,n,r,o,a,l,c){r||(r=new d({spatialReference:W(e)}),await x(o,e.renderSpatialReference,r,{signal:c})||(r=null)),i(c);const s=me(e,t,n,o,a,l);if(pe(e,n,l)&&await ie(e,s.eye,c)){i(c);const{tilt:l,mode:s}=de(e,n,o,a);return fe(e,t,l,r,o,a,s,c)}return he(s,o)}function me(e,t,n,r,o,i){const a=je(e,t,n,r,o=Math.max(o,e.state.constraints.minimumPoiDistance),i);return(0,Y(e).eyeForCenterWithHeadingTilt)(r,o,a.heading,a.tilt)}function pe(e,t,n){const r=e.map.ground.navigationConstraint;return n===K.ADJUST&&"global"===e.viewingMode&&t>0&&(null==r||"stay-above"===r.type)}function de(e,t,n,r){const o=Ce(e,n,r,Se(e,r,t,n));return{tilt:o,mode:t-o<1?K.LOCKED:K.ADJUST}}function he(e,t){return{...e,center:f(t)}}function ge(e,t){const{state:n,spatialReference:r}=e,o=t.spatialReference;return n.isGlobal&&D(o,T.Global)||n.isLocal&&r.equals(o)}function ye(e,t){let n,r,o;if(e.state.isGlobal){const e=new d(t.xmin,t.ymin,t.spatialReference),i=new d(t.xmax,t.ymax,t.spatialReference),a=t.spatialReference.isGeographic?X:V;n=new d({x:a.center(e.x,i.x),y:(i.y+e.y)/2,z:null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0,spatialReference:t.spatialReference});const l=p(t.spatialReference),c=P(n,e,i);r=c.lon,o=c.lat,a.diff(e.x,i.x)>a.range/2&&(r+=l.halfCircumference),r=Math.min(r,l.halfCircumference),o=Math.min(o,l.halfCircumference)}else{const i=e.renderSpatialReference??t.spatialReference;i.equals(t.spatialReference)||(t=g(t,i)),r=t.xmax-t.xmin,o=t.ymax-t.ymin;const a=null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0;n=new d({x:t.xmin+.5*r,y:t.ymin+.5*o,z:a,spatialReference:i})}const i=null!=t.zmax&&null!=t.zmin?t.zmax-t.zmin:0,a=e.state.camera,l=1/Math.tan(a.fovX/2),c=1/Math.tan(a.fovY/2),s=1/Math.tan(a.fov/2);return{center:n,distance:Math.max(.5*r*l,.5*o*c,.5*i*s)/E}}async function ve(e,t,n,r,o,a){const l=ge(e,t)?t:await h(t,e.spatialReference,{signal:a});i(a);const{center:c,distance:s}=ye(e,l),u=await se(e,n,r,c,s,o,a);return i(a),be(e,u,e.camera.fov,a)}function we(e,t,n,r,o,i){let a;try{a=ge(e,t)?t:g(t,e.spatialReference)}catch(u){return null}const{center:l,distance:c}=ye(e,a),s=ce(e,n,r,l,c,o);return null==s?null:Ue(e,s,e.camera.fov,i)}function Re(e,t,n){const r=e.renderSpatialReference,o=new d({spatialReference:W(e)});if(!R(n,r,o))return null;const i=Math.tan(t.fovX/2),a=Math.tan(t.fovY/2),l=c(t.eye,n),s=2*l*i*E,u=2*l*a*E;return"global"===e.viewingMode?U(e,o,s,u):C(e,o,s,u)}function xe(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>O)return!0;const o=t,i=e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation;return u(o,i)/(Math.tan(.5*e.state.camera.fov)*r)>q}function je(e,t,n,r,o,i){let a=0;return i===K.ADJUST&&xe(e,r,o)?(t=0,a=Te(e,o,n,r)):a=ze(e,r,o,n),a=e.state.constraints.clampTilt(o,a),{heading:t,tilt:n=Ce(e,r,o,a)}}const Me=.7;function Te(e,t,n,r){const o=ze(e,r,t,n);if(!e.state.constraints.tilt)return o;const i=e.state.constraints.tilt(t);i.max=Math.min(i.max,.5*Math.PI);const a=i.min*(1-Me)+i.max*Me;return Math.min(o,a)}function Se(e,t,n,r){let o=ze(e,r,t,n);if(!e.state.constraints.tilt)return o;const i=e.state.constraints.tilt(t);return o=Math.min(o,.5*Math.PI),i.min*(1-Me)+o*Me}function Ce(e,t,n,r){return Y(e).lookAtTiltToEyeTilt(r,t,n)}function ze(e,t,n,r){return Y(e).eyeTiltToLookAtTilt(r,t,n)}function Ue(t,n,r,o){if(null==n)return null;const i=t.renderSpatialReference,a=new d({spatialReference:W(t)});return R(n.eye,i,a)?(o??=new e,o.position=a,o.heading=n.heading,o.tilt=n.tilt,o.fov=r,o):null}async function be(t,n,r,o){const a=t.renderSpatialReference,l=new d({spatialReference:W(t)});return await x(n.eye,a,l,{signal:o}),i(o),new e(l,n.heading,n.tilt,r)}function Pe(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.levelAtScale(t);H().error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function Ae(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.scaleAtLevel(t);H().error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}function De(e,t){const{renderSpatialReference:n}=e,r=M(n);let o=null;try{j(t.center,n,k,r)&&(o=k[1])}catch{}return _(e,t.distance,o)}export{K as OrientationMode,De as computeScale,re as directionToHeadingTilt,_ as distanceToScale,Z as externalToInternal,ne as fromCenterDistanceAsync,te as fromCenterDistanceSync,ee as fromCenterScale,ve as fromExtentAsync,we as fromExtentSync,se as getObserverForPointAtDistanceAsync,ce as getObserverForPointAtDistanceSync,W as getViewSR,N as headingTiltToDirectionUp,Q as internalToExternal,$ as scaleToDistance,Pe as scaleToZoom,Re as toExtent,Ae as zoomToScale};
