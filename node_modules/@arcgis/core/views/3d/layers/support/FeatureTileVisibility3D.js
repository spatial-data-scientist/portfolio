/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{acosClamped as t}from"../../../../core/mathUtils.js";import e from"../../../../core/ObjectPool.js";import{n as s,z as i,m as r,r as n,s as o,F as u,b as c,g as a,j as l,H as d,k as _,f as h}from"../../../../chunks/vec32.js";import{create as f,fromValues as m}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as p}from"../../../../geometry/ellipsoidUtils.js";import{getSphericalPCPF as T}from"../../../../geometry/spatialReferenceEllipsoidUtils.js";import{projectBuffer as g}from"../../../../geometry/projection/projectBuffer.js";import{projectVec3Array as E}from"../../../../geometry/projection/projectVec3Array.js";import{PlaneIndex as R,PointIndex as F}from"../../../../geometry/support/frustum.js";import{create as I,signedDistance as O,projectVector as S,fromPoints as b,getNormal as A}from"../../../../geometry/support/plane.js";import{wrap as G}from"../../../../geometry/support/ray.js";import{ViewingMode as B}from"../../../ViewingMode.js";import{FeatureTileDescriptor3D as M,Visibility as P}from"./FeatureTileDescriptor3D.js";import{Frustum as j}from"../../state/Frustum.js";import{FrustumExtentIntersection as x}from"../../support/FrustumExtentIntersection.js";class N{constructor(t,e){this._renderCoordsHelper=t,this._getIsGroundOpaque=e,this._surfaceElevation=0,this._isGroundOpaque=!1,this._cache=new Map,this._frustumBoundingSphereCenter=f(),this._frustumBoundingSphereRadius=0,this._frustum=new j(t),this._extendedFrustum=new j(t),this._intersector=new x({renderCoordsHelper:t}),this._renderSR=t.spatialReference;const s=T(this._renderSR);this._renderSREllipsoidRadius=p(s).radius,this._renderCoordsHelper=t}begin(t,e){this._surfaceElevation=e,this._aboveGround=t.aboveGround,this._isGroundOpaque=this._getIsGroundOpaque(),this._frustum.update(t),k(this._frustum),this._updateExtendedFrustum(t),this._updateFrustumBoundingSphere()}end(){this._cache.clear()}calculate(t){const e=this._renderCoordsHelper.viewingMode===B.Global&&t.lij[0]>=V&&t.lij[0]<v,s=this._getOrCalculateSingleTileVisibility(t,!e);return s!==P.INVISIBLE&&e?this._calculateAggregatedChildrenVisibility(t):s}_calculateAggregatedChildrenVisibility(t){let e=P.INVISIBLE;const s=this._cache.get(t.id);if(null!=s)return s;const i=U.acquire();t.getChildren(i);for(const r of i){const t=this.calculate(r);if(t!==P.INVISIBLE&&(e=t,t===P.VISIBLE_ON_SURFACE))break}return U.release(i),this._cache.set(t.id,e),e}_getOrCalculateSingleTileVisibility(t,e){const s=this._cache.get(t.id);if(null!=s)return s;const i=this._calculateSingleTileVisibility(t);return e&&this._cache.set(t.id,i),i}_calculateSingleTileVisibility(t){if(!this._aboveGround&&this._renderCoordsHelper.viewingMode===B.Global&&t.lij[0]<H){return this._calculateSingleTileVisibilitySided(t,!1)===P.INVISIBLE?this._calculateSingleTileVisibilitySided(t,!0):void 0}return this._calculateSingleTileVisibilitySided(t,this._aboveGround)}_isTileVisibleInFrustum(t){return this._renderCoordsHelper.viewingMode===B.Local?this._isTileVisibleInFrustumLocal(t):this._isTileVisibleInFrustumGlobal(t)}_updateFrustumBoundingSphere(){const t=this._frustum,e=t.origin,o=at;s(o,t.direction);const u=t.points,c=lt;i(c,u[4],e);const a=.5*r(c,c)/r(o,c),l=this._frustumBoundingSphereCenter;n(l,e,o,a);const d=1+a;this._frustumBoundingSphereRadius=d}_isTileVisibleInFrustumLocal(t){const e=t.tilingScheme.spatialReference,s=t.extent,c=this._renderSR,a=$;if(a[0]=s[0],a[1]=s[1],a[2]=0,a[3]=s[2],a[4]=s[3],a[5]=0,!g(a,e,0,a,c,0,2))return!1;const l=tt;o(l[0],a[0],a[1],0),o(l[1],a[3],a[1],0),o(l[2],a[3],a[4],0),o(l[3],a[0],a[4],0);const d=et;o(d,.5*(a[0]+a[3]),.5*(a[1]+a[4]),.5*(a[2]+a[5]));const _=st;o(_,0,0,1);const h=.5*u(l[0],l[2]),f=this._frustum,m=this._frustumBoundingSphereRadius,p=this._frustumBoundingSphereCenter,T=_t;i(T,p,d);const E=r(_,T),R=dt;n(R,d,_,E);if(u(R,p)>h+m)return!1;const F=Z,I=this._isGroundOpaque&&this._aboveGround,O=this._isGroundOpaque&&!this._aboveGround,S=Math.min(O?yt:1/0,E+m),b=Math.max(I?-yt:-1/0,E-m);for(let i=0;i<4;++i)n(F[i],l[i],_,S),n(F[i+4],l[i],_,b);return!J(f.planes,F,8)}_isTileVisibleInFrustumGlobal(t){const e=t.tilingScheme.spatialReference,_=t.extent,h=this._isGroundOpaque&&this._aboveGround,p=this._isGroundOpaque&&!this._aboveGround;if(t.lij[0]<K)return!0;const T=tt,g=.5*(_[0]+_[2]);if(o(T[0],_[0],_[1],0),o(T[1],_[2],_[1],0),o(T[2],_[2],_[3],0),o(T[3],_[0],_[3],0),o(T[4],g,_[1],0),o(T[5],g,_[3],0),!E(T,e,0,T,this._renderSR,0,6))return!1;const R=T[0][2]>0,F=T[3][2]<0,I=R||F,S=this._renderSREllipsoidRadius;if(I){const t=m(0,0,1),e=rt;W(e,t,T[0]);const s=nt;if(W(s,t,T[1]),R){const i=it,r=T[4],n=ot;W(n,r,t),W(i,n,r);const o=T[0];c(o,e,i),D(o,S);const u=T[1];c(u,s,i),D(u,S)}else if(F){const i=it,r=T[5],n=ot;W(n,r,t),W(i,r,n);const o=T[3];c(o,i,e),D(o,S);const u=T[2];c(u,i,s),D(u,S)}}const b=et;{const t=i(Tt,T[3],T[0]);s(t,t);const e=a(gt,T[0],T[3]);l(e,e,.5);const o=-r(e,t),u=a(Et,T[0],T[1]);l(u,u,.5);const c=a(Rt,T[2],T[3]);l(c,c,.5);const d=i(Ft,c,u);s(d,d);const _=-(o+r(t,u))/r(t,d);n(b,u,d,_),D(b,S)}const A=this._frustumBoundingSphereRadius,G=this._frustumBoundingSphereCenter,B=this._frustum,M=B.planes,P=ut;s(P,b);const j=r(T[0],P)/d(T[0]),x=B.origin,N=B.points;let V=!1;if(h){{V=!0;const t=s(f(),x);for(let e=0;e<4;++e){const n=N[4+e],o=i(f(),n,x);s(o,o);const u=c(f(),t,o);s(u,u);const a=c(f(),o,u);s(a,a);if(r(x,a)>S){V=!1;break}}}if(V){if(r(x,P)<S*j-yt)return!1}const t=s(Ct,B.origin);if(r(t,P)<0)return!1;{const t=s(wt,B.direction);if(r(t,P)>qt)return!1}}const v=Math.sqrt(1-j*j);if(v>.9)return!0;let H=!1;{const t=r(P,G),e=d(G);if(e<=A&&!M.some((t=>O(t,ht)>0))){if(!h)return!0;H=!0}const s=t/e;if(!H&&t<=0){if(-t>A)return!1}const i=A/e;if(Math.sqrt(1-s*s)*Math.sqrt(1-i*i)-i*s>v)return!1}if(!V){if(T.some((t=>B.intersectsPoint(t))))return!0;if(B.intersectsPoint(b))return!0}const L=ft;i(L,G,ht);const y=r(L,P),C=ct;l(C,P,y);const w=u(C,G),q=e.isWGS84,U=t.lij,k=q&&U[2]===2**U[0]-1,X=q&&0===U[2],Y=X?jt:k?Mt:Gt,Z=X?xt:k?Pt:Bt;if(!H){const t=T,e=Nt,s=It,i=Ot,r=ht;for(const n of Y){const o=t[n];if(z(s,t[(n+1)%4],o),z(i,r,o),W(e,i,s),Q(e,N,1))return!1}}let $=null;if(!h&&y<1.01*A){const t=2.5*A;if(w>j*t+A)return!1;const e=pt,s=t/j;for(let i=0;i<4;++i)l(e[i],T[i],s/S);o(e[4],0,0,0),$=e}else{const t=(p?S+yt:y+A)/j,e=h?S-yt:(y-A)/j,s=mt;for(let i=0;i<4;++i){const r=T[i];l(s[i],r,e/S),l(s[i+4],r,t/S)}$=s}if(J(M,$,$.length))return!1;const st=B.lines,at=St,lt=bt;for(const r of st){s(lt,r.direction);for(const t of Z){const e=$[t];if(s(at,e),Lt(lt,at,$,N))return!1;const r=(t+1)%4;if(h){const t=$[r];if(i(at,t,e),s(at,at),Lt(lt,at,$,N))return!1}if(p){const e=$[4+t],n=$[4+r];if(i(at,n,e),s(at,at),Lt(lt,at,$,N))return!1}}}return!0}_calculateSingleTileVisibilitySided(t,e){return this._isTileVisibleInFrustum(t)?(this._intersector.update(t.extent,t.tilingScheme.spatialReference,this._surfaceElevation,e),this._intersector.isVisibleInFrustum(this._frustum,this._renderSREllipsoidRadius,!0)?P.VISIBLE_ON_SURFACE:P.VISIBLE_WHEN_EXTENDED):P.INVISIBLE}_updateExtendedFrustum(e){this._extendedFrustum.update(e),k(this._extendedFrustum);const s=this._renderCoordsHelper.worldUpAtPosition(e.eye,C);this._aboveGround||_(s,s);const i=t(-r(s,e.viewForward));if(this._hasExtendedFrustum=i>e.fovY/2,!this._hasExtendedFrustum)return;const n=this._extendedFrustumParameters(),o=this._extendedFrustum.mutablePoints;for(let t=0;t<4;t++){const e=n.pointIndices[t],s=o[e],i=this._renderCoordsHelper.getAltitude(s);if(n.needsAltitudeAdjustment(i)){switch(this._renderCoordsHelper.worldUpAtPosition(s,C),e){case F.FAR_BOTTOM_LEFT:case F.FAR_TOP_LEFT:case F.NEAR_BOTTOM_LEFT:case F.NEAR_TOP_LEFT:S(this._extendedFrustum.planes[R.LEFT],C,C);break;case F.FAR_BOTTOM_RIGHT:case F.FAR_TOP_RIGHT:case F.NEAR_BOTTOM_RIGHT:case F.NEAR_TOP_RIGHT:S(this._extendedFrustum.planes[R.RIGHT],C,C)}l(C,C,n.direction),this._renderCoordsHelper.intersectInfiniteManifold(G(s,C),n.zWithMargin,s)}}if(this._extendedFrustum.updatePoints(o),b(o[F.NEAR_BOTTOM_LEFT],o[F.NEAR_BOTTOM_RIGHT],o[F.NEAR_TOP_RIGHT],w),b(o[F.NEAR_BOTTOM_RIGHT],o[F.NEAR_TOP_RIGHT],o[F.NEAR_TOP_LEFT],q),r(A(w),A(q))<0){const t=this._extendedFrustum.mutablePoints;this._aboveGround?[t[F.NEAR_BOTTOM_LEFT],t[F.NEAR_BOTTOM_RIGHT]]=[t[F.NEAR_BOTTOM_RIGHT],t[F.NEAR_BOTTOM_LEFT]]:[t[F.NEAR_TOP_LEFT],t[F.NEAR_TOP_RIGHT]]=[t[F.NEAR_TOP_RIGHT],t[F.NEAR_TOP_LEFT]],this._extendedFrustum.updatePoints(t)}}_extendedFrustumParameters(){return this._aboveGround?this._extendedFrustumParametersAboveSurface():this._extendedFrustumParametersBelowSurface()}_extendedFrustumParametersAboveSurface(){const t=this._surfaceElevation-y;return{zWithMargin:t,pointIndices:j.planePointIndices.bottom,direction:-1,needsAltitudeAdjustment:e=>e>t}}_extendedFrustumParametersBelowSurface(){const t=this._surfaceElevation+y;return{zWithMargin:t,pointIndices:j.planePointIndices.top,direction:1,needsAltitudeAdjustment:e=>e<t}}}const V=2,v=6,H=12,L=.95,y=1,C=f(),w=I(),q=I(),U=new e(Array,(t=>{4!==t.length&&(t[0]=new M,t[1]=new M,t[2]=new M,t[3]=new M)}),(t=>{t[0].release(),t[1].release(),t[2].release(),t[3].release()}));function k(t){const e=j.nearFarLineIndices,s=t.mutablePoints;for(const i of e){const[t,e]=i,r=s[t],n=s[e];h(C,n,r),l(C,C,L),a(s[e],r,C)}t.updatePoints(s)}function W(t,e,i){return c(t,e,i),s(t,t),t}function z(t,e,r){return i(t,e,r),s(t,t),t}function D(t,e){return l(t,t,e/d(t)),t}const X=[R.LEFT,R.RIGHT,R.BOTTOM,R.TOP,R.FAR];function Y(t,e,s){for(let i=0;i<s;++i)if(O(t,e[i])<=0)return!1;return!0}function J(t,e,s){for(const i of X)if(Y(t[i],e,s))return!0;return!1}const K=4;function Q(t,e,s){for(const i of e)if(r(i,t)<s)return!1;return!0}const Z=[f(),f(),f(),f(),f(),f(),f(),f()],$=[0,0,0,0,0,0],tt=[f(),f(),f(),f(),f(),f()],et=f(),st=f(),it=f(),rt=f(),nt=f(),ot=f(),ut=f(),ct=f(),at=f(),lt=f(),dt=f(),_t=f(),ht=m(0,0,0),ft=f(),mt=[f(),f(),f(),f(),f(),f(),f(),f()],pt=[f(),f(),f(),f(),f()],Tt=f(),gt=f(),Et=f(),Rt=f(),Ft=f(),It=f(),Ot=f(),St=f(),bt=f(),At=f(),Gt=[0,1,2,3],Bt=[0,1,2,3],Mt=[0,1,3],Pt=[0,1,3],jt=[1,2,3],xt=[1,2,3],Nt=f();function Vt(t,e,s){let i=1/0,n=-1/0;for(const o of s){const t=r(e,o);i=Math.min(i,t),n=Math.max(n,t)}t[0]=i,t[1]=n}function vt(t,e,s,i){let n=1/0,o=-1/0;for(const u of i){const i=r(s,u);if(n=Math.min(n,i),o=Math.max(o,i),n<=e&&o>=t)return!1}return!0}const Ht=[0,0];function Lt(t,e,s,i){if(0===s.length||0===i.length)return!0;const r=At;W(r,t,e);const n=i[0]<s[0],o=n?s:i,u=Ht;return Vt(u,r,n?i:s),vt(u[0],u[1],r,o)}const yt=430,Ct=f(),wt=f(),qt=Math.cos(.25*Math.PI);export{N as FeatureTileVisibility3D,K as globalTileLevelThreshold,J as isConvexHullOutsideOfFrustum};
