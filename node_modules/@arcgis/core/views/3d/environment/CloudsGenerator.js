/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../core/Accessor.js";import{lerp as i}from"../../../core/mathUtils.js";import{releaseMaybe as s,disposeMaybe as r,destroyMaybe as o}from"../../../core/maybe.js";import{watch as a,initial as n}from"../../../core/reactiveUtils.js";import{property as h}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/Logger.js";import"../../../core/RandomLCG.js";import{subclass as u}from"../../../core/accessorSupport/decorators/subclass.js";import{fromMat4 as l}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{targetTo as d}from"../../../core/libs/gl-matrix-2/math/mat4.js";import{create as c}from"../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{set as m,equals as p,copy as f}from"../../../core/libs/gl-matrix-2/math/vec2.js";import{create as _}from"../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{fromValues as g,zeros as x}from"../../../core/libs/gl-matrix-2/factories/vec3f32.js";import{getReferenceEllipsoid as w}from"../../../geometry/ellipsoidUtils.js";import{C as T}from"../../../chunks/Clouds.glsl.js";import{CloudsTextureChannels as C,CloudsRenderingStages as v}from"./CloudsData.js";import{FadeMode as y}from"./CloudsParameters.js";import{cloudPresets as b}from"./CloudsPresets.js";import{CloudsTechnique as P}from"./CloudsTechnique.js";import{CloudsTechniqueConfiguration as S,RayMarchingSteps as j}from"./CloudsTechniqueConfiguration.js";import{NoiseTextureAtlas as I}from"./NoiseTextureAtlas.js";import{BindParameters as M}from"../webgl-engine/lib/BindParameters.js";import{createQuadVAO as z}from"../webgl-engine/lib/glUtil3D.js";import{TaskPriority as E}from"../../support/Scheduler.js";import{Yield as q}from"../../support/Yield.js";import{TextureType as D,TextureWrapMode as U}from"../../webgl/enums.js";import{FramebufferObject as R}from"../../webgl/FramebufferObject.js";import{TextureDescriptor as F}from"../../webgl/TextureDescriptor.js";let A=class extends t{constructor(e){super(e),this._techniques=new Array,this._techniqueConfiguration=new S,this._bindParameters=new M(null,null),this._passParameters=new T,this._weatherTile=_(),this._weatherTileCount=128,this._faceIndex=0,this._tileIndex=0,this.coverage=i(b.default.coverage[0],b.default.coverage[1],.5),this.density=i(b.default.density[0],b.default.density[1],.5),this.absorption=i(b.default.absorption[0],b.default.absorption[1],.5),this.cloudSize=i(b.default.cloudSize[0],b.default.cloudSize[1],.5),this.detailSize=i(b.default.detailSize[0],b.default.detailSize[1],.5),this.smoothness=i(b.default.smoothness[0],b.default.smoothness[1],.5),this.cloudHeight=i(b.default.cloudHeight[0],b.default.cloudHeight[1],.5),this.raymarchingSteps=b.default.raymarchingSteps,this._viewMatrix=c(),this._dirty=!1,this.running=!1,this._vao=z(e.context.renderContext.rctx)}_getTechnique(e){const t=1-this.context.renderContext.bindParameters.cloudsFade.readChannels,i=t===C.RG?2*e:2*e+1,s=this._techniques[i];return s||(this._techniqueConfiguration.writeTextureChannels=t,this._techniqueConfiguration.steps=e,this._techniques[i]=new P({rctx:this.context.renderContext.rctx,viewingMode:this.view.state.viewingMode},this._techniqueConfiguration),this._techniques[i])}updateWeatherTile(){const e=this.view.camera.position.latitude,t=this.view.camera.position.longitude;if(null==e||null==t)return;m(this._weatherTile,(e+90)/180,(t+180)/360);const i=Math.floor(this._weatherTileCount*Math.abs(2*this._weatherTile[0]-1));this._weatherTile[0]=Math.floor(2*this._weatherTileCount*this._weatherTile[0]),this._weatherTile[1]=Math.floor(4*(this._weatherTileCount-i)*this._weatherTile[1]);let s=0,r=0;if(null!=this.view.environment&&"virtual"!==this.view.environment.lighting.type&&null!=this.view.environment.lighting.date){const e=new Date(this.view.environment.lighting.date);e.setUTCHours(this.view.environment.lighting.date.getUTCHours()+(this.view.environment.lighting.displayUTCOffset??0)),s=31*e.getUTCMonth()+e.getUTCDate(),r=e.getUTCFullYear()}this._weatherTile[0]=(this._weatherTile[0]+s)%(2*this._weatherTileCount),this._weatherTile[1]=(this._weatherTile[1]+r%100)%(4*this._weatherTileCount),p(this._passParameters.weatherTile,this._weatherTile)||this.setDirty()}initialize(){const e=w(this.view.spatialReference);this._passParameters.cloudRadius=.5*e.radius,this.setDirty(),this.updateWeatherTile(),this.addHandles([this.view.resourceController.scheduler.registerTask(E.CLOUDS_GENERATOR,this),a((()=>[this.coverage,this.density,this.absorption,this.cloudSize,this.detailSize,this.smoothness,this.cloudHeight,this.raymarchingSteps]),(()=>this.setDirty()),n)])}destroy(){this._techniques.forEach((e=>s(e))),this._frameBufferCube=r(this._frameBufferCube),this._techniques.length=0,this._vao.dispose(),this._passParameters.noiseTexture=o(this._passParameters.noiseTexture)}get _tilesPerFace(){switch(this._techniqueConfiguration.steps){case j.SIXTEEN:return 1;case j.HUNDRED:return 4;case j.COUNT:case j.TWOHUNDRED:return 8}}get usedMemory(){return(this._frameBufferCube?.usedMemory??0)+(this._passParameters.noiseTexture?.textureAtlas?.usedMemory??0)}_ensureNoiseTexture(){return this._passParameters.noiseTexture??=new I({context:this.context}),this._passParameters.noiseTexture.updateWeatherMap(this._passParameters.weatherTile),null!=this._passParameters.noiseTexture.textureAtlas}_ensureFrameBufferCube(e){if(null==this._frameBufferCube){const t=new F(e);t.target=D.TEXTURE_CUBE_MAP,t.wrapMode=U.CLAMP_TO_EDGE,this._frameBufferCube=new R(this.context.renderContext.rctx,t)}return this._frameBufferCube}get cubeMap(){return this._frameBufferCube}destroyFrameBufferCube(){this._frameBufferCube=r(this._frameBufferCube)}applyPreset(e,t){const s=e.median,r=e=>{const r=i(e[0],e[1],s);return t<.5?i(e[0],r,2*t):i(r,e[1],2*(t-.5))};this.coverage=r(e.coverage),this.density=r(e.density),this.absorption=r(e.absorption),this.cloudSize=r(e.cloudSize),this.detailSize=r(e.detailSize),this.smoothness=r(e.smoothness),this.cloudHeight=r(e.cloudHeight),this.raymarchingSteps=e.raymarchingSteps}setDirty(){this._dirty=this.running=!0}runTask(e){0===this._faceIndex&&0===this._tileIndex&&(this._passParameters.raymarchingSteps=this.raymarchingSteps,this.updateWeatherTile(),f(this._passParameters.weatherTile,this._weatherTile));const t=this._getTechnique(this._passParameters.raymarchingSteps);if(!t.compiled)return q;if(this.context.renderContext.bindParameters.cloudsFade.fadeMode===y.CROSS_FADE||!this._ensureNoiseTexture())return q;0===this._faceIndex&&0===this._tileIndex&&(this.context.renderContext.bindParameters.cloudsFade.renderingStage=v.RENDERING,this._passParameters.absorption=this.absorption,this._passParameters.density=this.density,this._passParameters.cloudSize=this.cloudSize,this._passParameters.detailSize=this.detailSize,this._passParameters.smoothness=this.smoothness,this._passParameters.cloudHeight=this.cloudHeight,this._passParameters.coverage=this.coverage,this._dirty=!1);const i=B[this._faceIndex],s=H[this._faceIndex];d(this._viewMatrix,O,i,s),l(this._passParameters.viewMatrix,this._viewMatrix);const r=this.context.renderContext.rctx,o=r.bindTechnique(t,this._bindParameters,this._passParameters);r.bindVAO(this._vao),o.assertCompatibleVertexAttributeLocations(this._vao);const a=r.getViewport(),n=t.configuration.cubeMapSize,h=n/this._tilesPerFace,u=this._tileIndex*h;r.setViewport(0,u,n,h);const c=this._ensureFrameBufferCube(n);r.bindFramebuffer(c);const m=D.TEXTURE_CUBE_MAP_POSITIVE_X+this._faceIndex;return c.setColorTextureTarget(m),r.gl.drawArrays(r.gl.TRIANGLE_STRIP,0,4),r.gl.flush(),r.setViewport(a.x,a.y,a.width,a.height),this.requestRender(),++this._tileIndex,4===this._faceIndex&&this._tileIndex===this._tilesPerFace?(this.running=this._dirty,this._faceIndex=0,this._tileIndex=0,this.running||(this.context.renderContext.bindParameters.cloudsFade.renderingStage=v.FADING)):this._tileIndex===this._tilesPerFace&&(++this._faceIndex,this._tileIndex=0),e.madeProgress(),q}};e([h({constructOnly:!0})],A.prototype,"context",void 0),e([h({constructOnly:!0})],A.prototype,"view",void 0),e([h({constructOnly:!0})],A.prototype,"requestRender",void 0),e([h()],A.prototype,"coverage",void 0),e([h()],A.prototype,"density",void 0),e([h()],A.prototype,"absorption",void 0),e([h()],A.prototype,"cloudSize",void 0),e([h()],A.prototype,"detailSize",void 0),e([h()],A.prototype,"smoothness",void 0),e([h()],A.prototype,"cloudHeight",void 0),e([h()],A.prototype,"raymarchingSteps",void 0),e([h()],A.prototype,"running",void 0),A=e([u("esri.views.3d.environment.CloudsGenerator")],A);const B=[g(1,0,0),g(-1,0,0),g(0,1,0),g(0,-1,0),g(0,0,1)],H=[g(0,1,0),g(0,1,0),g(0,0,-1),g(0,0,1),g(0,1,0)],O=x();export{A as CloudsGenerator};
