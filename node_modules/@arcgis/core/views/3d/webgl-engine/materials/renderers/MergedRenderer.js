/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import{removeUnordered as t,filterInPlace as r}from"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import{someMap as i}from"../../../../../core/MapUtils.js";import{nextHighestPowerOfTwo as s}from"../../../../../core/mathUtils.js";import{disposeMaybe as o}from"../../../../../core/maybe.js";import{NestedMap as a}from"../../../../../core/NestedMap.js";import n from"../../../../../core/PooledArray.js";import{property as l}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/Logger.js";import{subclass as u}from"../../../../../core/accessorSupport/decorators/subclass.js";import{multiply as h,invert as c,transpose as f}from"../../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as d}from"../../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{glLayout as m}from"../../../support/buffer/glUtil.js";import{ShaderOutput as g}from"../../core/shaderLibrary/ShaderOutput.js";import{SyncPrepareRenderPlugin as p}from"../../effects/RenderPlugin.js";import{GLMaterials as y}from"../../lib/GLMaterials.js";import{DirtyState as _}from"../../lib/ModelDirtyTypes.js";import{RenderSlot as b}from"../../lib/RenderSlot.js";import{assert as v,setMatrixTranslation3 as w}from"../../lib/Util.js";import{DrawParameters as C}from"../DrawParameters.js";import{BufferRange as O,mergeAdjacentRanges as A}from"./BufferRange.js";import{Instance as E}from"./Instance.js";import{PerBufferData as B,hasVao as H}from"./PerBufferData.js";import{PerOriginData as D}from"./PerOriginData.js";import{VaoCache as R}from"./VaoCache.js";let S=class extends p{constructor(e){super(e),this._vaoCache=null,this._glMaterials=null,this._bufferWriter=null,this._dataByOrigin=new Map,this._hasHighlights=!1,this._hasOccludees=!1,this._produces=new Map,this.drapedPriority=0}destroy(){this._glMaterials=o(this._glMaterials),this._dataByOrigin.forEach((e=>e.dispose())),this._dataByOrigin.clear(),this._vaoCache=o(this._vaoCache)}initialize(){this.material.produces.forEach(((e,t)=>{this._produces.set(t,(t=>!(0===this._dataByOrigin.size||!(t!==g.Highlight&&t!==g.ShadowHighlight||this._hasHighlights))&&e(t)))}))}get produces(){return this._produces}initializeRenderContext(e,t){const{rctx:r}=e.renderContext;this._glMaterials=new y(this.material,t??e.materials),this._bufferWriter=this.material.createBufferWriter(),this._vaoCache=new R(r,this.material.vertexAttributeLocations,m(this._bufferWriter.vertexBufferLayout))}uninitializeRenderContext(){}get hasOccludees(){return this._hasOccludees}get isDecoration(){return this.material.parameters.isDecoration}queryRenderOccludedState(e){return this.material.queryRenderOccludedState(e)}get materialReference(){return this.material}get numGeometries(){let e=0;return this._dataByOrigin.forEach((t=>e+=t.buffers.reduce(((e,t)=>e+t.instances.size),0))),e}get usedMemory(){let e=0;return this._dataByOrigin.forEach((t=>e+=t.buffers.reduce(((e,t)=>e+t.vao.usedMemory),0))),e}forEachGeometry(e){this._dataByOrigin.forEach((t=>t.buffers.forEach((t=>t.instances.forEach((t=>e(t.geometry)))))))}modify(e){this._updateGeometries(e.updates),this._addAndRemoveGeometries(e.adds,e.removes),this._updateDrawCommands()}_updateGeometries(e){const t=this._bufferWriter;if(null===t)return;const r=t.vertexBufferLayout.stride/4;for(const i of e){const e=i.renderGeometry,s=this._dataByOrigin.get(e.localOrigin.id),o=s?.findBuffer(e.id);if(null==o)return;const a=o.instances.get(e.id);if(i.updateType&(_.GEOMETRY|_.TRANSFORMATION)){const i=U(t.elementCount(a.geometry.geometry)*r),s=t.vertexBufferLayout.createView(i.buffer);this._writeGeometry(e,s,0),o.vao.vertexBuffers.geometry.setSubData(i,a.from*r,0,a.numElements*r)}i.updateType&(_.HIGHLIGHT|_.OCCLUDEE|_.VISIBILITY)&&(o.drawCommandsDirty=!0)}}_computeDeltas(e,t){const r=new a;for(const i of e){const e=i.localOrigin;if(null==e)continue;let t=r.get(e.id,null);null==t&&(t=new x(e.vec3),r.set(e.id,null,t)),t.changes.push(i)}for(const i of t){const e=i.localOrigin;if(null==e)continue;const t=this._dataByOrigin.get(e.id),s=t?.findBuffer(i.id);if(null==s)continue;let o=r.get(e.id,s);null==o&&(o=new x(e.vec3),r.set(e.id,s,o)),o.changes.push(i)}return r}_addAndRemoveGeometries(e,r){if(null===this._bufferWriter||null===this._vaoCache)return;const{_bufferWriter:i,_dataByOrigin:s}=this,o=i.vertexBufferLayout.stride/4,a=this._computeDeltas(e,r);a.forEach(((e,r)=>{const n=e.get(null),l=null!=n?n.changes:[];a.delete(r,null);let u=s.get(r);if(e.forEach(((e,n)=>{if(a.delete(r,n),null==n)return void v(!1,"No VAO for removed geometries");if(n.instances.size===e.changes.length)return this._vaoCache.deleteVao(n.vao),t(u.buffers,n),void(0===u.buffers.length&&0===l.length&&s.delete(r));const h=n.numElements,c=n.vao.byteSize/4,f=l.reduce(((e,t)=>e+i.elementCount(t.geometry)),0),d=e.changes.reduce(((e,t)=>e+i.elementCount(t.geometry)),0),m=Math.min((h+f-d)*o,z),g=m>c;m>G&&m<c/2?(e.changes.forEach((({id:e})=>n.deleteInstance(e))),n.instances.forEach((({geometry:e})=>l.push(e))),this._vaoCache.deleteVao(n.vao),t(u.buffers,n)):g?this._applyAndRebuild(n,l,e):this._applyRemoves(n,e)})),l.length>0)for(null==u&&(u=new D(n.origin),s.set(r,u)),u.buffers.forEach((e=>this._applyAdds(e,l)));l.length>0;)u.buffers.push(this._applyAndRebuild(new B,l,null))}))}_updateDrawCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach((e=>{e.buffers.forEach((e=>{e.drawCommandsDirty&&(e.hasHiddenInstances=!1,e.hasHighlights=!1,e.hasOccludees=!1,i(e.instances,(t=>(e.updateDrawState(t),e.hasHiddenInstances&&e.hasHighlights&&e.hasOccludees))),e.updateDrawCommands(this._bufferWriter.vertexBufferLayout.stride)),this._hasHighlights=this._hasHighlights||e.hasHighlights,this._hasOccludees=this._hasOccludees||e.hasOccludees}))}))}_applyAndRebuild(e,t,r){if(null!=r)for(const d of r.changes)e.deleteInstance(d.id);const i=this._bufferWriter,s=i.vertexBufferLayout.stride,o=s/4,a=Math.floor(z/o);let n=e.numElements;for(;t.length>0;){const r=t.pop(),s=i.elementCount(r.geometry);if(n+s>a&&n>0){t.push(r);break}n+=s;const o=new E(r,0,0);v(null==e.instances.get(r.id)),e.addInstance(r.id,o)}const l=n*o,u=U(l),h=i.vertexBufferLayout.createView(u.buffer);let c=0;e.hasHiddenInstances=!1,e.hasHighlights=!1,e.hasOccludees=!1,e.instances.forEach(((t,r)=>{this._writeGeometry(t.geometry,h,c);const s=c;c+=i.elementCount(t.geometry.geometry),e.updateInstance(r,s,c),e.updateDrawState(t)})),this._vaoCache.deleteVao(e.vao),e.vao=this._vaoCache.newVao(q(l)),e.vao.vertexBuffers.geometry.setSubData(u,0,0,c*o),e.holes.clear();const f=e.holes.pushNew();return f.from=c,f.to=Math.floor(e.vao.byteSize/s),e.updateDrawCommands(s),e}_applyRemoves(e,t){if(0===t.changes.length||null===this._bufferWriter)return;for(const a of t.changes){const t=a.id,r=e.instances.get(t);if(!r)continue;e.deleteInstance(t);const i=T.back();if(i){if(i.to===r.from){i.to=r.to;continue}if(i.from===r.to){i.from=r.from;continue}}const s=T.pushNew();s.from=r.from,s.to=r.to}A(T);const r=this._bufferWriter.vertexBufferLayout.stride/4,i=T.reduce(((e,t)=>Math.max(e,t.numElements)),0)*r,s=U(i);s.fill(0,0,i);const o=e.vao.vertexBuffers.geometry;T.forAll((e=>o.setSubData(s,e.from*r,0,e.numElements*r))),e.holes.pushArray(T.data,T.length),T.forAll(((e,t)=>T.data[t]=null)),T.clear(),e.drawCommandsDirty=!0}_applyAdds(e,t){if(0===t.length||null===this._bufferWriter)return;if(!H(e))return void this._applyAndRebuild(e,t,null);const i=this._bufferWriter,s=i.vertexBufferLayout.stride/4,o=e.numElements,a=t.reduce(((e,t)=>e+i.elementCount(t.geometry)),0),n=Math.min((o+a)*s,z),l=4*n;if(e.vao.byteSize<q(z-G)&&l>e.vao.byteSize)return void this._applyAndRebuild(e,t,null);A(e.holes);const u=new Array;for(const r of t){const t=i.elementCount(r.geometry),s=M(e.holes,t);u.push(s)}const h=e.vao.vertexBuffers.geometry;let c=0,f=0,d=0;const m=U(n),g=i.vertexBufferLayout.createView(m.buffer);t.forEach(((t,r)=>{const o=u[r];if(null==o)return;if(!(d===o)){const e=d-f;e>0&&h.setSubData(m,f*s,0,e*s),f=o,c=0}const a=i.elementCount(t.geometry);this._writeGeometry(t,g,c),c+=a,d=o+a;const n=new E(t,o,o+a);v(null==e.instances.get(t.id)),e.addInstance(t.id,n),e.drawCommandsDirty=!0}));const p=d-f;p>0&&h.setSubData(m,f*s,0,p*s),r(t,((e,t)=>null==u[t]))}_writeGeometry(e,t,r){if(null===this._bufferWriter)return;const i=e.localOrigin.vec3;w(j,-i[0],-i[1],-i[2]);const s=h(L,j,e.transformation);c(I,s),f(I,I),this._bufferWriter.write(s,I,e.geometry,t,r)}updateAnimation(e){return this.material.update(e)}prepareTechnique(e){if(!this.material.shouldRender(e))return null;const{output:t,bindParameters:r}=e,i=this.material.produces.get(r.slot);if(!i?.(t))return null;const s=t===g.Highlight||t===g.ShadowHighlight;if(s&&!this._hasHighlights)return null;const o=t===g.ShadowExcludeHighlight,a=!(s||o);for(const n of this._dataByOrigin.values())for(const i of n.buffers){if(s&&!i.hasHighlights)continue;const n=(s?i.drawCommandsHighlight:o&&i.needsMultipleCommands()?i.drawCommandsShadowHighlightRest:i.drawCommandsDefault)||null,l=a&&i.drawCommandsOccludees||null;if(n?.length||l?.length){const i=this._glMaterials.load(e.rctx,r.slot,t),s=null!=i?i.beginSlot(r):null;if(null!=s)return s}}return null}renderNode(e,t){const{output:r,bindParameters:i}=e,s=r===g.Highlight||r===g.ShadowHighlight,o=r===g.ShadowExcludeHighlight,a=!(s||o),n=i.slot===b.OCCLUDER_MATERIAL,l=i.slot===b.TRANSPARENT_OCCLUDER_MATERIAL,u=e.rctx;u.runAppleAmdDriverHelper(),u.bindTechnique(t,i,this.material.parameters);for(const h of this._dataByOrigin.values())for(const e of h.buffers){if(s&&!e.hasHighlights)continue;const r=(s?e.drawCommandsHighlight:o&&e.needsMultipleCommands()?e.drawCommandsShadowHighlightRest:e.drawCommandsDefault)||null,c=a&&e.drawCommandsOccludees||null;if(r?.length||c?.length){t.program.bindDraw(new C(h.origin),i,this.material.parameters),t.ensureAttributeLocations(e.vao),u.bindVAO(e.vao),r?.length&&(u.setPipelineState(t.getPipeline(!1,n,l)),r.forAll((e=>u.drawArrays(t.primitiveType,e.first,e.count)))),c?.length&&(u.setPipelineState(t.getPipeline(!0,n,l)),c.forAll((e=>u.drawArrays(t.primitiveType,e.first,e.count))))}}}get test(){}};e([l({constructOnly:!0})],S.prototype,"material",void 0),S=e([u("esri.views.3d.webgl-engine.materials.renderers.MergedRenderer")],S);class x{constructor(e){this.origin=e,this.changes=new Array}}function M(e,t){let r;if(!e.some((e=>!(e.numElements<t)&&(r=e,!0))))return null;const i=r.from;return r.from+=t,r.from>=r.to&&e.removeUnordered(r),i}const j=d(),L=d(),I=d(),T=new n({allocator:e=>e||new O,deallocator:null}),G=65536,W=4*G,P=1024,V=16777216,z=V/4;let N=new Float32Array(G);function U(e){return N.length<e&&(N=new Float32Array(e)),N}function q(e){const t=4*e;return t<=P?P:t<W?s(t):Math.max(Math.min(Math.ceil(1.5*t/W)*W,V),t)}export{S as MergedRenderer};
