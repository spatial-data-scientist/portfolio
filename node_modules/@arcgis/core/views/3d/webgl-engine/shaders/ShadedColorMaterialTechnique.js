/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import{ShaderOutput as t}from"../core/shaderLibrary/ShaderOutput.js";import{ReloadableShaderModule as r}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as o}from"../core/shaderTechnique/ShaderTechnique.js";import{parameter as i}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{CullFaceOptions as s}from"../lib/basicInterfaces.js";import{blendingDefault as n,oitBlending as a,oitDepthWrite as p,oitDrawBuffers as l,OITPolygonOffset as c}from"../lib/OrderIndependentTransparency.js";import{Program as u}from"../lib/Program.js";import{TransparencyPassType as d}from"../lib/TransparencyPassType.js";import{VertexAttribute as h}from"../lib/VertexAttribute.js";import{DefaultTechniqueConfiguration as m}from"../materials/DefaultTechniqueConfiguration.js";import{S as f}from"../../../../chunks/ShadedColorMaterial.glsl.js";import{CompareFunction as b}from"../../../webgl/enums.js";import{makePipelineState as y,cullingParams as S,defaultDepthWriteParams as g,defaultColorWriteParams as T}from"../../../webgl/renderState.js";class j extends o{initializeProgram(e){return new u(e.rctx,j.shader.get().build(this.configuration),E)}_setPipelineState(e){const r=this.configuration,o=e===d.NONE,i=e===d.FrontFace;return y({blending:r.output===t.Color&&r.transparent?o?n:a(e):null,culling:S(r.cullFace),depthTest:{func:i?b.LESS:r.shadingEnabled?b.LEQUAL:b.LESS},depthWrite:o?r.writeDepth?g:null:p(e),drawBuffers:l(e),colorWrite:T,polygonOffset:o||i?null:c})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}}j.shader=new r(f,(()=>import("./ShadedColorMaterial.glsl.js")));class v extends m{constructor(){super(...arguments),this.output=t.Color,this.cullFace=s.None,this.transparencyPassType=d.NONE,this.hasSlicePlane=!1,this.transparent=!1,this.writeDepth=!0,this.screenSizeEnabled=!0,this.shadingEnabled=!0,this.multipassEnabled=!1,this.cullAboveGround=!1}}e([i({count:t.COUNT})],v.prototype,"output",void 0),e([i({count:s.COUNT})],v.prototype,"cullFace",void 0),e([i({count:d.COUNT})],v.prototype,"transparencyPassType",void 0),e([i()],v.prototype,"hasSlicePlane",void 0),e([i()],v.prototype,"transparent",void 0),e([i()],v.prototype,"writeDepth",void 0),e([i()],v.prototype,"screenSizeEnabled",void 0),e([i()],v.prototype,"shadingEnabled",void 0),e([i()],v.prototype,"multipassEnabled",void 0),e([i()],v.prototype,"cullAboveGround",void 0),e([i({constValue:!1})],v.prototype,"occlusionPass",void 0);const E=new Map([[h.POSITION,0],[h.NORMAL,1],[h.OFFSET,2]]);export{j as ShadedColorMaterialTechnique,v as ShadedColorMaterialTechniqueConfiguration,E as vertexAttributeLocations};
