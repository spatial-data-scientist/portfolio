/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import t from"../../../core/Logger.js";import{fromMat4 as e}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{create as r}from"../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{fromRotationTranslationScaleOrigin as o,multiply as i,getScaling as n,scale as s,getTranslation as a,fromRotation as l}from"../../../core/libs/gl-matrix-2/math/mat4.js";import{create as c}from"../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{setAxisAngle as m}from"../../../core/libs/gl-matrix-2/math/quat.js";import{create as f}from"../../../core/libs/gl-matrix-2/factories/quatf64.js";import{s as p,i as u,t as g,h as x}from"../../../chunks/vec32.js";import{ONES as j,ZEROS as h,create as v}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import b from"../../Point.js";import{getSphericalPCPF as A}from"../../spatialReferenceEllipsoidUtils.js";import{computeTranslationToOriginAndRotation as R}from"../../projection/computeTranslationToOriginAndRotation.js";import{projectPointToVector as d}from"../../projection/projectPointToVector.js";import{create as y,angleRad as w,axis as F,fromMatrix as S}from"../axisAngleDegrees.js";import T from"../MeshTransform.js";import{isMeshWithRelativeVertexSpace as U}from"../meshVertexSpaceUtils.js";import{performGlobalOperation as q}from"./geographicUtils.js";import{logProjectionError as C,loadProjectErrorMessage as k,projectToPCPF as z,projectNormalToPCPF as L,projectTangentToPCPF as M,projectFromPCPF as P,projectNormalFromPCPF as V,projectTangentFromPCPF as D}from"./projection.js";import{projectPointToVertexSpace as E}from"./vertexSpaceConversion.js";const O=()=>t.getLogger("esri.geometry.support.meshUtils.rotate");function B(t,e,r){if(!t.vertexAttributes?.position||0===e[3])return;const{spatialReference:o,vertexSpace:i}=t,n=r?.origin??t.anchor,s=r?.geographic,a=q(O,i,o,s);U(t)?G(t,e,n):a?H(t,e,n):I(t,e,n)}function G(t,e,r){t.transform??=new T;const{vertexSpace:l,transform:c,spatialReference:f}=t,[g,x,A]=l.origin,R=new b({x:g,y:x,z:A,spatialReference:f}),d=K;if(R.equals(r))p(d,0,0,0);else if(!E(d,r,t))return void C(O(),r.spatialReference,f,k);m(Z,F(e),w(e));const y=o(N,Z,h,j,d),{localMatrix:U}=c,q=i(N,y,U);c.scale=n(v(),q),s(q,q,u(K,c.scale));const z=c.rotationAxis;c.rotation=S(q),0===c.rotationAngle&&(c.rotationAxis=z),c.translation=a(v(),q)}function H(t,r,o){const i=t.spatialReference,n=A(i),s=Y;if(!d(o,s,n)&&(C(O(),o.spatialReference,n,"Falling back to mesh origin"),!d(t.origin,s,n)))return void C(O(),t.origin.spatialReference,n);const a=t.vertexAttributes.position,l=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,m=new Float64Array(a.length),f=null!=l?new Float32Array(l.length):null,p=null!=c?new Float32Array(c.length):null;R(n,s,W,n),e(X,W);const u=Q;g(F(Q),F(r),X),u[3]=r[3],z(a,i,m)&&(null==l||null==f||L(l,a,m,i,f))&&(null==c||null==p||M(c,a,m,i,p))?(J(m,u,3,s),P(m,a,i)&&(null==l||null==f||(J(f,u,3),V(f,a,m,i,l)))&&(null==c||null==p||(J(p,u,4),D(p,a,m,i,c)))?t.vertexAttributesChanged():C(O(),n,i)):C(O(),i,n)}function I(t,e,r){const o=Y;if(!d(r,o,t.spatialReference)){const e=t.origin;return o[0]=e.x,o[1]=e.y,o[2]=e.z,void C(O(),r.spatialReference,t.spatialReference,k)}J(t.vertexAttributes.position,e,3,o),J(t.vertexAttributes.normal,e,3),J(t.vertexAttributes.tangent,e,4),t.vertexAttributesChanged()}function J(t,e,r,o=h){if(null!=t){l(W,w(e),F(e));for(let e=0;e<t.length;e+=r){for(let r=0;r<3;r++)K[r]=t[e+r]-o[r];x(K,K,W);for(let r=0;r<3;r++)t[e+r]=K[r]+o[r]}}}const K=v(),N=c(),Q=y(),W=c(),X=r(),Y=v(),Z=f();export{B as rotate};
