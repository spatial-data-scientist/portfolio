/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../renderers/PointCloudClassBreaksRenderer.js";import"../../renderers/PointCloudRenderer.js";import"../../renderers/PointCloudRGBRenderer.js";import"../../renderers/PointCloudStretchRenderer.js";import e from"../../renderers/PointCloudUniqueValueRenderer.js";import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import r from"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import i from"../../core/Error.js";import{clone as n}from"../../core/lang.js";import{fetchMessageBundle as o}from"../../intl/messages.js";import{isTimeOnlyField as l}from"../../layers/support/fieldUtils.js";import{LegendOptions as s}from"../../renderers/support/LegendOptions.js";import{createUniqueValueLabel as t,calculateDateFormatInterval as a,dateFormatIntervalOptions as p}from"../../renderers/support/utils.js";import u from"../../renderers/support/pointCloud/ColorUniqueValueInfo.js";import d from"../heuristics/outline.js";import m from"../heuristics/sizeRange.js";import{errorCallback as c,getPointSizeAlgorithm as y,verifyBasicFieldValidity as f,isValidPointSize as b,createColors as h,getSymbolSizeFromScheme as v,getSymbolOutlineFromScheme as g,createSymbol as w,getBasemapInfo as T}from"./support/utils.js";import j from"../statistics/uniqueValues.js";import{verifyBinningParams as z}from"../support/binningUtils.js";import{getFieldsList as E,fieldDelimiter as I,isAnyDateField as x}from"../support/utils.js";import{binningCapableLayerTypes as V,featureCapableLayerTypes as M,createLayerAdapter as S,getLayerTypeLabels as C,LayerType as R}from"../support/adapters/support/layerUtils.js";import{cloneScheme as q,getSchemes as O}from"../symbology/type.js";async function U(e){if(!e?.layer||!e.field&&!e.valueExpression)throw new i("type-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("type-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&z(e,"type-renderer");const r={...e,layer:e.layer};r.symbolType=r.symbolType||"2d",r.numTypes=null==r.numTypes?10:r.numTypes,r.defaultSymbolEnabled??=!0,r.sortBy??="count",r.sortEnabled??=!0,r.statistics=n(r.statistics);const o=e.forBinning?V:M,l=S(r.layer,o,e.forBinning);if(!l)throw new i("type-renderer:invalid-parameters","'layer' must be one of these types: "+C(o).join(", "));r.layer=l;const s=null!=r.signal?{signal:r.signal}:null;await l.load(s);const t=l.geometryType;if(r.outlineOptimizationEnabled="polygon"===t&&r.outlineOptimizationEnabled,r.sizeOptimizationEnabled=("point"===t||"multipoint"===t||"polyline"===t)&&r.sizeOptimizationEnabled,"mesh"===t)r.symbolType="3d-volumetric",r.colorMixMode=r.colorMixMode||"replace",r.edgesType=r.edgesType||"none";else{if("3d-volumetric-uniform"===r.symbolType&&"point"!==t)throw new i("type-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new i("type-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const a=await E({field:r.field,field2:r.field2,field3:r.field3,valueExpression:r.valueExpression}),p=f(l,a,"type-renderer:invalid-parameters");if(p)throw p;return r}async function P(e){if(!e?.layer||!e.field)throw new i("type-point-cloud-class-renderer:missing-parameters","'layer' and 'field' parameters are required");const r={...e,layer:e.layer};r.statistics=n(r.statistics);const o=[R.PointCloudLayer],l=S(r.layer,o);if(!l)throw new i("type-point-cloud-class-renderer:invalid-parameters","'layer' must be one of these types: "+C(o).join(", "));if(r.layer=l,r.density=r.density||25,r.size=r.size||"100%",!b(r.size))throw new i("type-point-cloud-class-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const s=null!=r.signal?{signal:r.signal}:null;await l.load(s);const t=await E({field:r.field}),a=f(l,t,"type-point-cloud-class-renderer:invalid-parameters");if(a)throw a;return r}async function B(e){let r=e.typeScheme,i=null,n=null;const o=await T(e.basemap,e.view);if(i=null!=o.basemapId?o.basemapId:null,n=null!=o.basemapTheme?o.basemapTheme:null,r)return{scheme:q(r),basemapId:i,basemapTheme:n};const l=O({basemapTheme:n,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return l&&(r=l.primaryScheme,i=l.basemapId,n=l.basemapTheme),{scheme:r,basemapId:i,basemapTheme:n}}function D(e,r){let i;return i=e.label<r.label?-1:e.label>r.label?1:0,i}function Z(e,r){let i;return i=e.value<r.value?-1:e.value>r.value?1:0,i}function k(e,r){let i=r.count-e.count;return 0===i&&(i=D(e,r)),i}function L(e,r){let i=r.count-e.count;return 0===i&&(i=Z(e,r)),i}function F(e,r,i){let n;"count"===r?(n=L,i&&"codedValues"in i&&i.codedValues&&(n=k)):"value"===r&&(n=Z,i&&"codedValues"in i&&i.codedValues&&(n=D)),n&&e.sort(n)}async function A(e,i,n,u){const d=await o("esri/smartMapping/t9n/smartMapping"),{field:m,field2:c,field3:y}=i,f=e.uniqueValueInfos,b=i.layer,T=m?b.getField(m):null,j=T?b.getFieldDomain(T.name):null,z=-1===i.numTypes?f.length:i.numTypes,E=b.geometryType,V=await B({basemap:i.basemap,geometryType:E,typeScheme:i.typeScheme,worldScale:!!i.symbolType?.includes("3d-volumetric"),view:i.view}),M=V.scheme,S=new r({field:m,field2:c,field3:y,fieldDelimiter:m&&c?I:null}),C=[],R=[],O={value:null,domain:j,fieldInfo:T};f.forEach(((e,r)=>{O.value=e.value,e.label=t(O);const i=e.value;(null===i||"string"==typeof i&&i.toLowerCase().includes("<null>"))&&C.unshift(r)}));for(const r of C)R.unshift(f.splice(r,1)[0]);if(!1!==i.sortEnabled&&F(f,i.sortBy,j),T&&(x(T)||l(T))){const e=f.filter(((e,r)=>r<z)).map((e=>e.value)),r=l(T)?null:a(e),n=r?p[r]:void 0;if(O.dateFormatOptions={fieldType:T.type,format:n},i.view){const e=b.layer;O.dateFormatOptions.timeZoneOptions={layerTimeZone:"preferredTimeZone"in e?e.preferredTimeZone:null,viewTimeZone:i.view.timeZone,datesInUnknownTimezone:"datesInUnknownTimezone"in e&&e.datesInUnknownTimezone}}}const U=n?.opacity;let P=h(M.colors,f.length);const D=v(M,E),Z=g(M,E,U);f.forEach(((e,r)=>{O.value=e.value,e.label=t(O),e.symbol=w(E,{type:i.symbolType,color:P[r],size:D,outline:Z,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}})})),i.valueExpression&&(S.valueExpression=i.valueExpression,S.valueExpressionTitle=i.valueExpressionTitle),i.legendOptions&&(S.legendOptions=new s(i.legendOptions)),P=h(M.colors,z);for(let r=0;r<z;r++){const e=f[r];e&&S.addUniqueValueInfo({value:e.value,label:e.label,symbol:w(E,{type:i.symbolType,color:P[r],size:D,outline:Z,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}})})}i.defaultSymbolEnabled&&(S.defaultSymbol=w(E,{type:i.symbolType,color:M.noDataColor,size:D,outline:Z,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}}),S.defaultLabel=d.other);for(const r of R)r.symbol=w(E,{type:i.symbolType,color:M.noDataColor,size:D,outline:Z,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}}),f.push(r);const k=[],L=S.uniqueValueInfos?.length??0,A=L===f.length?-1:L;if(A>-1)for(let r=A;r<f.length;r++)k.push({...f[r]});return n?.visualVariables?.length&&(S.visualVariables=n.visualVariables.map((e=>e.clone()))),u?.minSize&&(S.visualVariables?S.visualVariables.push(u.minSize):S.visualVariables=[u.minSize]),{renderer:S,uniqueValueInfos:f,excludedUniqueValueInfos:k,typeScheme:q(M),basemapId:V.basemapId,basemapTheme:V.basemapTheme}}async function G(e,r){const i=e.uniqueValueInfos,n=await B({basemap:"gray",theme:"point-cloud-class",geometryType:"point",typeScheme:r}),o=n?.scheme,l="point-cloud-class"===o?.theme,s=l?o.colors:h(o?.colors??[],i.length);return F(i,"value"),i.map(((e,r)=>{const i=e.value;let n=null;return l?(n=s[i],n||(n=s[s.length-1])):n=s[r],new u({values:[i],color:n,label:e.label})}))}async function H(e){const r=await U(e),{layer:i,view:n,signal:o}=r,l={layer:i,field:r.field,field2:r.field2,field3:r.field3,valueExpression:r.valueExpression,returnAllCodedValues:r.returnAllCodedValues,view:n,signal:o},[s,t,a]=await Promise.all([null!=r.statistics?r.statistics:j(l),r.outlineOptimizationEnabled?d({layer:i,view:n,signal:o}).catch(c):null,r.sizeOptimizationEnabled?m({layer:i,view:n,signal:o}).catch(c):null]);return A(s,r,t,a)}async function J(r){const i=await P(r),n=null!=i.statistics?i.statistics:await j({layer:i.layer,field:i.field,signal:i.signal});return{renderer:new e({field:i.field,pointsPerInch:i.density??void 0,pointSizeAlgorithm:y(i.size),colorUniqueValueInfos:await G(n,i.typeScheme)})}}export{J as createPCClassRenderer,H as createRenderer};
