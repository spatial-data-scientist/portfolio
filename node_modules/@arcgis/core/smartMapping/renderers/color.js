/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../renderers/PointCloudClassBreaksRenderer.js";import"../../renderers/PointCloudRenderer.js";import e from"../../renderers/PointCloudRGBRenderer.js";import o from"../../renderers/PointCloudStretchRenderer.js";import"../../renderers/PointCloudUniqueValueRenderer.js";import i from"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import r from"../../core/Error.js";import{ensureClass as a}from"../../core/accessorSupport/ensureType.js";import{fetchMessageBundle as n}from"../../intl/messages.js";import{substitute as l}from"../../intl/substitute.js";import s from"../../renderers/support/AuthoringInfo.js";import t from"../../renderers/support/AuthoringInfoVisualVariable.js";import{createColorStops as m,setLabelsForClassBreaks as d}from"../../renderers/support/utils.js";import u from"../../renderers/visualVariables/ColorVariable.js";import p from"../../renderers/visualVariables/support/ColorStop.js";import c from"../../renderers/visualVariables/support/VisualVariableLegendOptions.js";import y from"../heuristics/ageUnit.js";import f from"../heuristics/outline.js";import h from"../heuristics/sizeRange.js";import{getSummaryStatistics as b,errorCallback as w,getClassBreaks as v,getPointSizeAlgorithm as g,formatDate as T,updateAgeRendererAuthoringInfoVV as x,verifyBasicFieldValidity as V,isValidPointSize as E,createColors as z,getDefaultDataRange as S,createDefaultStopValues as M,createStopValues as I,getDataRange as j,createDataValues as q,createSymbol as C,getSymbolSizeFromScheme as O,getSymbolOutlineFromScheme as B,getBasemapInfo as k}from"./support/utils.js";import{getAgeExpressions as U,verifyDates as R,supportedAgeUnits as F}from"../statistics/support/ageUtils.js";import{verifyBinningParams as P}from"../support/binningUtils.js";import{isAnyDateField as D,getFieldsList as L,getNormalizationType as A}from"../support/utils.js";import{binningCapableLayerTypes as G,featureCapableLayerTypes as W,createLayerAdapter as $,getLayerTypeLabels as H,LayerType as _}from"../support/adapters/support/layerUtils.js";import{cloneScheme as J,getSchemes as K,getSchemeById as N}from"../symbology/color.js";const Q="high-to-low",X=2**53-1,Y=5;async function Z(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new r("color-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new r("color-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&P(e,"color-visual-variable");const o={...e},i=e.forBinning?G:W,a=$(o.layer,i,e.forBinning);if(!a)throw new r("color-visual-variable:invalid-parameters","'layer' must be one of these types: "+H(i).join(", "));o.layer=a;const n=null!=o.signal?{signal:o.signal}:null;await a.load(n);if("mesh"!==a.geometryType&&o.worldScale&&(!o.view||"3d"!==o.view.type))throw new r("color-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true");const l=await L({field:o.field,normalizationField:o.normalizationField,valueExpression:o.valueExpression}),s=V(a,l,"color-visual-variable:invalid-parameters");if(s)throw s;return o}async function ee(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new r("color-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new r("color-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&P(e,"color-continuous-renderer");const o={...e};o.symbolType=o.symbolType||"2d",o.defaultSymbolEnabled??=!0;const i=e.forBinning?G:W,a=$(o.layer,i,e.forBinning);if(!a)throw new r("color-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+H(i).join(", "));o.layer=a;const n=null!=o.signal?{signal:o.signal}:null;await a.load(n);const l=a.geometryType;if(o.outlineOptimizationEnabled="polygon"===l&&o.outlineOptimizationEnabled,o.sizeOptimizationEnabled=("point"===l||"multipoint"===l||"polyline"===l)&&o.sizeOptimizationEnabled,"mesh"===l)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else{if("3d-volumetric-uniform"===o.symbolType&&"point"!==l)throw new r("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.includes("3d-volumetric")&&(!o.view||"3d"!==o.view.type))throw new r("color-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const s=await L({field:o.field,normalizationField:o.normalizationField,valueExpression:o.valueExpression}),t=V(a,s,"color-continuous-renderer:invalid-parameters");if(t)throw t;return o}async function oe(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new r("color-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new r("color-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&P(e,"color-class-breaks-renderer");const o={...e};o.symbolType=o.symbolType||"2d",o.defaultSymbolEnabled??=!0,o.classificationMethod??="equal-interval",o.normalizationType=A(o);const i=e.forBinning?G:W,a=$(o.layer,i,e.forBinning);if(!a)throw new r("color-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+H(i).join(", "));o.layer=a;if(!(null!=o.minValue&&null!=o.maxValue)&&(null!=o.minValue||null!=o.maxValue))throw new r("color-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const n=null!=o.signal?{signal:o.signal}:null;await a.load(n);const l=a.geometryType;if(o.outlineOptimizationEnabled="polygon"===l&&o.outlineOptimizationEnabled,"mesh"===l)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else{if("3d-volumetric-uniform"===o.symbolType&&"point"!==l)throw new r("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.includes("3d-volumetric")&&(!o.view||"3d"!==o.view.type))throw new r("color-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const s=await L({field:o.field,normalizationField:o.normalizationField}),t=V(a,s,"color-class-breaks-renderer:invalid-parameters");if(t)throw t;return o}function ie(e){const o={...e};delete o.basemap,delete o.colorScheme,delete o.legendOptions,delete o.symbolType,delete o.defaultSymbolEnabled,delete o.colorMixMode,delete o.edgesType;const i=o;return i.analyzeData=!(null!=o.minValue&&null!=o.maxValue),i}async function re(e){if(!e?.layer)throw new r("color-point-cloud-true-color-renderer:missing-parameters","'layer' parameter is required");const o={...e,layer:e.layer},i=[_.PointCloudLayer],a=$(o.layer,i);if(!a)throw new r("color-point-cloud-true-color-renderer:invalid-parameters","'layer' must be one of these types: "+H(i).join(", "));if(o.layer=a,o.density=o.density||25,o.size=o.size||"100%",!E(o.size))throw new r("color-point-cloud-true-color-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const n=null!=o.signal?{signal:o.signal}:null;return await a.load(n),o}async function ae(e){if(!e?.layer||!e.field)throw new r("color-point-cloud-continuous-renderer:missing-parameters","'layer' and 'field' parameters are required");const o=e.field.toLowerCase();if("intensity"!==o&&"elevation"!==o)throw new r("color-point-cloud-continuous-renderer:invalid-parameters","'field' should be either 'intensity' or 'elevation'");const i={...e,layer:e.layer,field:e.field},a=[_.PointCloudLayer],n=$(i.layer,a);if(!n)throw new r("color-point-cloud-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+H(a).join(", "));if(i.layer=n,i.density=i.density||25,i.size=i.size||"100%",!E(i.size))throw new r("color-point-cloud-continuous-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const l=null!=i.signal?{signal:i.signal}:null;return await n.load(l),i}function ne(e){const o={...e},i=!!o.symbolType?.includes("3d-volumetric");delete o.symbolType,delete o.defaultSymbolEnabled,delete o.colorMixMode,delete o.edgesType;const r=o;return r.worldScale=i,r}async function le(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new r("color-age-renderer:missing-parameters","'layer', 'view', startTime', 'endTime' parameters are required");const o={...e};o.symbolType=o.symbolType||"2d",o.defaultSymbolEnabled??=!0;const i=$(o.layer,W);if(!i)throw new r("color-age-renderer:invalid-parameters","'layer' must be one of these types: "+H(W).join(", "));o.layer=i;const a=null!=o.signal?{signal:o.signal}:null;await i.load(a);const n=i.geometryType;if(o.outlineOptimizationEnabled="polygon"===n&&o.outlineOptimizationEnabled,o.sizeOptimizationEnabled=("point"===n||"multipoint"===n||"polyline"===n)&&o.sizeOptimizationEnabled,"mesh"===n)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else if("3d-volumetric-uniform"===o.symbolType&&"point"!==n)throw new r("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.includes("3d-volumetric")&&(!o.view||"3d"!==o.view.type))throw new r("color-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");const l=R(i,o.startTime,o.endTime,"color-age-renderer:invalid-parameters");if(l)throw l;if(o.unit&&!F.includes(o.unit))throw new r("color-age-renderer:invalid-unit",`Supported units are: ${F.join(", ")}`);return o}async function se(e,o){let i=e.colorScheme,r=null,a=null;const{view:n}=e,l=await k(e.basemap,n);if(r=null!=l.basemapId?l.basemapId:null,a=null!=l.basemapTheme?l.basemapTheme:null,i)return{scheme:J(i),basemapId:r,basemapTheme:a};const s=e.theme||Q,t=K({theme:s,basemapTheme:a,geometryType:e.geometryType,worldScale:e.worldScale,view:n});if(t)if(r=t.basemapId,a=t.basemapTheme,e.schemeId){const o=s+"/"+r+"/"+e.schemeId;i=N({id:o,geometryType:e.geometryType})}else i=t.primaryScheme;return{scheme:i,basemapId:r,basemapTheme:a}}async function te(e,o){const i=o.layer,a=await se({basemap:o.basemap,colorScheme:o.colorScheme,geometryType:i.geometryType,schemeId:"elevation"===o.field.toLowerCase()?"point-cloud-elevation-scheme":"point-cloud-intensity-scheme"}),n=a.scheme;if(!n)throw new r("color-point-cloud-continuous-renderer:insufficient-info","Unable to find color scheme");const l=z(n.colors,Y);if(l.length<Y)throw new r("color-point-cloud-continuous-renderer:insufficient-info","Color scheme does not have enough colors");const s=S(e,!1,!0),t=s?M(s[0],s[1],5):I(e);return{stops:m({values:t,isDate:!1,colors:l,labelIndexes:[0,2,4]}),basemapId:a.basemapId,basemapTheme:a.basemapTheme,statistics:e,defaultValuesUsed:!!s,colorScheme:J(n)}}async function me(e,o,i,n){const{field:l,theme:m}=e,d=await se({basemap:e.basemap,theme:e.theme,geometryType:i,colorScheme:e.colorScheme,worldScale:e.worldScale,view:e.view}),y=d.scheme;if(!y)throw new r("color-visual-variable:insufficient-info","Unable to find color scheme");const f=z(y.colors,Y);if(f.length<Y)throw new r("color-visual-variable:insufficient-info","Color scheme does not have enough colors");const h=y.id.includes("seq-"),b=j(o,m,n,!0),w=q(b,o,m,h),v=z(f,Y),g=new u({field:l??void 0,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationField:e.normalizationField,stops:w.map(((e,o)=>new p({value:e,color:v[o]}))),legendOptions:a(c,e.legendOptions)}),T=new t({type:"color",minSliderValue:null!=e.minValue?e.minValue:o.min,maxSliderValue:null!=e.maxValue?e.maxValue:o.max,theme:y.theme}),x=new s({visualVariables:[T]});return{basemapId:d.basemapId,basemapTheme:d.basemapTheme,visualVariable:g,statistics:o,defaultValuesUsed:b.defaultValuesUsed,colorScheme:J(y),authoringInfo:x}}async function de(e,o,r,a,l,s,t){const m=await n("esri/smartMapping/t9n/smartMapping"),{field:d,defaultSymbolEnabled:u}=t,p=J(e.colorScheme),c=o?.opacity,y=[e.visualVariable.clone()];o?.visualVariables?.length&&y.push(...o.visualVariables.map((e=>e.clone()))),r?.minSize&&y.push(r.minSize);return{renderer:new i({classBreakInfos:[{minValue:-X,maxValue:X,symbol:C(s,{type:t.symbolType,color:p.noDataColor,size:O(p,s),outline:B(p,s,c),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}})}],defaultLabel:u?m.other:null,defaultSymbol:u?C(s,{type:t.symbolType,color:p.noDataColor,size:O(p,s),outline:B(p,s,c),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}}):null,field:d,normalizationType:a,normalizationField:l,valueExpression:t.valueExpression,valueExpressionTitle:t.valueExpressionTitle,visualVariables:y,authoringInfo:e.authoringInfo&&e.authoringInfo.clone()}),visualVariable:e.visualVariable.clone(),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,colorScheme:J(e.colorScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}async function ue(e){const o=await Z(e),{view:i,field:r,valueExpression:a,minValue:n,maxValue:l,layer:s,normalizationField:t,signal:m,statistics:d}=o,u=t?"field":void 0,[p]=await Promise.all([d??b({layer:s,field:r,valueExpression:a,sqlExpression:o.sqlExpression,sqlWhere:o.sqlWhere,normalizationType:u,normalizationField:t,minValue:n,maxValue:l,view:i,signal:m})]),c=s,y=r&&"function"!=typeof r?c.getField(r):null;return me(o,p,c.geometryType,D(y))}function pe(e,o){const i=e.colorsForClassBreaks;let r;if(i&&i.length>0&&(i.some((e=>(e.numClasses===o&&(r=e.colors),!!r))),!r)){const e=i[i.length-1],a=o-e.numClasses;if(a>0){const o=e.colors[e.numClasses-1];r=e.colors.splice(0);for(let e=1;e<=a;e++)r.push(o)}}return r&&(r=z(r,r.length)),r}async function ce(e,o){const a=await n("esri/smartMapping/t9n/smartMapping"),l=e.layer,t=e.defaultSymbolEnabled,m=l.geometryType,u=e.classificationMethod,p="standard-deviation"===u,c=await se({basemap:e.basemap,geometryType:m,theme:p?"above-and-below":null,colorScheme:e.colorScheme,worldScale:!!e.symbolType?.includes("3d-volumetric"),view:e.view}),y=c.scheme,{result:f,outlineResult:h}=o,b=f.classBreakInfos,w=e.normalizationType;if(!y)throw new r("color-class-breaks-renderer:insufficient-info","Unable to find color scheme");const v=pe(y,b.length);if(!v||v.length!==b.length)throw new r("color-class-breaks-renderer:insufficient-info","Color scheme does not have enough colors");const g=h?.opacity,T=new i({classBreakInfos:b.map(((o,i)=>({minValue:o.minValue,maxValue:o.maxValue,symbol:C(m,{type:e.symbolType,color:v[i],size:O(y,m),outline:B(y,m,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}),label:o.label}))),defaultLabel:t?a.other:null,defaultSymbol:t?C(m,{type:e.symbolType,color:y.noDataColor,size:O(y,m),outline:B(y,m,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:w,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===w?f.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new s({type:"class-breaks-color",classificationMethod:u,standardDeviationInterval:e.standardDeviationInterval})});return p||d({classBreakInfos:T.classBreakInfos,classificationMethod:u,normalizationType:w,round:!0}),h?.visualVariables?.length&&(T.visualVariables=h.visualVariables.map((e=>e.clone()))),{renderer:T,colorScheme:J(y),classBreaksResult:f,defaultValuesUsed:o.defaultValuesUsed,basemapId:c.basemapId,basemapTheme:c.basemapTheme}}async function ye(e){const o=await ee(e),{layer:i,view:r,signal:a}=o,[n,l,s]=await Promise.all([ue(ne(o)),o.outlineOptimizationEnabled?f({layer:i,view:r,signal:a}).catch(w):null,o.sizeOptimizationEnabled?h({layer:i,view:r,signal:a}).catch(w):null]),t=o.normalizationField;return de(n,l,s,t?"field":void 0,t,i.geometryType,o)}async function fe(e){const o=await oe(e);return ce(o,await v(ie(o),o.outlineOptimizationEnabled))}function he(o){return re(o).then((o=>({renderer:new e({field:"RGB",pointsPerInch:o.density??void 0,pointSizeAlgorithm:g(o.size)})})))}async function be(e){const i=await ae(e),r=i.statistics??await b({layer:i.layer,field:i.field,signal:i.signal}),a=await te(r,i);return{renderer:new o({field:i.field,pointsPerInch:i.density??void 0,pointSizeAlgorithm:g(i.size),stops:a.stops}),basemapId:a.basemapId,basemapTheme:a.basemapTheme,statistics:a.statistics,defaultValuesUsed:a.defaultValuesUsed,colorScheme:a.colorScheme}}async function we(e){const o=await n("esri/smartMapping/t9n/smartMapping"),i=await le(e),{defaultSymbolEnabled:r,view:a,startTime:s,endTime:t,symbolType:m,colorMixMode:d,edgesType:u,minValue:p,maxValue:c,signal:b}=i,v=i.layer,[g,V,E]=await Promise.all([i.unit?{unit:i.unit,statistics:null}:y({view:a,layer:v,startTime:s,endTime:t,minValue:p,maxValue:c,signal:b}),i.outlineOptimizationEnabled?f({layer:v,view:a,signal:b}).catch(w):null,i.sizeOptimizationEnabled?h({layer:v,view:a,signal:b}).catch(w):null]),{unit:z,statistics:S}=g,M=U({layer:v,startTime:s,endTime:t,unit:z}).valueExpression,I=l(o[`ageInfo_${z}`],{unit:z,startTime:T(s,z,v,a),endTime:T(t,z,v,a)}),j=await ue(ne({layer:v,basemap:i.basemap,valueExpression:M,symbolType:m,statistics:S,legendOptions:{title:I},colorScheme:i.colorScheme,theme:i.theme,view:a,minValue:i.minValue,maxValue:i.maxValue,signal:b})),q={layer:v,valueExpression:M,defaultSymbolEnabled:r,symbolType:m,colorMixMode:d,edgesType:u},C=await de(j,V,E,null,null,v.geometryType,q),O=C.renderer.authoringInfo?.visualVariables;return O?.forEach((e=>x(e,s,t,z))),{...C,unit:z}}export{we as createAgeRenderer,fe as createClassBreaksRenderer,ye as createContinuousRenderer,be as createPCContinuousRenderer,he as createPCTrueColorRenderer,ue as createVisualVariable};
