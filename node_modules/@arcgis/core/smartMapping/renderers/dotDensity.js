/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import e from"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import r from"../../core/Error.js";import{getResolutionForScale as t}from"../../geometry/support/scaleUtils.js";import i from"../../renderers/support/AuthoringInfo.js";import s from"../heuristics/outline.js";import{roundValue as a}from"./support/dotDensityUtils.js";import{errorCallback as n,createColors as o,getSymbolOutlineFromScheme as l,verifyBasicFieldValidity as u,getBasemapInfo as m}from"./support/utils.js";import d from"../statistics/spatialStatistics.js";import p from"../statistics/summaryStatisticsForAttributes.js";import c from"../statistics/support/attributeDensity.js";import{verifyBinningParams as y}from"../support/binningUtils.js";import{getFieldsList as f}from"../support/utils.js";import{LayerType as b,binningCapableLayerTypes as g,createLayerAdapter as w,getLayerTypeLabels as h}from"../support/adapters/support/layerUtils.js";import{cloneScheme as v,getSchemes as S}from"../symbology/dotDensity.js";const j=500;async function V(e){const t=e.view;if(!(e?.layer&&t&&e.attributes?.length))throw new r("dot-density-renderer:missing-parameters","'layer', 'view' and 'attributes' parameters are required");if(e.attributes.length>8)throw new r("dot-density-renderer:invalid-parameters","Dot density renderer does not support more than 8 attributes");e.forBinning&&y(e,"dot-density-renderer");const i={...e,view:t,layer:e.layer,attributes:e.attributes},s=[b.FeatureLayer,b.OGCFeatureLayer,b.GeoJSONLayer,b.WFSLayer],a=e.forBinning?g:s,n=w(i.layer,a,e.forBinning);if(!n)throw new r("dot-density-renderer:invalid-parameters","'layer' must be one of these types: "+h(a).join(", "));i.layer=n,i.dotBlendingEnabled??=!0,i.dotValueOptimizationEnabled??=!0;const o=null!=i.signal?{signal:i.signal}:null;await Promise.all([t.when(),n.load(o)]);if("polygon"!==n.geometryType)throw new r("dot-density-renderer:not-supported","Dot density renderer is supported for polygon layers only");const l=[],m=i.attributes;for(const r of m){const e=await f({field:r.field,valueExpression:r.valueExpression});l.push(...e)}const d=u(n,l.filter(Boolean),"dot-density-renderer:invalid-parameters");if(d)throw d;return i}async function x(e){let r=e.dotDensityScheme,t=null,i=null;const s=await m(e.basemap,e.view);if(t=null!=s.basemapId?s.basemapId:null,i=null!=s.basemapTheme?s.basemapTheme:null,r)return{scheme:v(r),basemapId:t,basemapTheme:i};const a=S({numColors:e.attributes.length,basemapTheme:i});return a&&(r=a.primaryScheme,t=a.basemapId,i=a.basemapTheme),{scheme:r,basemapId:t,basemapTheme:i}}function E(e){return{dotValue:1,referenceScale:e.scale,minSliderValue:1,maxSliderValue:100}}async function D(e){const{view:r,layer:i,attributes:s,signal:n}=e,o=await i.getSampleFeatures({view:r,sampleSize:j,returnGeometry:!0,signal:n},"json"),[l,u]=await Promise.all([d({features:o,geometryType:i.geometryType}),p({layer:i,attributes:s,includeZeros:!1,includeNegatives:!1,view:r,signal:n})]),m=null!=l&&"avgSize"in l&&l.avgSize,c=u.avg;if(!m||!c)return E(r);const y=t(r.scale,r.spatialReference);return{dotValue:a(c/(m*m/(y*y)*.1))||1,referenceScale:r.scale,minSliderValue:1,maxSliderValue:a(c)}}async function T(e){const{view:r,layer:i,attributes:s,signal:n}=e,o=[];for(const t of s){const e=await f({field:t.field,valueExpression:t.valueExpression});o.push(...e)}const l=await i.getSampleFeatures({view:r,sampleSize:j,requiredFields:o,returnGeometry:!0,signal:n},"json"),{minDensity:u,maxDensity:m,avgDensity:d}=await c({features:l,attributes:s,includeZeros:!1,includeNegatives:!1,view:r});if(!d||!u||!m)return E(r);const p=t(r.scale,r.spatialReference),y=p*p,b=a(u*y),g=a(m*y);let w=a(d*y*10)||1;return w>g&&(w=g),{dotValue:w,referenceScale:r.scale,minSliderValue:b,maxSliderValue:g}}async function R(t){const a=await V(t),u=a.layer,m=u.geometryType,d=await x(a),p=d?.scheme;if(!p)throw new r("dot-density-renderer:insufficient-info","Unable to find dot-density scheme");const c=a.view,y={layer:u,view:c,attributes:a.attributes,signal:a.signal},f={layer:a.layer,view:c,signal:a.signal},[b,g]=await Promise.all([a.trueDensity?T(y):D(y),a.outlineOptimizationEnabled?s(f).catch(n):null]),{dotValue:w,referenceScale:h,minSliderValue:v,maxSliderValue:S}=b,j=o(p.colors,a.attributes.length),E=a.attributes.map(((e,r)=>({field:e.field,valueExpression:e.valueExpression,label:e.label,valueExpressionTitle:e.valueExpressionTitle,color:j[r]}))),R=new e({attributes:E,dotBlendingEnabled:a.dotBlendingEnabled,outline:g?l(p,m,g.opacity):null,dotValue:w,referenceScale:a.dotValueOptimizationEnabled?h:null,legendOptions:a.legendOptions});return g?.visualVariables.length&&(R.visualVariables=g.visualVariables.map((e=>e.clone()))),R.authoringInfo=new i({type:"dot-density",minSliderValue:v,maxSliderValue:S}),{renderer:R,dotDensityScheme:p,basemapId:d.basemapId,basemapTheme:d.basemapTheme}}export{R as createRenderer};
