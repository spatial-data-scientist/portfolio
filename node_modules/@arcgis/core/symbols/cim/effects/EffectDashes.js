/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{GeometryCursor as t}from"../../../geometry/GeometryCursor.js";import{collectPath as e,collectMultipath as s}from"../../../geometry/geometryCursorCollectUtils.js";import{getPathLength as r}from"../../../geometry/support/coordsUtils.js";import{PathEffectCursor as i}from"../CIMCursor.js";import{LineDashEnding as a}from"../enums.js";import{GeometryWalker as n,DashPattern as h}from"../GeometryWalker.js";import{normalizeDashTemplate as l}from"../utils.js";const o=1e3,u=1e-7;class _{static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(t,e,s,r,i){return new p(t,e,s,r)}}_.instance=null;class p extends i{constructor(t,e,s,r){super(t,!0,!0),this._firstCurve=null,this._walker=new n,this._walker.updateTolerance(s),this._endings=e.lineDashEnding,this._customDashPos=-(e.offsetAlongLine??0)*s,this._offsetAtEnd=(e.customEndingOffset??0)*s,this._tileKey=r;let i=l(e).dashTemplate;null==i&&(i=[]),i.length%2&&(i=[...i,...i]);let a=0;for(let n=0;n<i.length;n++){let t=Math.abs(i[n]);t<u&&(t=u),a+=t}this._patternLength=a,this._numOfDashesPerPattern=i.length/2,this._pattern=new h,this._pattern.init(i,!0),this._pattern.scale(s)}processPath(s){if(0===this._pattern.length()){this.iteratePath=!1;const r=e(s);return t.fromJSONCIM({paths:[r]})}if(!this.iteratePath){let r=!0;switch(this._endings){case a.HalfPattern:case a.HalfGap:default:this._pattern.extPtGap=0;break;case a.FullPattern:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case a.FullGap:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case a.NoConstraint:this.isClosed||(r=!1);break;case a.Custom:this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const i=s.pathLength();if(this._pattern.isEmpty()||i<.1*this._pattern.length()){const r=e(s);return t.fromJSONCIM({paths:[r]})}if(!this._walker.init(s,this._pattern,r)){const r=e(s);return t.fromJSONCIM({paths:[r]})}}let r;if(this.iteratePath)r=this._pattern.nextValue();else{let t;switch(this._endings){case a.HalfPattern:default:t=.5*this._pattern.firstValue();break;case a.HalfGap:t=.5*-this._pattern.lastValue();break;case a.FullGap:t=-this._pattern.lastValue();break;case a.FullPattern:t=0;break;case a.NoConstraint:case a.Custom:t=-this._customDashPos}let e=t/this._pattern.length();e-=Math.floor(e),t=e*this._pattern.length(),this._pattern.reset(),r=this._pattern.nextValue();let s=!1;for(;t>=r;)t-=r,r=this._pattern.nextValue(),s=!s;r-=t,s?(this._walker.nextPosition(r),r=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(r),r=this._pattern.nextValue(),this._walker.nextPosition(r),r=this._pattern.nextValue())}let i=this._walker.nextCurve(r);if(i)if(this._walker.isPathEnd()){if(this.iteratePath=!1,this._firstCurve){for(this._firstCurve.nextPath();this._firstCurve.nextPoint();)i.pushXY(this._firstCurve.x,this._firstCurve.y);this._firstCurve=null}}else r=this._pattern.nextValue(),!this._walker.nextPosition(r)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(i.pushCursor(this._firstCurve),this._firstCurve=null)):this.iteratePath=!0;else this.iteratePath=!1,i=this._firstCurve,this._firstCurve=null;return i?.reset(),i}isClippingRequired(t){const e=s(t);let i=0;for(const s of e)i+=r(s);return Math.round(this._numOfDashesPerPattern*(i/this._patternLength))>o}}export{_ as EffectDashes};
