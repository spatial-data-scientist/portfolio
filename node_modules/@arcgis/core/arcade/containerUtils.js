/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"./Dictionary.js";import{ArcadeExecutionError as a,ExecutionErrorCodes as r}from"./executionError.js";import t from"./ImmutablePathArray.js";import n from"./ImmutablePointArray.js";import{o as s,q as c,r as i,c as l,v as u,p as o,b as f}from"../chunks/languageUtils.js";let h=0;function d(s,c,i,l,u=1){let o;switch(c=c.toLowerCase()){case"hasz":{const e=s.hasZ;return void 0!==e&&e}case"hasm":{const e=s.hasM;return void 0!==e&&e}case"spatialreference":{let a=s.spatialReference._arcadeCacheId;if(void 0===a){let e=!0;Object.freeze&&Object.isFrozen(s.spatialReference)&&(e=!1),e&&(h++,s.spatialReference._arcadeCacheId=h,a=h)}const r=new e({wkt:s.spatialReference.wkt,wkid:s.spatialReference.wkid});return void 0!==a&&(r._arcadeCacheId="SPREF"+a.toString()),r}}switch(s.type){case"extent":switch(c){case"xmin":case"xmax":case"ymin":case"ymax":case"zmin":case"zmax":case"mmin":case"mmax":{const e=s[c];return void 0!==e?e:null}case"type":return"Extent"}break;case"polygon":switch(c){case"rings":o=s.cache._arcadeCacheId,void 0===o&&(h++,o=h,s.cache._arcadeCacheId=o);return new t(s.rings,s.spatialReference,!0===s.hasZ,!0===s.hasM,o);case"type":return"Polygon"}break;case"point":switch(c){case"x":case"y":case"z":case"m":return s[c]??null;case"type":return"Point"}break;case"polyline":switch(c){case"paths":o=s.cache._arcadeCacheId,void 0===o&&(h++,o=h,s.cache._arcadeCacheId=o);return new t(s.paths,s.spatialReference,!0===s.hasZ,!0===s.hasM,o);case"type":return"Polyline"}break;case"multipoint":switch(c){case"points":o=s.cache._arcadeCacheId,void 0===o&&(h++,o=h,s.cache._arcadeCacheId=o);return new n(s.points,s.spatialReference,!0===s.hasZ,!0===s.hasM,o,1);case"type":return"Multipoint"}}if(1===u)throw new a(i,r.InvalidIdentifier,l);return 2===u?{keystate:"notfound"}:null}function p(e,a){let r,t=e;if(null==t)return null;if(s(a))r=a;else if(c(a))r=a.toArray();else{if(null==a)return null;r=[a]}for(const n of r){if(i(t)){if(!1===l(n))return null;if(!t.hasField(n))return null;t=t.field(n)}else if(u(t)){if(!1===l(n))return null;if(!t.hasField(n))return null;t=t.field(n)}else if(o(t)){if(!1===l(n))return null;t=d(t,n,null,null,0)}else if(s(t)){if(!1===f(n))return null;t=n>=0?t[n]:t[t.length+n]}else{if(!c(t))return null;if(!1===f(n))return null;t=n>=0?t.get(n):t.get(t.length()+n)}if(null==t)return null}return t}export{d as geometryMember,p as getNestedOptionalValue};
