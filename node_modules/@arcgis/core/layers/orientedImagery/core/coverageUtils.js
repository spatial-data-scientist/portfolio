/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../../geometry.js";import{throwIfAborted as e}from"../../../core/promiseUtils.js";import{zeros as t,create as n}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{z as r,g as a}from"../../../chunks/vec32.js";import o from"../../../geometry/Circle.js";import i from"../../../geometry/Mesh.js";import{projectWithZConversion as s}from"../../../geometry/projection.js";import{earth as c}from"../../../geometry/support/Ellipsoid.js";import{wrap as f}from"../../../geometry/support/lineSegment.js";import y from"../../../geometry/support/MeshComponent.js";import{MeshVertexAttributes as l}from"../../../geometry/support/MeshVertexAttributes.js";import{intersectLineSegmentClamp as m,create as u,fromArray as x}from"../../../geometry/support/plane.js";import{isWebMercator as p}from"../../../geometry/support/spatialReferenceUtils.js";import{getWebMercatorScalingFactor as h,calculateRotationMatrix as g,transformMat3 as z,scaleAndAddWithFactor as M,scaleWithFactor as w,computeHFOVAndVFOV as d,projectiveTransform as R}from"../transformations/utils.js";import j from"../../../geometry/Polygon.js";import P from"../../../geometry/SpatialReference.js";import v from"../../../geometry/Multipoint.js";const A=Math.PI/180;function b(e){return e.isSpherical?V(e):D(e)}function D(e){const{horizontalFieldOfView:t,verticalFieldOfView:n,geometry:r,cameraHeading:a}=e,o=h(r);let i=e.cameraPitch,s=e.cameraRoll,c=150;t>150&&(i=90,s=0,c=5);const f=Math.ceil(t/c),y=H(f,a,t);let l=e.farDistance?e.farDistance*o:e.cameraHeight*o/Math.cos(i*A);e.cameraPitch+n/2>=90&&(l=(e.farDistance||20)*o);const m=new j({spatialReference:r?.spatialReference});m.imageID=e.objectId;let u=null;for(const x of y)u=I(x,i,s,e,r,l,o,n,t,f,m);return u.imageID=e.objectId,{polygon:m,frustum:u}}function H(e,t,n){const r=[];if(e%2==0)for(let a=0;a<e/2;a++)r.push(t-n/e*(a+.5),t+n/e*(a+.5));else{r.push(t);for(let a=1;a<e/2;a++)r.push(t-n/e*a,t+n/e*a)}return r.sort(),r}function I(e,n,o,i,s,c,f,y,l,m,u){const x=g("HPR",[e,n,o]),p=q(i,x),h=z([0,0,-1],x),{x:d,y:R}=s,j=M([d,R,i.cameraHeight],h,c,f),P=2*Math.tan(y*A/2)*c,v=2*Math.tan(l/m*A/2)*c,b=z([0,1,0],x),D=z([1,0,0],x),H=w(b,P/2,f),I=w(D,v/2,f),V=r(t(),H,I),F=a(t(),H,I),U=S([a(t(),j,V),a(t(),j,F),r(t(),j,V),r(t(),j,F)],i.cameraHeight,s,f);return U.push(U[0]),u.addRing(U),p}function S(e,t,n,r){return e.map((e=>O(e,t,n,r)))}function V(e){const{geometry:t,farDistance:n,objectId:r,nearDistance:a,cameraHeight:s}=e,c=h(t),f=new o({center:t.clone(),radius:n*c});if(f.imageID=r,a){const e=new o({center:t.clone(),radius:a*c});f.addRing(e.rings[0])}const y=t.clone();y.z=s-n*c;const l=i.createSphere(y,{size:2*n*c});return l.imageID=r,{polygon:f,frustum:l}}function F(e,t){return e.contains(t)}function U(e,t){return Math.sign(e)!==Math.sign(t)}function q(e,n,o){const{cameraHeight:s,cameraPitch:c,farDistance:f,geometry:y,horizontalFieldOfView:m,nearDistance:u,verticalFieldOfView:x}=e,p=k(y),h=u<0?0:u*p;let g=s*p/Math.cos(c*A),d=!0;c+x/2>=90&&(g=(f??20)*p,d=!1);const R=2*Math.tan(x*A/2)*h,j=2*Math.tan(m*A/2)*h,P=2*Math.tan(x*A/2)*g,v=2*Math.tan(m*A/2)*g;let b,D;D=[0,0,-1],D=z(D,n),b=M([y.x,y.y,s],D,g,p),d&&(b[2]=0);const H=M([y.x,y.y,s],D,h,p);let I=[0,1,0];I=z(I,n);let S=[1,0,0];S=z(S,n);let V=[],F=[];h?(F=[{faces:[4,0,3,4,7,3]},{faces:[5,1,2,5,6,2]},{faces:[4,0,1,4,5,1]},{faces:[6,2,3,6,7,3]}],V=V.concat(a(t(),H,r(t(),w(I,R/2,p),w(S,j/2,p)))),V=V.concat(a(t(),H,a(t(),w(I,R/2,p),w(S,j/2,p)))),V=V.concat(r(t(),H,r(t(),w(I,R/2,p),w(S,j/2,p)))),V=V.concat(r(t(),H,a(t(),w(I,R/2,p),w(S,j/2,p))))):(V=[y.x,y.y,s],F=[{faces:[0,1,2,0,2,3,0,3,4,0,4,1]}]),V=V.concat(a(t(),b,r(t(),w(I,P/2,p),w(S,v/2,p)))),V=V.concat(a(t(),b,a(t(),w(I,P/2,p),w(S,v/2,p)))),V=V.concat(r(t(),b,r(t(),w(I,P/2,p),w(S,v/2,p)))),V=V.concat(r(t(),b,a(t(),w(I,P/2,p),w(S,v/2,p))));const U=new l({position:Float64Array.from(V)});return new i({vertexAttributes:U,components:F,spatialReference:y.spatialReference})}function O(e,n,a,o){{const i=Math.sqrt((e[2]-n)**2+(Math.sqrt((e[0]-a.x)**2+(e[1]-a.y)**2)/o)**2)*o,s=w(r(t(),[e[0],e[1],e[2]],[a.x,a.y,n]),1/i,1/o),c=n/(n-e[2]),f={x:(1-c)*a.x+c*e[0],y:(1-c)*a.y+c*e[1],z:(1-c)*n+c*e[2]},y=Math.sqrt((f.z-n)**2+(Math.sqrt((f.x-a.x)**2+(f.y-a.y)**2)/o)**2)*o,l=w(r(t(),[f.x,f.y,f.z],[a.x,a.y,n]),1/y,1/o);return U(s[0],l[0])&&U(s[1],l[1])&&U(s[2],l[2])||e[2]>=0?[e[0],e[1],0]:[f.x,f.y,f.z]}}function C(e){const{spatialReference:t,x:n,y:r}=e.geometry,{cameraHeading:a,cameraPitch:o,farDistance:i,nearDistance:s}=e,c=k(e.geometry),f=new j({spatialReference:t}),y=Math.abs(1.44*i*c);let l=Math.abs(1.44*s*c);(o<20||null==a)&&(l=y);const m=[];return m[0]={x:n+y*Math.sin((a-45)*A),y:r+y*Math.cos((a-45)*A)},m[1]={x:n+y*Math.sin((a+45)*A),y:r+y*Math.cos((a+45)*A)},m[2]={x:n+l*Math.sin((a+135)*A),y:r+l*Math.cos((a+135)*A)},m[3]={x:n+l*Math.sin((a+225)*A),y:r+l*Math.cos((a+225)*A)},f.addRing([[m[0].x,m[0].y,0],[m[1].x,m[1].y,0],[m[2].x,m[2].y,0],[m[3].x,m[3].y,0],[m[0].x,m[0].y,0]]),f}function k(e){return e&&p(e?.spatialReference)?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*e.y/c.radius))):1}function E(e,n){const a=1+n/100;if("esri.geometry.Circle"===e.declaredClass){const{radius:t,center:n}=e,r=new o({radius:t*a,center:n});return e.rings.length>1&&r.addRing(e.rings[1]),r}if("esri.geometry.Polygon"===e.declaredClass){const n=new j({spatialReference:e.spatialReference}),o=e.centroid;if(o){const i=[];for(let n=0;n<e.rings[0].length;n++){const s=Math.sqrt((o.x-e.rings[0][n][0])**2+(o.y-e.rings[0][n][1])**2),c=w(r(t(),[e.rings[0][n][0],e.rings[0][n][1],0],[o.x,o.y,0]),1/s,1),f=M([o.x,o.y,0],c,s*a,1);i.push({x:f[0],y:f[1]})}n.addRing([[i[0].x,i[0].y,0],[i[1].x,i[1].y,0],[i[2].x,i[2].y,0],[i[3].x,i[3].y,0],[i[0].x,i[0].y,0]])}return n}return e}async function L(e,t,n){const{cameraHeight:r,cameraLocation:a,cameraPitch:o,frustumVertices:i,horizontalFieldOfView:s,imageHeight:c,imageWidth:f,inSRS:y,outSRS:l,verticalFieldOfView:m,cameraRoll:u,imageRotation:x,options:p}=n,h=new P(y),g=new P(l),z=d(s,m,u??0),M=i.length>15;return o+z.vfov/2>=90?await K(i,e,f,c,h,g,M,x,p):await W(i,e,t,a,r,M,h,g,p)}async function W(e,t,n,r,a,o,s,c,f){const y=B(e,t,n,r,a);if(!y)return;const{farPlane:m,nearPlane:u}=y,x=await N([...u?.vertexPositions??e.slice(0,3),...m.vertexPositions],s,c,f);return new i({vertexAttributes:new l({position:x}),components:Y(X(o)),spatialReference:c})}function B(e,t,n,r,a){const o=T(e),i=T(e,"near");if(!o)return;const{coefficients:s}=o,c=t.length;for(let f=0;f<c;f++){const e=Q([n[f][0],n[f][1]],s),t=n[f];t[2]=(t[2]>=0?e:t[2])??0;const c=[t[0]-r[0],t[1]-r[1],t[2]-(r[2]??a)];J(r,c,f,i),G(r,c,f,o,n,e)}return{farPlane:o,nearPlane:i}}function G(e,t,r,a,o,i){const{coefficients:s,vertexPositions:c}=a;if(null!=i&&i>=0)c.splice(3*r,3,...o[r]);else{const a=n();m(s,f(e,t),a)&&c.splice(3*r,3,...a)}}function J(e,t,r,a){if(!a)return;const o=n();m(a.coefficients,f(e,t),o)&&a.vertexPositions.splice(3*r,3,...o)}async function K(e,t,n,r,a,o,s,c=0,f){const y=Math.cos((c??0)*A),m=Math.sin((c??0)*A),u=Math.abs(n*y+r*m),x=Math.abs(n*-m+r*y);let p,h,g=s?new Array:[e[0],e[1],e[2]],z=new Array;const M=t.length;for(let i=0;i<M;i++){const a=[u/2,x/2],o=t[i];h=[(o[0]-a[0])*y-(o[1]-a[1])*m+a[0],(o[0]-a[0])*m+(o[1]-a[1])*y+a[1]],s?(p=R({x:h[0],y:h[1],z:1},{x:0,y:0,z:1},{x:n,y:0,z:1},{x:n,y:r,z:1},{x:0,y:r,z:1},{x:e[0],y:e[1],z:e[2]},{x:e[3],y:e[4],z:e[5]},{x:e[6],y:e[7],z:e[8]},{x:e[9],y:e[10],z:e[11]}),g=g.concat([p.x,p.y,p.z]),p=R({x:h[0],y:h[1],z:1},{x:0,y:0,z:1},{x:n,y:0,z:1},{x:n,y:r,z:1},{x:0,y:r,z:1},{x:e[12],y:e[13],z:e[14]},{x:e[15],y:e[16],z:e[17]},{x:e[18],y:e[19],z:e[20]},{x:e[21],y:e[22],z:e[23]}),z=z.concat([p.x,p.y,p.z])):(p=R({x:h[0],y:h[1],z:1},{x:0,y:0,z:1},{x:n,y:0,z:1},{x:n,y:r,z:1},{x:0,y:r,z:1},{x:e[3],y:e[4],z:e[5]},{x:e[6],y:e[7],z:e[8]},{x:e[9],y:e[10],z:e[11]},{x:e[12],y:e[13],z:e[14]}),g=g.concat([p.x,p.y,p.z]))}g=g.concat(z);const w=await N(g,a,o,f);return new i({vertexAttributes:new l({position:w}),components:Y(X(s)),spatialReference:o})}async function N(t,n,r,a){if(n.equals(r))return t;const o=t.reduce(((e,t,n)=>{const r=Math.floor(n/3);return e[r]||(e[r]=new Array),e[r].push(t),e}),new Array),{points:i}=await s(new v(o,n),r,a);return e(a),i.flat()}function Q(e,t){if(t)return(-t[3]-t[0]*e[0]-t[1]*e[1])/t[2]}function T(e,t="far"){const n=u();let r;switch(t){case"far":if(r=Array.from(15===e.length?e.slice(3):e.slice(12)),x(n,r,!1))return{coefficients:n,vertexPositions:r};break;case"near":if(r=Array.from(e.slice(0,12)),15===e.length||!x(n,r,!1))return;return{coefficients:n,vertexPositions:r}}}const X=e=>e?[{faces:new Uint32Array([4,0,3,4,7,3])},{faces:new Uint32Array([5,1,2,5,6,2])},{faces:new Uint32Array([4,0,1,4,5,1])},{faces:new Uint32Array([6,2,3,6,7,3])}]:[{faces:new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1])}],Y=e=>e.map((e=>new y(e)));export{F as checkIfPolygonContainsSelectedPoint,C as computePolygonForInspection,b as createCoveragePolygon,S as limitZToGround,N as projectVertices,E as resizePolygon,L as updateFrustum};
