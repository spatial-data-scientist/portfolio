/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../core/Error.js";import t from"../../../core/Logger.js";import{isAbortError as a,throwIfAborted as r}from"../../../core/promiseUtils.js";import{mul as i}from"../../../core/libs/gl-matrix-2/math/mat3.js";import n from"../../../geometry/Point.js";import{initializeProjection as o,project as s,projectWithZConversion as c}from"../../../geometry/projection.js";import{fromExtent as l}from"../../../geometry/support/aaBoundingRect.js";import{distance as m}from"../../../geometry/support/pointUtils.js";import{geographicToWebMercator as p}from"../../../geometry/support/webMercatorUtils.js";import f from"../../ElevationLayer.js";import u from"../../ImageryLayer.js";import{isConstantElevation as y,validateElevationSourceURL as d}from"../core/ElevationSourceDefinitions.js";import{geographicToLTP as g,convertSphereVertexToOrientation as h,convertOrientationToPixelLocation as w,calculateRotationMatrix as R}from"./utils.js";import{TileElevationSampler as v}from"../../support/ElevationSampler.js";import{ElevationTile as b}from"../../support/ElevationTile.js";import{ElevationTileData as z}from"../../support/ElevationTileData.js";import P from"../../support/TileInfo.js";import{TileKey as O}from"../../support/TileKey.js";import{defaultImageSphereCenter as j}from"../../../widgets/PanoramicViewer/constants.js";const x=Math.PI/180;async function S(e,t,a=!1){if(!e)return[];e=e.map((e=>"esri.geometry.Point"===e.declaredClass?e:n.fromJSON(e)));const{feature:r}=t,{attributes:i}=r;if(isNaN(parseFloat(i.elevation))){const e=await M([r.geometry],t);r.attributes.elevation=e[0].z}return M(e,t,a).then((e=>H(e,t)))}async function M(e,t,a=!1){if(a)return e;const{feature:{attributes:{cameraOrientation:r,elevationSource:i,cameraHeight:n,location:o},elevationSample:s}}=t;return s?Promise.all(e.map(N(s,t.options))):i&&(y(i)||i.url?.length)?E(e,t):I(e,r&&"number"==typeof o.z?o.z-n:0)}async function E(e,r){const{feature:i,options:n,footprintExtent:s}=r,c=i.attributes.elevationSource;if(!c)return e;if(y(c)){const{constantElevation:t}=c;return"number"!=typeof t?e:I(e,t)}const{url:m}=c;if(!m)return e;const{elevationSample:p}=i;if(!p){if(!s)return e;const r=s.clone(),{error:o,isSupported:p,isDynamic:y}=await d(m);if(!p){t.getLogger(c).warn(o);const{location:a,cameraHeight:r,cameraOrientation:n}=i.attributes;return I(e,n&&"number"==typeof a.z?a.z-r:0)}let h,w=e;try{if(y){h=new u({url:m,format:"lerc",rasterFunction:{functionName:c.rasterFunction??"None"}}),await h.load(n);let e,t=512,a=512;const o=s.width/s.height;o>1?(a/=o,e=r.height/a):(t*=o,e=r.width/t);const p=await h.fetchImage(s,t,a,n),f=P.create({scales:[e],size:512,spatialReference:s.spatialReference}),y=new O(null,0,0,0,l(s)),d=new z(p.pixelData.pixelBlock.pixels[0],t,a,0),g=new b(y,d);i.elevationSample=new v(g,f,void 0)}else h=new f(m),await h.load(),i.elevationSample=await h.createElevationSampler(r,n);w=await Promise.all(e.map(N(i.elevationSample,n)))}catch(g){if(!a(g)){t.getLogger("esri.layers.orientedImagery.transformations.groundToImageUtils").warn(`#updateElevation() failed to update elevation using the provided elevation source URL: ${m}. Please provide a valid elevation source url.`,g);const{location:a,cameraHeight:r,cameraOrientation:n}=i.attributes;e=I(e,n&&"number"==typeof a.z?a.z-r:0)}}finally{h?.destroy()}return w}return await o(e[0].spatialReference,p.spatialReference,null,r.options),Promise.all(e.map(N(p,n)))}function N(e,t){return r(t),async a=>{a.z=1;const r=e.queryElevation(s(a,e.spatialReference));return r?.z&&(a.z=(await c(r,a.spatialReference,t)).z),a}}function I(e,t){return e.map((e=>(e.z=t,e)))}function H(e,t){const{attributes:a}=t.feature;return a.isSpherical||360===a.horizontalFieldOfView?W(e,t):a.cameraOrientation?.isAdvanced?T(e,t):Promise.resolve(L(e,t))}async function W(e,t){const a=Array.isArray(e)?e:[e],r=new Array,{location:i,cameraOrientation:n,cameraHeading:o}=t.feature.attributes,s=t.imageProperties.height??1,c=t.imageProperties.width??1;return await q(i,a,o,c,s,r,n),r}async function q(e,t,a,r,i,o,s){const l=e.spatialReference.isWGS84&&4!==s?.type?p(e):new n(e),{latitude:f,longitude:u,ellipsoidRadius:y,squaredEccentricity:d}=s??{};for(const p of t){const e=p.spatialReference.isWGS84&&4===s?.type?new n(g(p,[f,u,y,d])):p.spatialReference.equals(l.spatialReference)?new n(p):await c(p,l.spatialReference),t=m(l,e);e.x-=l.x,e.y-=l.y,e.z=(e.z??0)-(l.z??0);const R=h(e,t);R.heading=(R.heading-a)%360;const{x:v,y:b}=w(R.heading,R.pitch,r,i);o.push(new n(v,b,j.spatialReference))}}function L(e,t){const{feature:a,imageProperties:r}=t,{width:o,height:s}=r,{attributes:c}=a,l=R("HPR",[c.cameraHeading,c.cameraPitch,c.cameraRoll]),m=Math.sin(c.imageRotation??0*x),f=Math.cos(c.imageRotation??0*x),u=o??1,y=s??1,d=[Math.abs(f*u+m*y),Math.abs(f*y-m*u)],h={horizontal:1/(2*Math.tan(c.horizontalFieldOfView*x/2)),vertical:1/(2*Math.tan(c.verticalFieldOfView*x/2))},w=[-h.horizontal,0,.5,0,h.vertical,.5,0,0,1];let v=new n(c.location);v.spatialReference.isWGS84&&4!==c.cameraOrientation?.type&&(v=p(v));const b=v.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*v.y/6378137))):1,z=i(new Array(9),l,w);return e.map((e=>{let t=new n(e);if(t.spatialReference.isWGS84)if(4===c.cameraOrientation?.type){const e=c.cameraOrientation;t=new n(g(t,[e.latitude,e.longitude,e.ellipsoidRadius,e.squaredEccentricity]))}else t=new n(p(t));const a=(t.z??0)-(v.z??0),r=(t.x-v.x)/b,i=(t.y-v.y)/b,o=(z[0]*r+z[1]*i+z[2]*a)/(z[6]*r+z[7]*i+z[8]*a),s=(z[3]*r+z[4]*i+z[5]*a)/(z[6]*r+z[7]*i+z[8]*a),l={x:o*d[0],y:s*d[1]};return{x:f*(l.x-d[0]/2)+m*(l.y-d[1]/2)+u/2,y:-m*(l.x-d[0]/2)+f*(l.y-d[1]/2)+y/2}}))}function T(t,a){const{feature:r}=a,{attributes:i}=r,c=i.cameraOrientation;if(!c)throw new e("groundToImageUtils:missing-camera-orientation-parameters","CameraOrientation Parameters are required to perform advanced transformations");let l=new n(i.location);l.spatialReference.isWGS84&&4!==i.cameraOrientation?.type&&(l=p(l));const m=l.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*l.y/6378137))):1;let f;if("esri.layers.orientedImagery.core.CameraOrientationOPK"===c.declaredClass){const{omega:e,phi:t,kappa:a}=c;f=R("OPK",[e,t,a])}else{const{cameraHeading:e,cameraPitch:t,cameraRoll:a}=i;f=R("HPR",[e,t,a])}const{principalOffsetPoint:u,focalLength:y,radialDistortionCoefficients:d,affineTransformations:h,tangentialDistortionCoefficients:w}=c;return Promise.all(t.map((async e=>{let r;return e.spatialReference.equals(l.spatialReference)?(r=new n(e),c(r)):(await o(t[0].spatialReference,l.spatialReference,null,a.options),r=s(e,l.spatialReference),c(r));function c(e){if(e.spatialReference.isWGS84)if(4===i.cameraOrientation?.type){const t=i.cameraOrientation;e=new n(g(e,[t.latitude,t.longitude,t.ellipsoidRadius,t.squaredEccentricity]))}else e=new n(p(e));const t=(e.z??0)-(l.z??0),a=(e.x-l.x)/m,r=(e.y-l.y)/m,o=(f[0]*a+f[1]*r+f[2]*t)/(f[6]*a+f[7]*r+f[8]*t),s=(f[3]*a+f[4]*r+f[5]*t)/(f[6]*a+f[7]*r+f[8]*t),c=o**2+s**2;let R=0,v=0,b=0,z=0,P=0,O=0,j=0;d&&(R=d[0]??0,v=d[1]??0,b=d[2]??0),w&&(z=w[0],P=w[1]),u&&(O=u[0]??0,j=u[1]??0);const x=1+(R||0)*c+(v||0)*c*c+(b||0)*c*c*c;let S=o*x+(z||0)*(c+2*o**2)+2*(P||0)*o*s,M=s*x+(P||0)*(c+2*s**2)+2*(z||0)*o*s;S=-(y??0)*S+O,M=-(y??0)*M+j;return{x:Number(h[0])+Number(h[1])*S+Number(h[2])*M,y:Number(h[3])+Number(h[4])*S+Number(h[5])*M}}})))}export{S as transformPoints,W as transformPointsEquirectangularPanorama,M as updateElevation,E as updateElevationUsingElevationSource};
