/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../../geometry.js";import"../../../core/has.js";import"../../../core/Logger.js";import{deg2rad as e}from"../../../core/mathUtils.js";import{zeros as t,create as r}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{m as a,z as n,g as i}from"../../../chunks/vec32.js";import o from"../../../geometry/Point.js";import{projectWithZConversion as s,initializeProjection as c,project as f}from"../../../geometry/projection.js";import{fromPoints as p,fromValues as m}from"../../../geometry/support/ray.js";import{k as l,i as y}from"../../../chunks/sphere.js";import{geographicToWebMercator as u,webMercatorToGeographic as g}from"../../../geometry/support/webMercatorUtils.js";import{createCoveragePolygon as w,limitZToGround as x}from"../core/coverageUtils.js";import z from"../core/ExposurePoint.js";import{transformPoints as h,updateElevation as d}from"./groundToImageUtils.js";import{getWebMercatorScalingFactor as R,convertPixelToHeadingPitch as j,convertHeadingPitchToSphereVertex as b,scaleAndAddWithFactor as P,hasCameraOrientationLTP as v,computeHFOVAndVFOV as M,ltpToGeographic as O,projectiveTransform2 as S,scaleWithFactor as F,calculateRotationMatrix as L,transformMat3 as H,projectiveTransform as V,getPlaneLineIntersectionPoint as A}from"./utils.js";import{defaultImageSphereCenter as T}from"../../../widgets/PanoramicViewer/constants.js";import{isNumber as U}from"../../../widgets/support/dataUtils.js";import C from"../../../geometry/Polygon.js";import D from"../../../geometry/SpatialReference.js";function E(e,t){if(!e)return Promise.resolve([]);const r=t.feature;let a=r.attributes;return a instanceof z||(a=z.fromJSON(r),a&&(r.attributes=a)),G(e,t)}function G(e,t){const{attributes:r}=t.feature;if(r.isSpherical||360===r.horizontalFieldOfView){const{location:a,cameraOrientation:n,farDistance:i,cameraHeading:o,cameraHeight:s}=r;return W(e,a,i,[t.imageProperties.width,t.imageProperties.height],o,s,n)}return k(e,t)}async function W(e,t,a,n,i,s,c){let f=new o(t);f.spatialReference.isGeographic&&f.spatialReference.isWGS84&&4!==c?.type&&(f=u(f));const g=R(f),w=new Array,[x,z,h]=f.toArray(),d=l([x,z,h??0],a*g),v=T.toArray();for(const l of e){let e,t;if(U(l.heading)&&U(l.pitch))e=l.heading,t=l.pitch;else{const r=j({x:l.x,y:l.y},n[0],n[1]);e=r.heading,t=r.pitch}e=(e+i)%360;const a=p([v[0],v[1],v[2]],b(e,t)),c=m([x,z,h??0],a.direction),u=r();y(d,c,u);const R=(f.z??0)-s;if(u[2]<R){const e=Math.abs((f.z-R)/-a.direction[2])*g;P([f.x,f.y,f.z],a.direction,e,g,u)}else u[2]=R;w.push(new o(u,f.spatialReference))}return w}async function k(e,t){const{feature:r,footprintExtent:a,options:n}=t,{attributes:{cameraHeight:i,cameraOrientation:c,cameraPitch:f,cameraRoll:p,elevationSource:m,horizontalFieldOfView:l,location:y,verticalFieldOfView:x},elevationSample:z}=r,d=v(c),{vfov:j}=M(l,x,p??0);let b=new o(y),P=!1;d&&(b=new o(O(b,[c.latitude,c.longitude,c.ellipsoidRadius,c.squaredEccentricity]))),b.spatialReference.isWGS84&&(P=!0,b=u(b));const F=R(b),L=I(t,b,F),H=d?L.map((e=>g(new o(e)))):L,V=await h(H,t,!0).then((e=>e.map((e=>({x:e.x,y:e.y,z:1}))))),A=new Array;for(const u of e){const e={...u,z:1},c={...S(e,V,H),spatialReference:b.spatialReference},[p]=await h([d?g(new o(c)):new o(c)],t,!0);await B(e,p,V,H,b,c,d,t);const l=r.attributes.clone();l.geometry=b.clone();const{polygon:y}=w(l),x=y.rings[0].map((e=>new o(e,y.spatialReference))),R=await s(m||z?await q({cameraLocation:b,groundFootPrint:x,projectedPoint:c,webMercatorScalingFactor:F,vfov:j,shouldConvertToLatLong:P,isCameraOrientationLTP:d,imgPoint:e},t):new o(N(c,b,F,b.z-i,f,j,P)),a.spatialReference,n);A.push(R)}return A}async function q(e,t){const{cameraLocation:r,groundFootPrint:a,projectedPoint:n,webMercatorScalingFactor:i,vfov:s,shouldConvertToLatLong:f,isCameraOrientationLTP:p,imgPoint:m}=e,{cameraHeight:l,cameraPitch:y}=t.feature.attributes;await c(r.spatialReference,t.footprintExtent.spatialReference,null,t.options);let u=await Z(a,t),w=0,x=(r.z??0)-l,z=0;for(;z<10;){const e=K(u,r,n);if(!e||!J([r.x,r.y,r.z],[e.x,e.y,e.z],[n.x,n.y,n.z]))return new o(N(n,r,i,x,y,s,f));const a=new o({x:e.x,y:e.y,z:e.z,spatialReference:r.spatialReference}),c=await h([p?g(a):a],t);if(w=Math.abs(m.x-c[0].x)+Math.abs(m.y-c[0].y),x=e.z,w<=1)return new o(N(n,r,i,x,y,s,f));z+=1;const{extent:l}=u,R=(l?.width??0)/10,j=(l?.height??0)/10;if(R<1||j<1)return new o(N(n,r,i,x,y,s,f));const{x:b,y:P}=e,v=await d(Q(R,j).map((([e,t])=>new o({x:b+e,y:P+t,spatialReference:r.spatialReference}))),t,!1);v.push(v[0]),u=new C({rings:[v.map((e=>e.toArray()))],spatialReference:r.spatialReference})}return new o(N(n,r,i,x,y,s,f))}const J=(e,r,i)=>a(n(t(),r,e),n(t(),i,e))>0;function N(e,r,a,i,s,c,f){const p=Math.sqrt((e.z-r.z)**2+(Math.sqrt((e.x-r.x)**2+(e.y-r.y)**2)/a)**2)*a,m=F(n(t(),[e.x,e.y,e.z],[r.x,r.y,r.z]),1/p,1/a);if(e.z<i||s+c/2<90){const t=Math.abs((r.z-i)/-m[2])*a,n=P([r.x,r.y,r.z],m,t,a);e.x=n[0],e.y=n[1],e.z=n[2]}else e.z=i;return f?g(new o(e)).toJSON():e}function I(r,a,s){const{feature:c}=r,{attributes:f}=c,p=2*Math.tan(e(f.verticalFieldOfView)/2)*f.farDistance*s,m=2*Math.tan(e(f.horizontalFieldOfView)/2)*f.farDistance*s,l=L("HPR",[f.cameraHeading,f.cameraPitch,f.cameraRoll??0]),y=H([0,0,-1],l),u=P([a.x,a.y,a.z],y,f.farDistance*s,s),g=H([0,1,0],l),w=H([1,0,0],l),x=F(g,p/2,s),z=F(w,m/2,s),h=n(t(),x,z),d=i(t(),x,z);return[i(t(),u,h),i(t(),u,d),n(t(),u,h),n(t(),u,d)].map((e=>{const[t,r,n]=e;return new o({x:t,y:r,z:n,spatialReference:a.spatialReference})}))}async function Z(e,t){const r=e[0].spatialReference.isWGS84?D.WebMercator:e[0].spatialReference,{cameraHeight:a,location:n,elevation:i}=t.feature.attributes,s="number"==typeof n.z&&"number"==typeof i?n.z-i:a,c=x(e.map((({x:e,y:t,z:r})=>[e,t,r])),s,n,R(n)),p=(await d(c.map((e=>new o(e,n.spatialReference))),t,!1)).map((e=>f(e,r)));return new C({hasZ:!0,rings:[p.map((e=>[e.x,e.y,e.z]))],spatialReference:r})}async function B(e,t,r,a,n,i,s,c){let f=0;const p=8;for(let m=0;m<=p;m+=1){if(f=Math.abs(e.x-t.x)+Math.abs(e.y-t.y),f<=1)return;const[p,m,l,y]=Q(f,f).map((([t,i])=>({...V({x:e.x+t,y:e.y+i,z:1},r[0],r[1],r[2],r[3],{x:a[0].x,y:a[0].y,z:a[0].z},{x:a[1].x,y:a[1].y,z:a[1].z},{x:a[2].x,y:a[2].y,z:a[2].z},{x:a[3].x,y:a[3].y,z:a[3].z}),spatialReference:n.spatialReference}))),[u,w,x,z]=await h(s?[g(new o(p)),g(new o(m)),g(new o(l)),g(new o(y))]:[new o(p),new o(m),new o(l),new o(y)],c,!0).then((e=>e.map((e=>({...e,z:0}))))),{x:d,y:R,z:j}=V(e,u,w,x,z,p,m,l,y);i.x=d,i.y=R,i.z=j,[t]=await h([s?g(new o(i)):new o(i)],c,!0)}}function K(e,t,r){const a={x:e.rings[0][0][0],y:e.rings[0][0][1],z:e.rings[0][0][2]},n={x:e.rings[0][1][0],y:e.rings[0][1][1],z:e.rings[0][1][2]},i={x:e.rings[0][1][0],y:e.rings[0][1][1],z:e.rings[0][1][2]},o={x:e.rings[0][2][0],y:e.rings[0][2][1],z:e.rings[0][2][2]},s=(o.z-i.z)*(n.y-a.y)-(o.y-i.y)*(n.z-a.z),c=-((o.z-i.z)*(n.x-a.x)-(n.z-a.z)*(o.x-i.x)),f=(o.y-i.y)*(n.x-a.x)-(n.y-a.y)*(o.x-i.x),p=-(s*a.x+c*a.y+f*a.z);return A(t.toJSON(),r,s,c,f,p)}const Q=(e,t)=>[[-e,-t],[e,-t],[e,t],[-e,t]];export{E as transformPoints};
