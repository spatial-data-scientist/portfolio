/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t}from"../chunks/tslib.es6.js";import"../geometry.js";import e from"../request.js";import r from"../core/Error.js";import{clamp as o}from"../core/mathUtils.js";import{MultiOriginJSONMixin as i}from"../core/MultiOriginJSONSupport.js";import{watch as l,initial as s}from"../core/reactiveUtils.js";import{property as n}from"../core/accessorSupport/decorators/property.js";import"../core/has.js";import"../core/Logger.js";import"../core/RandomLCG.js";import{reader as p}from"../core/accessorSupport/decorators/reader.js";import{subclass as a}from"../core/accessorSupport/decorators/subclass.js";import u from"../geometry/Polyline.js";import y from"../geometry/SpatialReference.js";import c from"./Layer.js";import{BlendLayer as d}from"./mixins/BlendLayer.js";import{CustomParametersMixin as m}from"./mixins/CustomParametersMixin.js";import{ScaleRangeLayer as h}from"./mixins/ScaleRangeLayer.js";import{parse as f}from"./support/arcgisLayerUrl.js";import{url as g}from"./support/commonProperties.js";import v from"./support/PlaybackInfo.js";import{getVideoLayerCapabilities as j}from"./support/serviceCapabilitiesUtils.js";import O from"./support/TelemetryData.js";import S from"./support/TelemetryDisplay.js";import b from"./support/VideoFrame.js";import C from"./video/VideoController.js";import{getFrameHorizonPoints as T,getGroundControlPoints as P,getTelemetryData as U,getSensorTrailPoints as x,readVideoTimeExtent as I}from"./video/videoUtils.js";import N from"../geometry/Polygon.js";import w from"../geometry/Extent.js";let E=class extends(d(h(i(m(c))))){constructor(t){super(t),this._trailPoints=[],this.capabilities=null,this.connectionInfo=null,this.controller=new C,this.copyright=null,this.coverage=null,this.created=null,this.description=null,this.elevationSource=null,this.frame=null,this.frameCount=null,this.fullExtent=null,this.initialExtent=null,this.layerId=null,this.playbackInfo=null,this.posterUrl=null,this.protocol="hls",this.qualities=null,this.serviceItemId=null,this.sourceJSON=null,this.sourceQuality=null,this.sourceType=null,this.spatialReference=y.WGS84,this.telemetryDisplay=null,this.title=null,this.type="video",this.url=null,this.videoTimeExtent=null}initialize(){this.telemetryDisplay=new S({frameCenter:!0,frameOutline:!0,lineOfSight:!0,sensorLocation:!0,sensorTrail:!0}),this.addHandles([l((()=>this.metadata),(()=>{this.notifyChange("telemetry"),this.notifyChange("groundControlPoints"),this.notifyChange("frameHorizonPoints")})),l((()=>this.telemetry?.sensorLocation),(t=>this._setSensorTrail(t)),s)])}load(t){const e=null!=t?t.signal:null;return this.addResolvingPromise(this._fetchService(e)),Promise.resolve(this)}get buffered(){return this.controller.buffered}readCapabilitiesFromService(t,e){return j(e)}readConnectionInfo(t,e){const r=e.connectionUrl;return this.controller.playerUrl=r&&this.protocol?r[this.protocol]:"",r}get currentTime(){return this.controller.currentTime}get duration(){return this.controller.duration}get ended(){return this.controller.ended}get frameHorizonPoints(){return T(this.metadata)}get groundControlPoints(){return P(this.metadata)}get loop(){return this.controller.loop}set loop(t){this.controller.loop=t}get metadata(){return this.controller?.currentMetadata}get muted(){return this.controller.muted}set muted(t){this.controller.muted=t}get playbackRate(){return this.controller.rate}set playbackRate(t){this.controller.rate=t}get playerUrl(){return this.controller.playerUrl}get playing(){return this.controller.playing}get state(){return this.controller.state}get telemetry(){return U(this.metadata)}get videoElement(){return this.controller?.element}get videoHeight(){return this.controller?.videoHeight}get videoWidth(){return this.controller?.videoWidth}get waiting(){return this.controller.waiting}play(){this.controller.play()}pause(){this.controller.pause()}reset(){this.controller.reset()}setCurrentTime(t){if(!this.duration)return;const e=o(t,0,this.duration);this.controller.setCurrentTime(e)}getCurrentFrame(){}toGround(t,e){return this.controller?.sensorModel?.metadataSupportsTransforms?this.controller.sensorModel.transformImageToGeo(t,e):null}toVideo(t){if(!this.controller?.sensorModel?.metadataSupportsTransforms)return null;const e=this.controller.sensorModel.transformGeoToImage(t.x,t.y,t.z);return{x:e[0],y:e[1]}}async _fetchService(t){if(this.sourceJSON)return void this.read(this.sourceJSON,{origin:"service",url:this.parsedUrl});const o=f(this.parsedUrl?.path);if(null==o)throw new r("arcgis-layers:url-mismatch","The url is not a valid arcgis resource");let i=null;const{data:l,ssl:s}=await e(o.url.path,{query:{f:"json",...this.parsedUrl.query,...this.customParameters},signal:t}),n=l;if(this.url=o.url.path,s&&(this.url=this.url.replace(/^http:/i,"https:")),!n?.currentVersion)return n.currentVersion="11.2",this.sourceJSON=n,void this.read(this.sourceJSON,{origin:"service",url:this.parsedUrl});let p=o?.sublayer;if(null==p&&n.layers?.length&&(p=n.layers[0].id),null==p)throw new r("arcgis-layers:url-mismatch","The url is not a valid arcgis resource");this.url=`${o.url.path}/${p}`,i=await e(this.url,{query:{f:"json",...this.customParameters},signal:t});const a={...n,...i.data};this.sourceJSON=a,this.read(this.sourceJSON,{origin:"service",url:this.parsedUrl})}_setSensorTrail(t){if(!t)return;const e=x(t,this._trailPoints);this._trailPoints=[...e];const r=this._trailPoints.map((t=>t.toArray())),o=new u({hasZ:t.hasZ,paths:[r]});this.telemetry.sensorTrail=o.clone()}};t([n({readOnly:!0})],E.prototype,"buffered",null),t([n({readOnly:!0,json:{read:!1}})],E.prototype,"capabilities",void 0),t([p("service","capabilities",["supportsAppend","supportsCoverageQuery","supportsExportClip","supportsExportFrameset","supportsMensuration","supportsUpdate"])],E.prototype,"readCapabilitiesFromService",null),t([n({readOnly:!0})],E.prototype,"connectionInfo",void 0),t([p("connectionInfo",["connectionUrl"])],E.prototype,"readConnectionInfo",null),t([n()],E.prototype,"controller",void 0),t([n({type:String})],E.prototype,"copyright",void 0),t([n({type:N})],E.prototype,"coverage",void 0),t([n({type:Date})],E.prototype,"created",void 0),t([n({type:Number})],E.prototype,"currentTime",null),t([n({type:String})],E.prototype,"description",void 0),t([n({type:Number})],E.prototype,"duration",null),t([n({readOnly:!0})],E.prototype,"elevationSource",void 0),t([n({type:Boolean})],E.prototype,"ended",null),t([n({type:b})],E.prototype,"frame",void 0),t([n({type:Number})],E.prototype,"frameCount",void 0),t([n({type:w})],E.prototype,"fullExtent",void 0),t([n({readOnly:!0})],E.prototype,"frameHorizonPoints",null),t([n({readOnly:!0})],E.prototype,"groundControlPoints",null),t([n({type:w})],E.prototype,"initialExtent",void 0),t([n({readOnly:!0,json:{read:{source:"id"}}})],E.prototype,"layerId",void 0),t([n({type:Boolean})],E.prototype,"loop",null),t([n({readOnly:!0})],E.prototype,"metadata",null),t([n({type:Boolean})],E.prototype,"muted",null),t([n({type:v})],E.prototype,"playbackInfo",void 0),t([n({type:Number})],E.prototype,"playbackRate",null),t([n({type:String})],E.prototype,"playerUrl",null),t([n({readOnly:!0})],E.prototype,"playing",null),t([n({readOnly:!0,json:{read:{source:"poster"}}})],E.prototype,"posterUrl",void 0),t([n({type:String})],E.prototype,"protocol",void 0),t([n({readOnly:!0})],E.prototype,"qualities",void 0),t([n({readOnly:!0})],E.prototype,"serviceItemId",void 0),t([n()],E.prototype,"sourceJSON",void 0),t([n()],E.prototype,"sourceQuality",void 0),t([n({readOnly:!0,json:{name:"serviceType"}})],E.prototype,"sourceType",void 0),t([n()],E.prototype,"spatialReference",void 0),t([n({type:String})],E.prototype,"state",null),t([n({type:O})],E.prototype,"telemetry",null),t([n({type:S})],E.prototype,"telemetryDisplay",void 0),t([n({readOnly:!1,json:{read:{source:"name"}}})],E.prototype,"title",void 0),t([n({readOnly:!0})],E.prototype,"type",void 0),t([n(g)],E.prototype,"url",void 0),t([n({readOnly:!0})],E.prototype,"videoElement",null),t([n({readOnly:!0})],E.prototype,"videoHeight",null),t([n({readOnly:!0,nonNullable:!1,json:{read:{reader:I,source:"time"}}})],E.prototype,"videoTimeExtent",void 0),t([n({readOnly:!0})],E.prototype,"videoWidth",null),t([n({readOnly:!0})],E.prototype,"waiting",null),E=t([a("esri.layers.VideoLayer")],E);const J=E;export{J as default};
