/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../../geometry.js";import e from"../../../Graphic.js";import{isSome as t}from"../../../core/arrayUtils.js";import i from"../../../core/Logger.js";import{waitTick as o,throwIfAborted as r,isAbortError as s}from"../../../core/promiseUtils.js";import{transformPoints as a}from"../../../layers/orientedImagery/transformations/imageToGroundUtils.js";import{convertOrientationToPixelLocation as n}from"../../../layers/orientedImagery/transformations/utils.js";import{activePolygonSymbol as l,polygonSymbol as m}from"../symbols.js";import c from"../../../geometry/Polygon.js";class p{constructor(p){this.viewModel=p,this.createFootprints=async t=>{await o(t);const{coveragePolygons:i,currentBestFeature:r,isAdditionalCoverageVisible:s}=this.viewModel;for(const o of i)o?.imageID===r.attributes.objectId?this.viewModel.bestFeatureFootprint=new e({attributes:{imageID:o?.imageID},geometry:o,symbol:l,visible:!1}):this.viewModel.additionalFootprints.push(new e({attributes:{imageID:o?.imageID},geometry:o,symbol:m.clone(),visible:s}))},this.updateFootprint=async(o,n)=>{const{activeViewer:m,currentBestFeature:p,currentCoverageVisible:g,footprintExtent:u}=this.viewModel,f=m?.imageSize;if(p&&f&&u)try{const i=await a(o,{feature:p,imageProperties:{width:f[0],height:f[1]},options:n,footprintExtent:u});r(n);const s=i.filter(t);if(!s.length)return;const m=[s.map((({x:e,y:t})=>[e,t,1]))];m[0].push(m[0][0]);const d=new c({rings:m,spatialReference:s[0].spatialReference});this.viewModel.updateCurrentCoveragePolygon(new e({geometry:d,attributes:{imageID:p.attributes.objectId},symbol:l,visible:g}))}catch(d){s(d)||i.getLogger(this.viewModel).error("update-footprint",d)}},this.updateFootprintPanorama=async(t,i)=>{const{horizontalFieldOfView:o,pitch:s,verticalFieldOfView:m,yaw:p}=t,{activeViewer:g,currentBestFeature:u,currentCoverageVisible:f,footprintExtent:d}=this.viewModel,h=g?.imageSize;if(!u||!h||!d)return;const{cameraPitch:y,objectId:w}=u.attributes;if(s+y-m/2>180)return void this.viewModel.updateCurrentCoveragePolygon(null);let v=[];if(s+y+m/2<180){v=[[-o/2,m/2],[o/2,m/2],...s-m/2<0?[[-o/2,-m/2],[o/2,-m/2]]:[[o/2,-m/2],[-o/2,-m/2]]]}else if(s+y-m/2<180&&s+y+m/2>180){v=[[-o/2,-m/2]];const e=Math.floor(o/6),t=o/e;for(let i=0;i<=e;i++)v.push([i*t-o/2,90-s]);v.push([o/2,-m/2])}const b=v.map((([e,t])=>n(p+e,s+t,h[0],h[1]))),j=await a(b,{feature:u,imageProperties:{width:h[0],height:h[1]},options:i,footprintExtent:d});r(i);const I=[j.map((({x:e,y:t})=>[e,t,1]))];I[0].push(I[0][0]);const F=new c({rings:I,spatialReference:j[0].spatialReference});this.viewModel.updateCurrentCoveragePolygon(new e({geometry:F,attributes:{imageID:w},symbol:l.clone(),visible:f}))}}}export{p as default};
