/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../../geometry.js";import e from"../../../Graphic.js";import{isSome as t}from"../../../core/arrayUtils.js";import{throwIfAborted as i,waitTick as r}from"../../../core/promiseUtils.js";import{ensureType as o}from"../../../core/accessorSupport/ensureType.js";import a from"../../../geometry/Mesh.js";import{projectWithZConversion as s}from"../../../geometry/projection.js";import{MeshVertexAttributes as n}from"../../../geometry/support/MeshVertexAttributes.js";import{projectVertices as l,updateFrustum as c,createCoveragePolygon as m}from"../../../layers/orientedImagery/core/coverageUtils.js";import{transformPoints as p}from"../../../layers/orientedImagery/transformations/imageToGroundUtils.js";import{activeFrustumSymbol as u,additionalFrustumSymbol as f}from"../symbols.js";import g from"../../../geometry/Point.js";class w{constructor(g){this.viewModel=g,this.createFootprints=async r=>{const{coverageFrustums:o,currentBestFeature:c,isAdditionalCoverageVisible:m,view:p}=this.viewModel,g=o.filter(t);for(const t of g){let o=t.clone();if(!p.spatialReference.equals(o.spatialReference)){const{components:e,spatialReference:t,origin:c,vertexAttributes:m,vertexSpace:u}=o;if("local"===u.type){const e=await s(c,p.spatialReference,r);i(r),o.centerAt(e)}else{const s=m.position,c=Float64Array.from(await l([...s],t.clone(),p.spatialReference.clone(),r));i(r),o=new a({vertexAttributes:new n({position:c}),components:e,spatialReference:p.spatialReference.clone()})}}t.imageID===c.attributes.objectId?this.viewModel.bestFeatureFootprint=new e({attributes:{imageID:t.imageID},geometry:o,symbol:u.clone(),visible:!1}):this.viewModel.additionalFootprints.push(new e({attributes:{imageID:t.imageID},geometry:o,symbol:f.clone(),visible:m}))}},this.updateFootprint=async(r,n)=>{const{currentBestFeature:l,imagePointsInView:m,activeViewer:f,footprintExtent:g,view:w}=this.viewModel,y=o(a,this.viewModel.getCurrentBestFeaturePolygon().geometry),h=f?.imageSize;if(!(l&&y&&m&&h&&g))return;const{cameraHeight:v,location:b,cameraPitch:F,horizontalFieldOfView:R,verticalFieldOfView:j,cameraRoll:M,imageRotation:V}=l.attributes,I=b.toArray(),{vertexAttributes:{position:A},spatialReference:P}=y,x=await d(A,P,b.spatialReference),z=await p(r,{feature:l,imageProperties:{width:h[0],height:h[1]},options:n,footprintExtent:g});i(n);let C=z.filter(t);if(!C.length)return;C[0].spatialReference.equals(b.spatialReference)||(C=await Promise.all(C.map((async e=>{const t=await s(e,b.spatialReference,n);return i(n),t}))));const O=await c(m.slice(0,4).map((({x:e,y:t})=>[e,t])),C.slice(0,4).map((e=>e.toArray())),{cameraHeight:v,cameraLocation:I,cameraPitch:F,frustumVertices:x,horizontalFieldOfView:R,imageHeight:h[1],imageWidth:h[0],inSRS:{wkid:b.spatialReference.wkid},outSRS:{wkid:w.spatialReference.wkid},verticalFieldOfView:j,cameraRoll:M??0,imageRotation:V??0,options:n});this.viewModel.updateCurrentCoveragePolygon(new e({attributes:{imageID:l.attributes.objectId},geometry:O,symbol:u.clone(),visible:this.viewModel.currentCoverageVisible}))},this.updateFootprintPanorama=async(t,i)=>{await r(i);const{horizontalFieldOfView:o,pitch:a,verticalFieldOfView:s,yaw:n}=t,l=this.viewModel.currentBestFeature?.clone();if(!l)return;const{attributes:c}=l;c.orientedImageryType=null,c.cameraHeading=(n+c.cameraHeading)%360,c.cameraPitch=a,c.horizontalFieldOfView=o,c.verticalFieldOfView=s,c.cameraRoll=0;const{frustum:p}=m(c);p&&this.viewModel.updateCurrentCoveragePolygon(new e({attributes:{imageID:c.objectId},geometry:p,symbol:u.clone(),visible:this.viewModel.currentCoverageVisible}))}}updateGroundElevation(e,t){const{geometry:i}=this.viewModel.currentBestFeature,r=t.queryElevation(i);e.forEach((e=>{const{geometry:t}=e;switch(t?.type){case"mesh":{const{vertexAttributes:{position:e}}=t,i=Math.floor(e.length/3);for(let t=0;t<i;t+=1)e[3*t+2]+=r?.z??0;break}case"point":t.z=(t.z??0)+(r?.z??0)}}))}}async function d(e,t,i,r){return Float64Array.from((await Promise.all(e.reduce(((e,t,i)=>{const r=Math.floor(i/3);return e[r]=e[r]??[],e[r].push(t),e}),new Array).map((async e=>(await s(new g(e,t),i,r)).toArray())))).flat())}export{w as default};
